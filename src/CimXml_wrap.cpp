/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 1.3.19
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

#define SWIGPYTHON

#ifdef __cplusplus
template<class T> class SwigValueWrapper {
    T *tt;
public:
    inline SwigValueWrapper() : tt(0) { }
    inline ~SwigValueWrapper() { if (tt) delete tt; } 
    inline SwigValueWrapper& operator=(const T& t) { tt = new T(t); return *this; }
    inline operator T&() const { return *tt; }
    inline T *operator&() { return tt; }
};                                                    
#endif


#include "Python.h"

/***********************************************************************
 * common.swg
 *
 *     This file contains generic SWIG runtime support for pointer
 *     type checking as well as a few commonly used macros to control
 *     external linkage.
 *
 * Author : David Beazley (beazley@cs.uchicago.edu)
 *
 * Copyright (c) 1999-2000, The University of Chicago
 * 
 * This file may be freely redistributed without license or fee provided
 * this copyright message remains intact.
 ************************************************************************/

#include <string.h>

#if defined(_WIN32) || defined(__WIN32__)
#       if defined(_MSC_VER)
#               if defined(STATIC_LINKED)
#                       define SWIGEXPORT(a) a
#                       define SWIGIMPORT(a) extern a
#               else
#                       define SWIGEXPORT(a) __declspec(dllexport) a
#                       define SWIGIMPORT(a) extern a
#               endif
#       else
#               if defined(__BORLANDC__)
#                       define SWIGEXPORT(a) a _export
#                       define SWIGIMPORT(a) a _export
#               else
#                       define SWIGEXPORT(a) a
#                       define SWIGIMPORT(a) a
#               endif
#       endif
#else
#       define SWIGEXPORT(a) a
#       define SWIGIMPORT(a) a
#endif

#ifdef SWIG_GLOBAL
#define SWIGRUNTIME(a) SWIGEXPORT(a)
#else
#define SWIGRUNTIME(a) static a
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

typedef struct swig_type_info {
  const char             *name;                 
  swig_converter_func     converter;
  const char             *str;
  void                   *clientdata;	
  swig_dycast_func        dcast;
  struct swig_type_info  *next;
  struct swig_type_info  *prev;
} swig_type_info;

#ifdef SWIG_NOINCLUDE

SWIGIMPORT(swig_type_info *) SWIG_TypeRegister(swig_type_info *);
SWIGIMPORT(swig_type_info *) SWIG_TypeCheck(char *c, swig_type_info *);
SWIGIMPORT(void *)           SWIG_TypeCast(swig_type_info *, void *);
SWIGIMPORT(swig_type_info *) SWIG_TypeDynamicCast(swig_type_info *, void **);
SWIGIMPORT(const char *)     SWIG_TypeName(const swig_type_info *);
SWIGIMPORT(swig_type_info *) SWIG_TypeQuery(const char *);
SWIGIMPORT(void)             SWIG_TypeClientData(swig_type_info *, void *);

#else

static swig_type_info *swig_type_list = 0;

/* Register a type mapping with the type-checking */
SWIGRUNTIME(swig_type_info *)
SWIG_TypeRegister(swig_type_info *ti)
{
  swig_type_info *tc, *head, *ret, *next;
  /* Check to see if this type has already been registered */
  tc = swig_type_list;
  while (tc) {
    if (strcmp(tc->name, ti->name) == 0) {
      /* Already exists in the table.  Just add additional types to the list */
      if (tc->clientdata) ti->clientdata = tc->clientdata;	
      head = tc;
      next = tc->next;
      goto l1;
    }
    tc = tc->prev;
  }
  head = ti;
  next = 0;

  /* Place in list */
  ti->prev = swig_type_list;
  swig_type_list = ti;

  /* Build linked lists */
 l1:
  ret = head;
  tc = ti + 1;
  /* Patch up the rest of the links */
  while (tc->name) {
    head->next = tc;
    tc->prev = head;
    head = tc;
    tc++;
  }
  if (next) next->prev = head;  /**/
  head->next = next;
  return ret;
}

/* Check the typename */
SWIGRUNTIME(swig_type_info *) 
SWIG_TypeCheck(char *c, swig_type_info *ty)
{
  swig_type_info *s;
  if (!ty) return 0;        /* Void pointer */
  s = ty->next;             /* First element always just a name */
  do {
    if (strcmp(s->name,c) == 0) {
      if (s == ty->next) return s;
      /* Move s to the top of the linked list */
      s->prev->next = s->next;
      if (s->next) {
	s->next->prev = s->prev;
      }
      /* Insert s as second element in the list */
      s->next = ty->next;
      if (ty->next) ty->next->prev = s;
      ty->next = s;
      s->prev = ty;  /**/
      return s;
    }
    s = s->next;
  } while (s && (s != ty->next));
  return 0;
}

/* Cast a pointer up an inheritance hierarchy */
SWIGRUNTIME(void *) 
SWIG_TypeCast(swig_type_info *ty, void *ptr) 
{
  if ((!ty) || (!ty->converter)) return ptr;
  return (*ty->converter)(ptr);
}

/* Dynamic pointer casting. Down an inheritance hierarchy */
SWIGRUNTIME(swig_type_info *) 
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) 
{
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
     ty = (*ty->dcast)(ptr);
     if (ty) lastty = ty;
  }
  return lastty;
}

/* Return the name associated with this type */
SWIGRUNTIME(const char *)
SWIG_TypeName(const swig_type_info *ty) {
  return ty->name;
}

/* Search for a swig_type_info structure */
SWIGRUNTIME(swig_type_info *)
SWIG_TypeQuery(const char *name) {
  swig_type_info *ty = swig_type_list;
  while (ty) {
    if (ty->str && (strcmp(name,ty->str) == 0)) return ty;
    if (ty->name && (strcmp(name,ty->name) == 0)) return ty;
    ty = ty->prev;
  }
  return 0;
}

/* Set the clientdata field for a type */
SWIGRUNTIME(void)
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_type_info *tc, *equiv;
  if (ti->clientdata == clientdata) return;
  ti->clientdata = clientdata;
  equiv = ti->next;
  while (equiv) {
    if (!equiv->converter) {
      tc = swig_type_list;
      while (tc) {
	if ((strcmp(tc->name, equiv->name) == 0))
	  SWIG_TypeClientData(tc,clientdata);
	tc = tc->prev;
      }
    }
    equiv = equiv->next;
  }
}
#endif

#ifdef __cplusplus
}

#endif

/***********************************************************************
 * python.swg
 *
 *     This file contains the runtime support for Python modules
 *     and includes code for managing global variables and pointer
 *     type checking.
 *
 * Author : David Beazley (beazley@cs.uchicago.edu)
 ************************************************************************/

#include "Python.h"

#ifdef __cplusplus
extern "C" {
#endif

#define SWIG_PY_INT     1
#define SWIG_PY_FLOAT   2
#define SWIG_PY_STRING  3
#define SWIG_PY_POINTER 4
#define SWIG_PY_BINARY  5

/* Flags for pointer conversion */

#define SWIG_POINTER_EXCEPTION     0x1
#define SWIG_POINTER_DISOWN        0x2

/* Exception handling in wrappers */
#define SWIG_fail   goto fail

/* Constant information structure */
typedef struct swig_const_info {
    int type;
    char *name;
    long lvalue;
    double dvalue;
    void   *pvalue;
    swig_type_info **ptype;
} swig_const_info;

#ifdef SWIG_NOINCLUDE

SWIGEXPORT(PyObject *)        SWIG_newvarlink(void);
SWIGEXPORT(void)              SWIG_addvarlink(PyObject *, char *, PyObject *(*)(void), int (*)(PyObject *));
SWIGEXPORT(int)               SWIG_ConvertPtr(PyObject *, void **, swig_type_info *, int);
SWIGEXPORT(int)               SWIG_ConvertPacked(PyObject *, void *, int sz, swig_type_info *, int);
SWIGEXPORT(char *)            SWIG_PackData(char *c, void *, int);
SWIGEXPORT(char *)            SWIG_UnpackData(char *c, void *, int);
SWIGEXPORT(PyObject *)        SWIG_NewPointerObj(void *, swig_type_info *,int own);
SWIGEXPORT(PyObject *)        SWIG_NewPackedObj(void *, int sz, swig_type_info *);
SWIGEXPORT(void)              SWIG_InstallConstants(PyObject *d, swig_const_info constants[]);
#else

/* -----------------------------------------------------------------------------
 * global variable support code.
 * ----------------------------------------------------------------------------- */

typedef struct swig_globalvar {   
  char       *name;                  /* Name of global variable */
  PyObject *(*get_attr)(void);       /* Return the current value */
  int       (*set_attr)(PyObject *); /* Set the value */
  struct swig_globalvar *next;
} swig_globalvar;

typedef struct swig_varlinkobject {
  PyObject_HEAD
  swig_globalvar *vars;
} swig_varlinkobject;

static PyObject *
swig_varlink_repr(swig_varlinkobject *v) {
  v = v;
  return PyString_FromString("<Global variables>");
}

static int
swig_varlink_print(swig_varlinkobject *v, FILE *fp, int flags) {
  swig_globalvar  *var;
  flags = flags;
  fprintf(fp,"Global variables { ");
  for (var = v->vars; var; var=var->next) {
    fprintf(fp,"%s", var->name);
    if (var->next) fprintf(fp,", ");
  }
  fprintf(fp," }\n");
  return 0;
}

static PyObject *
swig_varlink_getattr(swig_varlinkobject *v, char *n) {
  swig_globalvar *var = v->vars;
  while (var) {
    if (strcmp(var->name,n) == 0) {
      return (*var->get_attr)();
    }
    var = var->next;
  }
  PyErr_SetString(PyExc_NameError,"Unknown C global variable");
  return NULL;
}

static int
swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p) {
  swig_globalvar *var = v->vars;
  while (var) {
    if (strcmp(var->name,n) == 0) {
      return (*var->set_attr)(p);
    }
    var = var->next;
  }
  PyErr_SetString(PyExc_NameError,"Unknown C global variable");
  return 1;
}

statichere PyTypeObject varlinktype = {
  PyObject_HEAD_INIT(0)              
  0,
  (char *)"swigvarlink",                      /* Type name    */
  sizeof(swig_varlinkobject),         /* Basic size   */
  0,                                  /* Itemsize     */
  0,                                  /* Deallocator  */ 
  (printfunc) swig_varlink_print,     /* Print        */
  (getattrfunc) swig_varlink_getattr, /* get attr     */
  (setattrfunc) swig_varlink_setattr, /* Set attr     */
  0,                                  /* tp_compare   */
  (reprfunc) swig_varlink_repr,       /* tp_repr      */    
  0,                                  /* tp_as_number */
  0,                                  /* tp_as_mapping*/
  0,                                  /* tp_hash      */
};

/* Create a variable linking object for use later */
SWIGRUNTIME(PyObject *)
SWIG_newvarlink(void) {
  swig_varlinkobject *result = 0;
  result = PyMem_NEW(swig_varlinkobject,1);
  varlinktype.ob_type = &PyType_Type;    /* Patch varlinktype into a PyType */
  result->ob_type = &varlinktype;
  result->vars = 0;
  result->ob_refcnt = 0;
  Py_XINCREF((PyObject *) result);
  return ((PyObject*) result);
}

SWIGRUNTIME(void)
SWIG_addvarlink(PyObject *p, char *name,
	   PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
  swig_varlinkobject *v;
  swig_globalvar *gv;
  v= (swig_varlinkobject *) p;
  gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
  gv->name = (char *) malloc(strlen(name)+1);
  strcpy(gv->name,name);
  gv->get_attr = get_attr;
  gv->set_attr = set_attr;
  gv->next = v->vars;
  v->vars = gv;
}

/* Pack binary data into a string */
SWIGRUNTIME(char *)
SWIG_PackData(char *c, void *ptr, int sz) {
  static char hex[17] = "0123456789abcdef";
  int i;
  unsigned char *u = (unsigned char *) ptr;
  register unsigned char uu;
  for (i = 0; i < sz; i++,u++) {
    uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/* Unpack binary data from a string */
SWIGRUNTIME(char *)
SWIG_UnpackData(char *c, void *ptr, int sz) {
  register unsigned char uu = 0;
  register int d;
  unsigned char *u = (unsigned char *) ptr;
  int i;
  for (i = 0; i < sz; i++, u++) {
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu = ((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = ((d - ('a'-10)) << 4);
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (d - ('a'-10));
    *u = uu;
  }
  return c;
}

/* Convert a pointer value */
SWIGRUNTIME(int)
SWIG_ConvertPtr(PyObject *obj, void **ptr, swig_type_info *ty, int flags) {
  swig_type_info *tc;
  char  *c;
  static PyObject *SWIG_this = 0;
  int    newref = 0;
  PyObject  *pyobj = 0;

  if (!obj) return 0;
  if (obj == Py_None) {
    *ptr = 0;
    return 0;
  }
#ifdef SWIG_COBJECT_TYPES
  if (!(PyCObject_Check(obj))) {
    if (!SWIG_this)
      SWIG_this = PyString_FromString("this");
    pyobj = obj;
    obj = PyObject_GetAttr(obj,SWIG_this);
    newref = 1;
    if (!obj) goto type_error;
    if (!PyCObject_Check(obj)) {
      Py_DECREF(obj);
      goto type_error;
    }
  }  
  *ptr = PyCObject_AsVoidPtr(obj);
  c = (char *) PyCObject_GetDesc(obj);
  if (newref) Py_DECREF(obj);
  goto cobject;
#else
  if (!(PyString_Check(obj))) {
    if (!SWIG_this)
      SWIG_this = PyString_FromString("this");
    pyobj = obj;
    obj = PyObject_GetAttr(obj,SWIG_this);
    newref = 1;
    if (!obj) goto type_error;
    if (!PyString_Check(obj)) {
      Py_DECREF(obj);
      goto type_error;
    }
  } 
  c = PyString_AsString(obj);
  /* Pointer values must start with leading underscore */
  if (*c != '_') {
    *ptr = (void *) 0;
    if (strcmp(c,"NULL") == 0) {
      if (newref) { Py_DECREF(obj); }
      return 0;
    } else {
      if (newref) { Py_DECREF(obj); }
      goto type_error;
    }
  }
  c++;
  c = SWIG_UnpackData(c,ptr,sizeof(void *));
  if (newref) { Py_DECREF(obj); }
#endif

#ifdef SWIG_COBJECT_TYPES
cobject:
#endif

  if (ty) {
    tc = SWIG_TypeCheck(c,ty);
    if (!tc) goto type_error;
    *ptr = SWIG_TypeCast(tc,(void*) *ptr);
  }

  if ((pyobj) && (flags & SWIG_POINTER_DISOWN)) {
      PyObject *zero = PyInt_FromLong(0);
      PyObject_SetAttrString(pyobj,(char*)"thisown",zero);
      Py_DECREF(zero);
  }
  return 0;

type_error:
  if (flags & SWIG_POINTER_EXCEPTION) {
    if (ty) {
      char *temp = (char *) malloc(64+strlen(ty->name));
      sprintf(temp,"Type error. Expected %s", ty->name);
      PyErr_SetString(PyExc_TypeError, temp);
      free((char *) temp);
    } else {
      PyErr_SetString(PyExc_TypeError,"Expected a pointer");
    }
  }
  return -1;
}

/* Convert a packed value value */
SWIGRUNTIME(int)
SWIG_ConvertPacked(PyObject *obj, void *ptr, int sz, swig_type_info *ty, int flags) {
  swig_type_info *tc;
  char  *c;

  if ((!obj) || (!PyString_Check(obj))) goto type_error;
  c = PyString_AsString(obj);
  /* Pointer values must start with leading underscore */
  if (*c != '_') goto type_error;
  c++;
  c = SWIG_UnpackData(c,ptr,sz);
  if (ty) {
    tc = SWIG_TypeCheck(c,ty);
    if (!tc) goto type_error;
  }
  return 0;

type_error:

  if (flags) {
    if (ty) {
      char *temp = (char *) malloc(64+strlen(ty->name));
      sprintf(temp,"Type error. Expected %s", ty->name);
      PyErr_SetString(PyExc_TypeError, temp);
      free((char *) temp);
    } else {
      PyErr_SetString(PyExc_TypeError,"Expected a pointer");
    }
  }
  return -1;
}

/* Create a new pointer object */
SWIGRUNTIME(PyObject *)
SWIG_NewPointerObj(void *ptr, swig_type_info *type, int own) {
  PyObject *robj;
  if (!ptr) {
    Py_INCREF(Py_None);
    return Py_None;
  }
#ifdef SWIG_COBJECT_TYPES
  robj = PyCObject_FromVoidPtrAndDesc((void *) ptr, (char *) type->name, NULL);
#else
  {
    char result[1024];
    char *r = result;
    *(r++) = '_';
    r = SWIG_PackData(r,&ptr,sizeof(void *));
    strcpy(r,type->name);
    robj = PyString_FromString(result);
  }
#endif
  if (!robj || (robj == Py_None)) return robj;
  if (type->clientdata) {
    PyObject *inst;
    PyObject *args = Py_BuildValue((char*)"(O)", robj);
    Py_DECREF(robj);
    inst = PyObject_CallObject((PyObject *) type->clientdata, args);
    Py_DECREF(args);
    if (inst) {
      if (own) {
	PyObject *n = PyInt_FromLong(1);
	PyObject_SetAttrString(inst,(char*)"thisown",n);
	Py_DECREF(n);
      }
      robj = inst;
    }
  }
  return robj;
}

SWIGRUNTIME(PyObject *)
SWIG_NewPackedObj(void *ptr, int sz, swig_type_info *type) {
  char result[1024];
  char *r = result;
  if ((2*sz + 1 + strlen(type->name)) > 1000) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  strcpy(r,type->name);
  return PyString_FromString(result);
}

/* Install Constants */
SWIGRUNTIME(void)
SWIG_InstallConstants(PyObject *d, swig_const_info constants[]) {
  int i;
  PyObject *obj;
  for (i = 0; constants[i].type; i++) {
    switch(constants[i].type) {
    case SWIG_PY_INT:
      obj = PyInt_FromLong(constants[i].lvalue);
      break;
    case SWIG_PY_FLOAT:
      obj = PyFloat_FromDouble(constants[i].dvalue);
      break;
    case SWIG_PY_STRING:
      obj = PyString_FromString((char *) constants[i].pvalue);
      break;
    case SWIG_PY_POINTER:
      obj = SWIG_NewPointerObj(constants[i].pvalue, *(constants[i]).ptype,0);
      break;
    case SWIG_PY_BINARY:
      obj = SWIG_NewPackedObj(constants[i].pvalue, constants[i].lvalue, *(constants[i].ptype));
      break;
    default:
      obj = 0;
      break;
    }
    if (obj) {
      PyDict_SetItemString(d,constants[i].name,obj);
      Py_DECREF(obj);
    }
  }
}

#endif

#ifdef __cplusplus
}
#endif








/* -------- TYPES TABLE (BEGIN) -------- */

#define  SWIGTYPE_p_KeyBindingXml swig_types[0] 
#define  SWIGTYPE_p_DoesNotExist swig_types[1] 
#define  SWIGTYPE_p_NameSpaceXml swig_types[2] 
#define  SWIGTYPE_p_CimomGhttp swig_types[3] 
#define  SWIGTYPE_p_AList swig_types[4] 
#define  SWIGTYPE_p_MethodXml swig_types[5] 
#define  SWIGTYPE_p_XmlBuffer swig_types[6] 
#define  SWIGTYPE_p_PropertyArray swig_types[7] 
#define  SWIGTYPE_p_ClassNameXml swig_types[8] 
#define  SWIGTYPE_p_InstanceNameXml swig_types[9] 
#define  SWIGTYPE_p_RetValXml swig_types[10] 
#define  SWIGTYPE_p_InstancePathArray swig_types[11] 
#define  SWIGTYPE_p_ClassesXml swig_types[12] 
#define  SWIGTYPE_p_std__vectorTPropertyXml_t swig_types[13] 
#define  SWIGTYPE_p_ArrayXmlTPropertyXml_t swig_types[14] 
#define  SWIGTYPE_p_ArrayIteratorTPropertyXml_t swig_types[15] 
#define  SWIGTYPE_p_ArrayIteratorTObjectWithPathXml_t swig_types[16] 
#define  SWIGTYPE_p_ArrayXmlTObjectWithPathXml_t swig_types[17] 
#define  SWIGTYPE_p_std__vectorTObjectWithPathXml_t swig_types[18] 
#define  SWIGTYPE_p_Cimom swig_types[19] 
#define  SWIGTYPE_p_URL swig_types[20] 
#define  SWIGTYPE_p_CimXml swig_types[21] 
#define  SWIGTYPE_p_ObjectsWithPathXml swig_types[22] 
#define  SWIGTYPE_p_InstancePathXml swig_types[23] 
#define  SWIGTYPE_p_NameSpacePathXml swig_types[24] 
#define  SWIGTYPE_p_LocalNameSpacePathXml swig_types[25] 
#define  SWIGTYPE_p_ObjectWithPathXml swig_types[26] 
#define  SWIGTYPE_p_InstanceNamesXml swig_types[27] 
#define  SWIGTYPE_p_ClassNamesXml swig_types[28] 
#define  SWIGTYPE_p_XmlAttr swig_types[29] 
#define  SWIGTYPE_p_CmdException swig_types[30] 
#define  SWIGTYPE_p_HttpException swig_types[31] 
#define  SWIGTYPE_p_ParseException swig_types[32] 
#define  SWIGTYPE_p_URLException swig_types[33] 
#define  SWIGTYPE_p_XmlException swig_types[34] 
#define  SWIGTYPE_p_KeyValueXml swig_types[35] 
#define  SWIGTYPE_p_ValueXml swig_types[36] 
#define  SWIGTYPE_p_IReturnvalueXml swig_types[37] 
#define  SWIGTYPE_p_InstancesXml swig_types[38] 
#define  SWIGTYPE_p_NamedInstancesXml swig_types[39] 
#define  SWIGTYPE_p_KeyBindingArray swig_types[40] 
#define  SWIGTYPE_p_StringArray swig_types[41] 
#define  SWIGTYPE_p_ErrorXml swig_types[42] 
#define  SWIGTYPE_p_IMethodresponseXml swig_types[43] 
#define  SWIGTYPE_p_InstanceArray swig_types[44] 
#define  SWIGTYPE_p_ArrayIteratorTKeyBindingXml_t swig_types[45] 
#define  SWIGTYPE_p_ArrayXmlTKeyBindingXml_t swig_types[46] 
#define  SWIGTYPE_p_std__vectorTKeyBindingXml_t swig_types[47] 
#define  SWIGTYPE_p_InstanceNameArray swig_types[48] 
#define  SWIGTYPE_p_OptionTstring_t swig_types[49] 
#define  SWIGTYPE_p_std__vectorTstring_t swig_types[50] 
#define  SWIGTYPE_p_QualifierXml swig_types[51] 
#define  SWIGTYPE_p_p_char swig_types[52] 
#define  SWIGTYPE_p_OptionTValueXml_t swig_types[53] 
#define  SWIGTYPE_p_ArrayIteratorTNamedInstanceXml_t swig_types[54] 
#define  SWIGTYPE_p_ArrayXmlTNamedInstanceXml_t swig_types[55] 
#define  SWIGTYPE_p_ArrayIteratorTClassNameXml_t swig_types[56] 
#define  SWIGTYPE_p_ArrayXmlTInstanceNameXml_t swig_types[57] 
#define  SWIGTYPE_p_ArrayXmlTNameSpaceXml_t swig_types[58] 
#define  SWIGTYPE_p_std__vectorTNamedInstanceXml_t swig_types[59] 
#define  SWIGTYPE_p_std__vectorTClassNameXml_t swig_types[60] 
#define  SWIGTYPE_p_std__vectorTInstanceXml_t swig_types[61] 
#define  SWIGTYPE_p_std__vectorTInstanceNameXml_t swig_types[62] 
#define  SWIGTYPE_p_std__vectorTNameSpaceXml_t swig_types[63] 
#define  SWIGTYPE_p_ArrayXmlTInstanceXml_t swig_types[64] 
#define  SWIGTYPE_p_ArrayXmlTClassNameXml_t swig_types[65] 
#define  SWIGTYPE_p_ArrayIteratorTNameSpaceXml_t swig_types[66] 
#define  SWIGTYPE_p_ArrayIteratorTInstanceNameXml_t swig_types[67] 
#define  SWIGTYPE_p_ArrayIteratorTInstanceXml_t swig_types[68] 
#define  SWIGTYPE_p_HostXml swig_types[69] 
#define  SWIGTYPE_p_ArrayIteratorTClassXml_t swig_types[70] 
#define  SWIGTYPE_p_std__vectorTClassXml_t swig_types[71] 
#define  SWIGTYPE_p_ArrayXmlTClassXml_t swig_types[72] 
#define  SWIGTYPE_p_NamedInstanceXml swig_types[73] 
#define  SWIGTYPE_p_InstanceXml swig_types[74] 
#define  SWIGTYPE_p_AVPs swig_types[75] 
#define  SWIGTYPE_p_AValue swig_types[76] 
#define  SWIGTYPE_p_SimplerspXml swig_types[77] 
#define  SWIGTYPE_p_string swig_types[78] 
#define  SWIGTYPE_p_MessageXml swig_types[79] 
#define  SWIGTYPE_p_ClassXml swig_types[80] 
#define  SWIGTYPE_p_PropertyXml swig_types[81] 
#define  SWIGTYPE_p_XmlElement swig_types[82] 
#define  SWIGTYPE_p_QualifierArray swig_types[83] 
static swig_type_info *swig_types[85];

/* -------- TYPES TABLE (END) -------- */


/*-----------------------------------------------
              @(target):= _CimXml.so
  ------------------------------------------------*/
#define SWIG_init    init_CimXml

#define SWIG_name    "_CimXml"


#include <stdexcept>
#include <cerrno>
#include <string>
#include <vector>

#include "Python.h"
#include "CimXml.h"

#ifdef LIBWWW
#else
#include "Cimghttp.h"
#endif



#include <string>

PyObject* SwigInt_FromBool(bool b) {
    return PyInt_FromLong(b ? 1L : 0L);
}
double SwigNumber_Check(PyObject* o) {
    return PyFloat_Check(o) || PyInt_Check(o) || PyLong_Check(o);
}
double SwigNumber_AsDouble(PyObject* o) {
    return PyFloat_Check(o) ? PyFloat_AsDouble(o) 
        : (PyInt_Check(o) ?   double(PyInt_AsLong(o))
                            : double(PyLong_AsLong(o)));
}
PyObject* SwigString_FromString(const std::string& s) {
    return PyString_FromStringAndSize(s.data(),s.size());
}
std::string SwigString_AsString(PyObject* o) {
    return std::string(PyString_AsString(o));
}


#define  SWIG_MemoryError    1
#define  SWIG_IOError        2
#define  SWIG_RuntimeError   3
#define  SWIG_IndexError     4
#define  SWIG_TypeError      5
#define  SWIG_DivisionByZero 6
#define  SWIG_OverflowError  7
#define  SWIG_SyntaxError    8
#define  SWIG_ValueError     9
#define  SWIG_SystemError   10
#define  SWIG_UnknownError  99


static void _SWIG_exception(int code, const char *msg) {
  switch(code) {
  case SWIG_MemoryError:
    PyErr_SetString(PyExc_MemoryError,msg);
    break;
  case SWIG_IOError:
    PyErr_SetString(PyExc_IOError,msg);
    break;
  case SWIG_RuntimeError:
    PyErr_SetString(PyExc_RuntimeError,msg);
    break;
  case SWIG_IndexError:
    PyErr_SetString(PyExc_IndexError,msg);
    break;
  case SWIG_TypeError:
    PyErr_SetString(PyExc_TypeError,msg);
    break;
  case SWIG_DivisionByZero:
    PyErr_SetString(PyExc_ZeroDivisionError,msg);
    break;
  case SWIG_OverflowError:
    PyErr_SetString(PyExc_OverflowError,msg);
    break;
  case SWIG_SyntaxError:
    PyErr_SetString(PyExc_SyntaxError,msg);
    break;
  case SWIG_ValueError:
    PyErr_SetString(PyExc_ValueError,msg);
    break;
  case SWIG_SystemError:
    PyErr_SetString(PyExc_SystemError,msg);
    break;
  default:
    PyErr_SetString(PyExc_RuntimeError,msg);
    break;
  }
}

#define SWIG_exception(a,b) { _SWIG_exception(a,b); SWIG_fail; }


#include <vector>
#include <algorithm>
#include <stdexcept>

bool std_vectorlNameSpaceXml_g___nonzero_____(std::vector<NameSpaceXml > *self){
                return !(self->empty());
            }
NameSpaceXml std_vectorlNameSpaceXml_g_pop___(std::vector<NameSpaceXml > *self){
                if (self->size() == 0)
                    throw std::out_of_range("pop from empty vector");
                NameSpaceXml x = self->back();
                self->pop_back();
                return x;
            }
NameSpaceXml &std_vectorlNameSpaceXml_g___getitem_____(std::vector<NameSpaceXml > *self,int i){
                int size = int(self->size());
                if (i<0) i += size;
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
std::vector<NameSpaceXml > std_vectorlNameSpaceXml_g___getslice_____(std::vector<NameSpaceXml > *self,int i,int j){
                int size = int(self->size());
                if (i<0) i = size+i;
                if (j<0) j = size+j;
                if (i<0) i = 0;
                if (j>size) j = size;
                std::vector<NameSpaceXml > tmp(j-i);
                std::copy(self->begin()+i,self->begin()+j,tmp.begin());
                return tmp;
            }
void std_vectorlNameSpaceXml_g___setitem_____(std::vector<NameSpaceXml > *self,int i,NameSpaceXml const &x){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    (*self)[i] = x;
                else
                    throw std::out_of_range("vector index out of range");
            }
void std_vectorlNameSpaceXml_g___setslice_____(std::vector<NameSpaceXml > *self,int i,int j,std::vector<NameSpaceXml > const &v){
                int size = int(self->size());
                if (i<0) i = size+i;
                if (j<0) j = size+j;
                if (i<0) i = 0;
                if (j>size) j = size;
                if (int(v.size()) == j-i) {
                    std::copy(v.begin(),v.end(),self->begin()+i);
                } else {
                    self->erase(self->begin()+i,self->begin()+j);
                    if (i+1 <= int(self->size())) {
                        self->insert(self->begin()+i,v.begin(),v.end());
                    } else {
                        self->insert(self->end(),v.begin(),v.end());
	            }
                }
            }
void std_vectorlNameSpaceXml_g___delitem_____(std::vector<NameSpaceXml > *self,int i){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    self->erase(self->begin()+i);
                else
                    throw std::out_of_range("vector index out of range");
            }
void std_vectorlNameSpaceXml_g___delslice_____(std::vector<NameSpaceXml > *self,int i,int j){
                int size = int(self->size());
                if (i<0) i = size+i;
                if (j<0) j = size+j;
                if (i<0) i = 0;
                if (j>size) j = size;
                self->erase(self->begin()+i,self->begin()+j);
            }
void ArrayXmllNameSpaceXml_g___setitem_____(ArrayXml<NameSpaceXml > *self,int key,NameSpaceXml *val){
    (*self)[key] = *val;
  }
NameSpaceXml *ArrayXmllNameSpaceXml_g___getitem_____(ArrayXml<NameSpaceXml > *self,int key){
    return &((*self)[key]); 
  }
string ArrayXmllNameSpaceXml_g___str_____(ArrayXml<NameSpaceXml > *self){ 
     string b;
     self->toStringBuffer(b,"\n"); 
     return b;
   }
ArrayIterator<NameSpaceXml > ArrayXmllNameSpaceXml_g___iter_____(ArrayXml<NameSpaceXml > *self){ return ArrayIterator<NameSpaceXml>(0, self); }
bool std_vectorlstring_g___nonzero_____(std::vector<string > *self){
                return !(self->empty());
            }
string std_vectorlstring_g_pop___(std::vector<string > *self){
                if (self->size() == 0)
                    throw std::out_of_range("pop from empty vector");
                string x = self->back();
                self->pop_back();
                return x;
            }
string &std_vectorlstring_g___getitem_____(std::vector<string > *self,int i){
                int size = int(self->size());
                if (i<0) i += size;
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
std::vector<string > std_vectorlstring_g___getslice_____(std::vector<string > *self,int i,int j){
                int size = int(self->size());
                if (i<0) i = size+i;
                if (j<0) j = size+j;
                if (i<0) i = 0;
                if (j>size) j = size;
                std::vector<string > tmp(j-i);
                std::copy(self->begin()+i,self->begin()+j,tmp.begin());
                return tmp;
            }
void std_vectorlstring_g___setitem_____(std::vector<string > *self,int i,string const &x){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    (*self)[i] = x;
                else
                    throw std::out_of_range("vector index out of range");
            }
void std_vectorlstring_g___setslice_____(std::vector<string > *self,int i,int j,std::vector<string > const &v){
                int size = int(self->size());
                if (i<0) i = size+i;
                if (j<0) j = size+j;
                if (i<0) i = 0;
                if (j>size) j = size;
                if (int(v.size()) == j-i) {
                    std::copy(v.begin(),v.end(),self->begin()+i);
                } else {
                    self->erase(self->begin()+i,self->begin()+j);
                    if (i+1 <= int(self->size())) {
                        self->insert(self->begin()+i,v.begin(),v.end());
                    } else {
                        self->insert(self->end(),v.begin(),v.end());
	            }
                }
            }
void std_vectorlstring_g___delitem_____(std::vector<string > *self,int i){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    self->erase(self->begin()+i);
                else
                    throw std::out_of_range("vector index out of range");
            }
void std_vectorlstring_g___delslice_____(std::vector<string > *self,int i,int j){
                int size = int(self->size());
                if (i<0) i = size+i;
                if (j<0) j = size+j;
                if (i<0) i = 0;
                if (j>size) j = size;
                self->erase(self->begin()+i,self->begin()+j);
            }
bool std_vectorlPropertyXml_g___nonzero_____(std::vector<PropertyXml > *self){
                return !(self->empty());
            }
PropertyXml std_vectorlPropertyXml_g_pop___(std::vector<PropertyXml > *self){
                if (self->size() == 0)
                    throw std::out_of_range("pop from empty vector");
                PropertyXml x = self->back();
                self->pop_back();
                return x;
            }
PropertyXml &std_vectorlPropertyXml_g___getitem_____(std::vector<PropertyXml > *self,int i){
                int size = int(self->size());
                if (i<0) i += size;
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
std::vector<PropertyXml > std_vectorlPropertyXml_g___getslice_____(std::vector<PropertyXml > *self,int i,int j){
                int size = int(self->size());
                if (i<0) i = size+i;
                if (j<0) j = size+j;
                if (i<0) i = 0;
                if (j>size) j = size;
                std::vector<PropertyXml > tmp(j-i);
                std::copy(self->begin()+i,self->begin()+j,tmp.begin());
                return tmp;
            }
void std_vectorlPropertyXml_g___setitem_____(std::vector<PropertyXml > *self,int i,PropertyXml const &x){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    (*self)[i] = x;
                else
                    throw std::out_of_range("vector index out of range");
            }
void std_vectorlPropertyXml_g___setslice_____(std::vector<PropertyXml > *self,int i,int j,std::vector<PropertyXml > const &v){
                int size = int(self->size());
                if (i<0) i = size+i;
                if (j<0) j = size+j;
                if (i<0) i = 0;
                if (j>size) j = size;
                if (int(v.size()) == j-i) {
                    std::copy(v.begin(),v.end(),self->begin()+i);
                } else {
                    self->erase(self->begin()+i,self->begin()+j);
                    if (i+1 <= int(self->size())) {
                        self->insert(self->begin()+i,v.begin(),v.end());
                    } else {
                        self->insert(self->end(),v.begin(),v.end());
	            }
                }
            }
void std_vectorlPropertyXml_g___delitem_____(std::vector<PropertyXml > *self,int i){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    self->erase(self->begin()+i);
                else
                    throw std::out_of_range("vector index out of range");
            }
void std_vectorlPropertyXml_g___delslice_____(std::vector<PropertyXml > *self,int i,int j){
                int size = int(self->size());
                if (i<0) i = size+i;
                if (j<0) j = size+j;
                if (i<0) i = 0;
                if (j>size) j = size;
                self->erase(self->begin()+i,self->begin()+j);
            }
void ArrayXmllPropertyXml_g___setitem_____(ArrayXml<PropertyXml > *self,int key,PropertyXml *val){
    (*self)[key] = *val;
  }
PropertyXml *ArrayXmllPropertyXml_g___getitem_______SWIG_0(ArrayXml<PropertyXml > *self,int key){
    return &((*self)[key]); 
  }
string ArrayXmllPropertyXml_g___str_____(ArrayXml<PropertyXml > *self){ 
     string b;
     self->toStringBuffer(b,"\n"); 
     return b;
   }
ArrayIterator<PropertyXml > ArrayXmllPropertyXml_g___iter_____(ArrayXml<PropertyXml > *self){ return ArrayIterator<PropertyXml>(0, self); }
ValueXml *ArrayXmllPropertyXml_g___getitem_______SWIG_1(ArrayXml<PropertyXml > *self,char *key){
    PropertyArray::iterator i;
    for(i=self->begin(); i != self->end(); i++) {
      if(strcasecmp(i->name.c_str(),key)==0) {
	return &i->value.val();
      }
    }
    throw std::range_error(string("The key ")+key+"is not in the dictionary.");
  }
void ArrayXmllPropertyXml_g___delitem_____(ArrayXml<PropertyXml > *self,string key,char *val){
    PropertyArray::iterator i;
    for(i=self->begin(); i != self->end(); i++) {
      if(strcasecmp(i->name.c_str(),key.c_str())==0) {
	self->erase(i);
	break;
      }
    }
  }
std::vector<string > ArrayXmllPropertyXml_g_keys___(ArrayXml<PropertyXml > *self){
    PropertyArray::iterator i;
    vector<string> the_keys;
    for(i=self->begin(); i != self->end(); i++) {
      the_keys.push_back(i->name);
    }
    return the_keys;
  }
bool std_vectorlInstanceNameXml_g___nonzero_____(std::vector<InstanceNameXml > *self){
                return !(self->empty());
            }
InstanceNameXml std_vectorlInstanceNameXml_g_pop___(std::vector<InstanceNameXml > *self){
                if (self->size() == 0)
                    throw std::out_of_range("pop from empty vector");
                InstanceNameXml x = self->back();
                self->pop_back();
                return x;
            }
InstanceNameXml &std_vectorlInstanceNameXml_g___getitem_____(std::vector<InstanceNameXml > *self,int i){
                int size = int(self->size());
                if (i<0) i += size;
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
std::vector<InstanceNameXml > std_vectorlInstanceNameXml_g___getslice_____(std::vector<InstanceNameXml > *self,int i,int j){
                int size = int(self->size());
                if (i<0) i = size+i;
                if (j<0) j = size+j;
                if (i<0) i = 0;
                if (j>size) j = size;
                std::vector<InstanceNameXml > tmp(j-i);
                std::copy(self->begin()+i,self->begin()+j,tmp.begin());
                return tmp;
            }
void std_vectorlInstanceNameXml_g___setitem_____(std::vector<InstanceNameXml > *self,int i,InstanceNameXml const &x){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    (*self)[i] = x;
                else
                    throw std::out_of_range("vector index out of range");
            }
void std_vectorlInstanceNameXml_g___setslice_____(std::vector<InstanceNameXml > *self,int i,int j,std::vector<InstanceNameXml > const &v){
                int size = int(self->size());
                if (i<0) i = size+i;
                if (j<0) j = size+j;
                if (i<0) i = 0;
                if (j>size) j = size;
                if (int(v.size()) == j-i) {
                    std::copy(v.begin(),v.end(),self->begin()+i);
                } else {
                    self->erase(self->begin()+i,self->begin()+j);
                    if (i+1 <= int(self->size())) {
                        self->insert(self->begin()+i,v.begin(),v.end());
                    } else {
                        self->insert(self->end(),v.begin(),v.end());
	            }
                }
            }
void std_vectorlInstanceNameXml_g___delitem_____(std::vector<InstanceNameXml > *self,int i){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    self->erase(self->begin()+i);
                else
                    throw std::out_of_range("vector index out of range");
            }
void std_vectorlInstanceNameXml_g___delslice_____(std::vector<InstanceNameXml > *self,int i,int j){
                int size = int(self->size());
                if (i<0) i = size+i;
                if (j<0) j = size+j;
                if (i<0) i = 0;
                if (j>size) j = size;
                self->erase(self->begin()+i,self->begin()+j);
            }
void ArrayXmllInstanceNameXml_g___setitem_____(ArrayXml<InstanceNameXml > *self,int key,InstanceNameXml *val){
    (*self)[key] = *val;
  }
InstanceNameXml *ArrayXmllInstanceNameXml_g___getitem_____(ArrayXml<InstanceNameXml > *self,int key){
    return &((*self)[key]); 
  }
string ArrayXmllInstanceNameXml_g___str_____(ArrayXml<InstanceNameXml > *self){ 
     string b;
     self->toStringBuffer(b,"\n"); 
     return b;
   }
ArrayIterator<InstanceNameXml > ArrayXmllInstanceNameXml_g___iter_____(ArrayXml<InstanceNameXml > *self){ return ArrayIterator<InstanceNameXml>(0, self); }
bool std_vectorlInstanceXml_g___nonzero_____(std::vector<InstanceXml > *self){
                return !(self->empty());
            }
InstanceXml std_vectorlInstanceXml_g_pop___(std::vector<InstanceXml > *self){
                if (self->size() == 0)
                    throw std::out_of_range("pop from empty vector");
                InstanceXml x = self->back();
                self->pop_back();
                return x;
            }
InstanceXml &std_vectorlInstanceXml_g___getitem_____(std::vector<InstanceXml > *self,int i){
                int size = int(self->size());
                if (i<0) i += size;
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
std::vector<InstanceXml > std_vectorlInstanceXml_g___getslice_____(std::vector<InstanceXml > *self,int i,int j){
                int size = int(self->size());
                if (i<0) i = size+i;
                if (j<0) j = size+j;
                if (i<0) i = 0;
                if (j>size) j = size;
                std::vector<InstanceXml > tmp(j-i);
                std::copy(self->begin()+i,self->begin()+j,tmp.begin());
                return tmp;
            }
void std_vectorlInstanceXml_g___setitem_____(std::vector<InstanceXml > *self,int i,InstanceXml const &x){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    (*self)[i] = x;
                else
                    throw std::out_of_range("vector index out of range");
            }
void std_vectorlInstanceXml_g___setslice_____(std::vector<InstanceXml > *self,int i,int j,std::vector<InstanceXml > const &v){
                int size = int(self->size());
                if (i<0) i = size+i;
                if (j<0) j = size+j;
                if (i<0) i = 0;
                if (j>size) j = size;
                if (int(v.size()) == j-i) {
                    std::copy(v.begin(),v.end(),self->begin()+i);
                } else {
                    self->erase(self->begin()+i,self->begin()+j);
                    if (i+1 <= int(self->size())) {
                        self->insert(self->begin()+i,v.begin(),v.end());
                    } else {
                        self->insert(self->end(),v.begin(),v.end());
	            }
                }
            }
void std_vectorlInstanceXml_g___delitem_____(std::vector<InstanceXml > *self,int i){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    self->erase(self->begin()+i);
                else
                    throw std::out_of_range("vector index out of range");
            }
void std_vectorlInstanceXml_g___delslice_____(std::vector<InstanceXml > *self,int i,int j){
                int size = int(self->size());
                if (i<0) i = size+i;
                if (j<0) j = size+j;
                if (i<0) i = 0;
                if (j>size) j = size;
                self->erase(self->begin()+i,self->begin()+j);
            }
void ArrayXmllInstanceXml_g___setitem_____(ArrayXml<InstanceXml > *self,int key,InstanceXml *val){
    (*self)[key] = *val;
  }
InstanceXml *ArrayXmllInstanceXml_g___getitem_____(ArrayXml<InstanceXml > *self,int key){
    return &((*self)[key]); 
  }
string ArrayXmllInstanceXml_g___str_____(ArrayXml<InstanceXml > *self){ 
     string b;
     self->toStringBuffer(b,"\n"); 
     return b;
   }
ArrayIterator<InstanceXml > ArrayXmllInstanceXml_g___iter_____(ArrayXml<InstanceXml > *self){ return ArrayIterator<InstanceXml>(0, self); }
bool std_vectorlKeyBindingXml_g___nonzero_____(std::vector<KeyBindingXml > *self){
                return !(self->empty());
            }
KeyBindingXml std_vectorlKeyBindingXml_g_pop___(std::vector<KeyBindingXml > *self){
                if (self->size() == 0)
                    throw std::out_of_range("pop from empty vector");
                KeyBindingXml x = self->back();
                self->pop_back();
                return x;
            }
KeyBindingXml &std_vectorlKeyBindingXml_g___getitem_____(std::vector<KeyBindingXml > *self,int i){
                int size = int(self->size());
                if (i<0) i += size;
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
std::vector<KeyBindingXml > std_vectorlKeyBindingXml_g___getslice_____(std::vector<KeyBindingXml > *self,int i,int j){
                int size = int(self->size());
                if (i<0) i = size+i;
                if (j<0) j = size+j;
                if (i<0) i = 0;
                if (j>size) j = size;
                std::vector<KeyBindingXml > tmp(j-i);
                std::copy(self->begin()+i,self->begin()+j,tmp.begin());
                return tmp;
            }
void std_vectorlKeyBindingXml_g___setitem_____(std::vector<KeyBindingXml > *self,int i,KeyBindingXml const &x){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    (*self)[i] = x;
                else
                    throw std::out_of_range("vector index out of range");
            }
void std_vectorlKeyBindingXml_g___setslice_____(std::vector<KeyBindingXml > *self,int i,int j,std::vector<KeyBindingXml > const &v){
                int size = int(self->size());
                if (i<0) i = size+i;
                if (j<0) j = size+j;
                if (i<0) i = 0;
                if (j>size) j = size;
                if (int(v.size()) == j-i) {
                    std::copy(v.begin(),v.end(),self->begin()+i);
                } else {
                    self->erase(self->begin()+i,self->begin()+j);
                    if (i+1 <= int(self->size())) {
                        self->insert(self->begin()+i,v.begin(),v.end());
                    } else {
                        self->insert(self->end(),v.begin(),v.end());
	            }
                }
            }
void std_vectorlKeyBindingXml_g___delitem_____(std::vector<KeyBindingXml > *self,int i){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    self->erase(self->begin()+i);
                else
                    throw std::out_of_range("vector index out of range");
            }
void std_vectorlKeyBindingXml_g___delslice_____(std::vector<KeyBindingXml > *self,int i,int j){
                int size = int(self->size());
                if (i<0) i = size+i;
                if (j<0) j = size+j;
                if (i<0) i = 0;
                if (j>size) j = size;
                self->erase(self->begin()+i,self->begin()+j);
            }
void ArrayXmllKeyBindingXml_g___setitem_____(ArrayXml<KeyBindingXml > *self,int key,KeyBindingXml *val){
    (*self)[key] = *val;
  }
KeyBindingXml *ArrayXmllKeyBindingXml_g___getitem_____(ArrayXml<KeyBindingXml > *self,int key){
    return &((*self)[key]); 
  }
string ArrayXmllKeyBindingXml_g___str_____(ArrayXml<KeyBindingXml > *self){ 
     string b;
     self->toStringBuffer(b,"\n"); 
     return b;
   }
ArrayIterator<KeyBindingXml > ArrayXmllKeyBindingXml_g___iter_____(ArrayXml<KeyBindingXml > *self){ return ArrayIterator<KeyBindingXml>(0, self); }
bool std_vectorlClassNameXml_g___nonzero_____(std::vector<ClassNameXml > *self){
                return !(self->empty());
            }
ClassNameXml std_vectorlClassNameXml_g_pop___(std::vector<ClassNameXml > *self){
                if (self->size() == 0)
                    throw std::out_of_range("pop from empty vector");
                ClassNameXml x = self->back();
                self->pop_back();
                return x;
            }
ClassNameXml &std_vectorlClassNameXml_g___getitem_____(std::vector<ClassNameXml > *self,int i){
                int size = int(self->size());
                if (i<0) i += size;
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
std::vector<ClassNameXml > std_vectorlClassNameXml_g___getslice_____(std::vector<ClassNameXml > *self,int i,int j){
                int size = int(self->size());
                if (i<0) i = size+i;
                if (j<0) j = size+j;
                if (i<0) i = 0;
                if (j>size) j = size;
                std::vector<ClassNameXml > tmp(j-i);
                std::copy(self->begin()+i,self->begin()+j,tmp.begin());
                return tmp;
            }
void std_vectorlClassNameXml_g___setitem_____(std::vector<ClassNameXml > *self,int i,ClassNameXml const &x){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    (*self)[i] = x;
                else
                    throw std::out_of_range("vector index out of range");
            }
void std_vectorlClassNameXml_g___setslice_____(std::vector<ClassNameXml > *self,int i,int j,std::vector<ClassNameXml > const &v){
                int size = int(self->size());
                if (i<0) i = size+i;
                if (j<0) j = size+j;
                if (i<0) i = 0;
                if (j>size) j = size;
                if (int(v.size()) == j-i) {
                    std::copy(v.begin(),v.end(),self->begin()+i);
                } else {
                    self->erase(self->begin()+i,self->begin()+j);
                    if (i+1 <= int(self->size())) {
                        self->insert(self->begin()+i,v.begin(),v.end());
                    } else {
                        self->insert(self->end(),v.begin(),v.end());
	            }
                }
            }
void std_vectorlClassNameXml_g___delitem_____(std::vector<ClassNameXml > *self,int i){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    self->erase(self->begin()+i);
                else
                    throw std::out_of_range("vector index out of range");
            }
void std_vectorlClassNameXml_g___delslice_____(std::vector<ClassNameXml > *self,int i,int j){
                int size = int(self->size());
                if (i<0) i = size+i;
                if (j<0) j = size+j;
                if (i<0) i = 0;
                if (j>size) j = size;
                self->erase(self->begin()+i,self->begin()+j);
            }
void ArrayXmllClassNameXml_g___setitem_____(ArrayXml<ClassNameXml > *self,int key,ClassNameXml *val){
    (*self)[key] = *val;
  }
ClassNameXml *ArrayXmllClassNameXml_g___getitem_____(ArrayXml<ClassNameXml > *self,int key){
    return &((*self)[key]); 
  }
string ArrayXmllClassNameXml_g___str_____(ArrayXml<ClassNameXml > *self){ 
     string b;
     self->toStringBuffer(b,"\n"); 
     return b;
   }
ArrayIterator<ClassNameXml > ArrayXmllClassNameXml_g___iter_____(ArrayXml<ClassNameXml > *self){ return ArrayIterator<ClassNameXml>(0, self); }
bool std_vectorlClassXml_g___nonzero_____(std::vector<ClassXml > *self){
                return !(self->empty());
            }
ClassXml std_vectorlClassXml_g_pop___(std::vector<ClassXml > *self){
                if (self->size() == 0)
                    throw std::out_of_range("pop from empty vector");
                ClassXml x = self->back();
                self->pop_back();
                return x;
            }
ClassXml &std_vectorlClassXml_g___getitem_____(std::vector<ClassXml > *self,int i){
                int size = int(self->size());
                if (i<0) i += size;
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
std::vector<ClassXml > std_vectorlClassXml_g___getslice_____(std::vector<ClassXml > *self,int i,int j){
                int size = int(self->size());
                if (i<0) i = size+i;
                if (j<0) j = size+j;
                if (i<0) i = 0;
                if (j>size) j = size;
                std::vector<ClassXml > tmp(j-i);
                std::copy(self->begin()+i,self->begin()+j,tmp.begin());
                return tmp;
            }
void std_vectorlClassXml_g___setitem_____(std::vector<ClassXml > *self,int i,ClassXml const &x){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    (*self)[i] = x;
                else
                    throw std::out_of_range("vector index out of range");
            }
void std_vectorlClassXml_g___setslice_____(std::vector<ClassXml > *self,int i,int j,std::vector<ClassXml > const &v){
                int size = int(self->size());
                if (i<0) i = size+i;
                if (j<0) j = size+j;
                if (i<0) i = 0;
                if (j>size) j = size;
                if (int(v.size()) == j-i) {
                    std::copy(v.begin(),v.end(),self->begin()+i);
                } else {
                    self->erase(self->begin()+i,self->begin()+j);
                    if (i+1 <= int(self->size())) {
                        self->insert(self->begin()+i,v.begin(),v.end());
                    } else {
                        self->insert(self->end(),v.begin(),v.end());
	            }
                }
            }
void std_vectorlClassXml_g___delitem_____(std::vector<ClassXml > *self,int i){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    self->erase(self->begin()+i);
                else
                    throw std::out_of_range("vector index out of range");
            }
void std_vectorlClassXml_g___delslice_____(std::vector<ClassXml > *self,int i,int j){
                int size = int(self->size());
                if (i<0) i = size+i;
                if (j<0) j = size+j;
                if (i<0) i = 0;
                if (j>size) j = size;
                self->erase(self->begin()+i,self->begin()+j);
            }
void ArrayXmllClassXml_g___setitem_____(ArrayXml<ClassXml > *self,int key,ClassXml *val){
    (*self)[key] = *val;
  }
ClassXml *ArrayXmllClassXml_g___getitem_____(ArrayXml<ClassXml > *self,int key){
    return &((*self)[key]); 
  }
string ArrayXmllClassXml_g___str_____(ArrayXml<ClassXml > *self){ 
     string b;
     self->toStringBuffer(b,"\n"); 
     return b;
   }
ArrayIterator<ClassXml > ArrayXmllClassXml_g___iter_____(ArrayXml<ClassXml > *self){ return ArrayIterator<ClassXml>(0, self); }
bool std_vectorlObjectWithPathXml_g___nonzero_____(std::vector<ObjectWithPathXml > *self){
                return !(self->empty());
            }
ObjectWithPathXml std_vectorlObjectWithPathXml_g_pop___(std::vector<ObjectWithPathXml > *self){
                if (self->size() == 0)
                    throw std::out_of_range("pop from empty vector");
                ObjectWithPathXml x = self->back();
                self->pop_back();
                return x;
            }
ObjectWithPathXml &std_vectorlObjectWithPathXml_g___getitem_____(std::vector<ObjectWithPathXml > *self,int i){
                int size = int(self->size());
                if (i<0) i += size;
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
std::vector<ObjectWithPathXml > std_vectorlObjectWithPathXml_g___getslice_____(std::vector<ObjectWithPathXml > *self,int i,int j){
                int size = int(self->size());
                if (i<0) i = size+i;
                if (j<0) j = size+j;
                if (i<0) i = 0;
                if (j>size) j = size;
                std::vector<ObjectWithPathXml > tmp(j-i);
                std::copy(self->begin()+i,self->begin()+j,tmp.begin());
                return tmp;
            }
void std_vectorlObjectWithPathXml_g___setitem_____(std::vector<ObjectWithPathXml > *self,int i,ObjectWithPathXml const &x){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    (*self)[i] = x;
                else
                    throw std::out_of_range("vector index out of range");
            }
void std_vectorlObjectWithPathXml_g___setslice_____(std::vector<ObjectWithPathXml > *self,int i,int j,std::vector<ObjectWithPathXml > const &v){
                int size = int(self->size());
                if (i<0) i = size+i;
                if (j<0) j = size+j;
                if (i<0) i = 0;
                if (j>size) j = size;
                if (int(v.size()) == j-i) {
                    std::copy(v.begin(),v.end(),self->begin()+i);
                } else {
                    self->erase(self->begin()+i,self->begin()+j);
                    if (i+1 <= int(self->size())) {
                        self->insert(self->begin()+i,v.begin(),v.end());
                    } else {
                        self->insert(self->end(),v.begin(),v.end());
	            }
                }
            }
void std_vectorlObjectWithPathXml_g___delitem_____(std::vector<ObjectWithPathXml > *self,int i){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    self->erase(self->begin()+i);
                else
                    throw std::out_of_range("vector index out of range");
            }
void std_vectorlObjectWithPathXml_g___delslice_____(std::vector<ObjectWithPathXml > *self,int i,int j){
                int size = int(self->size());
                if (i<0) i = size+i;
                if (j<0) j = size+j;
                if (i<0) i = 0;
                if (j>size) j = size;
                self->erase(self->begin()+i,self->begin()+j);
            }
void ArrayXmllObjectWithPathXml_g___setitem_____(ArrayXml<ObjectWithPathXml > *self,int key,ObjectWithPathXml *val){
    (*self)[key] = *val;
  }
ObjectWithPathXml *ArrayXmllObjectWithPathXml_g___getitem_____(ArrayXml<ObjectWithPathXml > *self,int key){
    return &((*self)[key]); 
  }
string ArrayXmllObjectWithPathXml_g___str_____(ArrayXml<ObjectWithPathXml > *self){ 
     string b;
     self->toStringBuffer(b,"\n"); 
     return b;
   }
ArrayIterator<ObjectWithPathXml > ArrayXmllObjectWithPathXml_g___iter_____(ArrayXml<ObjectWithPathXml > *self){ return ArrayIterator<ObjectWithPathXml>(0, self); }
bool std_vectorlNamedInstanceXml_g___nonzero_____(std::vector<NamedInstanceXml > *self){
                return !(self->empty());
            }
NamedInstanceXml std_vectorlNamedInstanceXml_g_pop___(std::vector<NamedInstanceXml > *self){
                if (self->size() == 0)
                    throw std::out_of_range("pop from empty vector");
                NamedInstanceXml x = self->back();
                self->pop_back();
                return x;
            }
NamedInstanceXml &std_vectorlNamedInstanceXml_g___getitem_____(std::vector<NamedInstanceXml > *self,int i){
                int size = int(self->size());
                if (i<0) i += size;
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
std::vector<NamedInstanceXml > std_vectorlNamedInstanceXml_g___getslice_____(std::vector<NamedInstanceXml > *self,int i,int j){
                int size = int(self->size());
                if (i<0) i = size+i;
                if (j<0) j = size+j;
                if (i<0) i = 0;
                if (j>size) j = size;
                std::vector<NamedInstanceXml > tmp(j-i);
                std::copy(self->begin()+i,self->begin()+j,tmp.begin());
                return tmp;
            }
void std_vectorlNamedInstanceXml_g___setitem_____(std::vector<NamedInstanceXml > *self,int i,NamedInstanceXml const &x){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    (*self)[i] = x;
                else
                    throw std::out_of_range("vector index out of range");
            }
void std_vectorlNamedInstanceXml_g___setslice_____(std::vector<NamedInstanceXml > *self,int i,int j,std::vector<NamedInstanceXml > const &v){
                int size = int(self->size());
                if (i<0) i = size+i;
                if (j<0) j = size+j;
                if (i<0) i = 0;
                if (j>size) j = size;
                if (int(v.size()) == j-i) {
                    std::copy(v.begin(),v.end(),self->begin()+i);
                } else {
                    self->erase(self->begin()+i,self->begin()+j);
                    if (i+1 <= int(self->size())) {
                        self->insert(self->begin()+i,v.begin(),v.end());
                    } else {
                        self->insert(self->end(),v.begin(),v.end());
	            }
                }
            }
void std_vectorlNamedInstanceXml_g___delitem_____(std::vector<NamedInstanceXml > *self,int i){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    self->erase(self->begin()+i);
                else
                    throw std::out_of_range("vector index out of range");
            }
void std_vectorlNamedInstanceXml_g___delslice_____(std::vector<NamedInstanceXml > *self,int i,int j){
                int size = int(self->size());
                if (i<0) i = size+i;
                if (j<0) j = size+j;
                if (i<0) i = 0;
                if (j>size) j = size;
                self->erase(self->begin()+i,self->begin()+j);
            }
void ArrayXmllNamedInstanceXml_g___setitem_____(ArrayXml<NamedInstanceXml > *self,int key,NamedInstanceXml *val){
    (*self)[key] = *val;
  }
NamedInstanceXml *ArrayXmllNamedInstanceXml_g___getitem_____(ArrayXml<NamedInstanceXml > *self,int key){
    return &((*self)[key]); 
  }
string ArrayXmllNamedInstanceXml_g___str_____(ArrayXml<NamedInstanceXml > *self){ 
     string b;
     self->toStringBuffer(b,"\n"); 
     return b;
   }
ArrayIterator<NamedInstanceXml > ArrayXmllNamedInstanceXml_g___iter_____(ArrayXml<NamedInstanceXml > *self){ return ArrayIterator<NamedInstanceXml>(0, self); }
string KeyValueXml___str__(KeyValueXml *self){ string b; self->toStringBuffer(b,""); return b; }
string RetValXml___str__(RetValXml *self){ string b; self->toStringBuffer(b,""); return b; }
long long RetValXml___long__(RetValXml *self){ 
     string b; char *p=0; long long val;
     self->toStringBuffer(b,""); 
     errno = 0;
     val = strtoll(b.c_str(), &p, 10); 
     if(errno==ERANGE) {
       errno=0; 
       throw std::runtime_error(b+"is to large to be a long");
     }
     return val;
     }
string KeyBindingXml___str__(KeyBindingXml *self){ string b; self->toStringBuffer(b,""); return b; }
string PropertyXml___str__(PropertyXml *self){ string b; self->toStringBuffer(b,""); return b; }
string URL___str__(URL *self){ 
  string b;
  self->toStringBuffer(b,0);
  b = string("http://")+b; 
  return b; 
}
#ifdef __cplusplus
extern "C" {
#endif
static PyObject *_wrap_XmlBuffer_cur_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    XmlBuffer *arg1 = (XmlBuffer *) 0 ;
    char *arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Os:XmlBuffer_cur_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_XmlBuffer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        if (arg1->cur) delete [] arg1->cur;
        if (arg2) {
            arg1->cur = (char *) (new char[strlen(arg2)+1]);
            strcpy((char *) arg1->cur,arg2);
        }else {
            arg1->cur = 0;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_XmlBuffer_cur_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    XmlBuffer *arg1 = (XmlBuffer *) 0 ;
    char *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:XmlBuffer_cur_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_XmlBuffer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (char *) ((arg1)->cur);
    
    resultobj = result ? PyString_FromString(result) : Py_BuildValue((char*)"");
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_XmlBuffer(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    string arg1 ;
    XmlBuffer *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:new_XmlBuffer",&obj0)) goto fail;
    {
        arg1 = PyString_AsString(resultobj);
        if (PyErr_Occurred()) return NULL;
    }
    {
        try {
            result = (XmlBuffer *)new XmlBuffer(arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_XmlBuffer, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_XmlBuffer_skipWS(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    XmlBuffer *arg1 = (XmlBuffer *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:XmlBuffer_skipWS",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_XmlBuffer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            (arg1)->skipWS();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_XmlBuffer_getChar__SWIG_0(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    XmlBuffer *arg1 = (XmlBuffer *) 0 ;
    char arg2 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oc:XmlBuffer_getChar",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_XmlBuffer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (int)(arg1)->getChar(arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_XmlBuffer_getChar__SWIG_1(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    XmlBuffer *arg1 = (XmlBuffer *) 0 ;
    char *arg2 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Os:XmlBuffer_getChar",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_XmlBuffer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (int)(arg1)->getChar((char const *)arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_XmlBuffer_getChar(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[3];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_XmlBuffer, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            }else {
                _v = 1;
            }
        }
        if (_v) {
            {
                _v = (PyString_Check(argv[1]) && (PyString_Size(argv[1]) == 1)) ? 1 : 0;
            }
            if (_v) {
                return _wrap_XmlBuffer_getChar__SWIG_0(self,args);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_XmlBuffer, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            }else {
                _v = 1;
            }
        }
        if (_v) {
            {
                _v = PyString_Check(argv[1]) ? 1 : 0;
            }
            if (_v) {
                return _wrap_XmlBuffer_getChar__SWIG_1(self,args);
            }
        }
    }
    
    PyErr_SetString(PyExc_TypeError,"No matching function for overloaded 'XmlBuffer_getChar'");
    return NULL;
}


static PyObject *_wrap_XmlBuffer_getWord(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    XmlBuffer *arg1 = (XmlBuffer *) 0 ;
    char *arg2 ;
    int arg3 = (int) 1 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Os|i:XmlBuffer_getWord",&obj0,&arg2,&arg3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_XmlBuffer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (int)(arg1)->getWord((char const *)arg2,arg3);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_XmlBuffer_nextTag(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    XmlBuffer *arg1 = (XmlBuffer *) 0 ;
    char *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:XmlBuffer_nextTag",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_XmlBuffer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (char *)(arg1)->nextTag();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = result ? PyString_FromString(result) : Py_BuildValue((char*)"");
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_XmlBuffer_nextEquals(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    XmlBuffer *arg1 = (XmlBuffer *) 0 ;
    char *arg2 ;
    char *arg3 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oss:XmlBuffer_nextEquals",&obj0,&arg2,&arg3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_XmlBuffer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (int)(arg1)->nextEquals((char const *)arg2,(char const *)arg3);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_XmlBuffer_xmlHdr(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    XmlBuffer *arg1 = (XmlBuffer *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:XmlBuffer_xmlHdr",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_XmlBuffer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (int)(arg1)->xmlHdr();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_XmlBuffer_tagEquals(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    XmlBuffer *arg1 = (XmlBuffer *) 0 ;
    char *arg2 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Os:XmlBuffer_tagEquals",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_XmlBuffer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (int)(arg1)->tagEquals((char const *)arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_XmlBuffer_endTag(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    XmlBuffer *arg1 = (XmlBuffer *) 0 ;
    char *arg2 ;
    XmlAttr *arg3 = (XmlAttr *) NULL ;
    int result;
    PyObject * obj0 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Os|O:XmlBuffer_endTag",&obj0,&arg2,&obj2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_XmlBuffer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (obj2) {
        if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_XmlAttr,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    }
    {
        try {
            result = (int)(arg1)->endTag((char const *)arg2,(XmlAttr const *)arg3);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_XmlBuffer_attrsOk(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    XmlBuffer *arg1 = (XmlBuffer *) 0 ;
    XmlElement *arg2 = 0 ;
    XmlAttr *arg3 = 0 ;
    char *arg4 ;
    int result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOs:XmlBuffer_attrsOk",&obj0,&obj1,&obj2,&arg4)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_XmlBuffer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_XmlElement,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_XmlAttr,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg3 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            result = (int)(arg1)->attrsOk((XmlElement const &)*arg2,*arg3,(char const *)arg4);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_XmlBuffer_getValue(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    XmlBuffer *arg1 = (XmlBuffer *) 0 ;
    char *arg2 = (char *) NULL ;
    string result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O|s:XmlBuffer_getValue",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_XmlBuffer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (arg1)->getValue((char const *)arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    {
        resultobj = PyString_FromString((&result)->c_str());
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_XmlBuffer_getContent(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    XmlBuffer *arg1 = (XmlBuffer *) 0 ;
    XmlAttr *arg2 = (XmlAttr *) 0 ;
    char *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:XmlBuffer_getContent",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_XmlBuffer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_XmlAttr,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (char *)(arg1)->getContent((XmlAttr const *)arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = result ? PyString_FromString(result) : Py_BuildValue((char*)"");
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_XmlBuffer_skipElement(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    XmlBuffer *arg1 = (XmlBuffer *) 0 ;
    char *arg2 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Os:XmlBuffer_skipElement",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_XmlBuffer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (int)(arg1)->skipElement((char const *)arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_XmlBuffer_testAttr(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    XmlBuffer *arg1 = (XmlBuffer *) 0 ;
    char *arg2 ;
    char *arg3 ;
    int arg4 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Ossi:XmlBuffer_testAttr",&obj0,&arg2,&arg3,&arg4)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_XmlBuffer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (int)(arg1)->testAttr(arg2,arg3,arg4);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_XmlBuffer(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    XmlBuffer *arg1 = (XmlBuffer *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_XmlBuffer",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_XmlBuffer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * XmlBuffer_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_XmlBuffer, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_new_NameSpaceVector__SWIG_0(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    unsigned int arg1 = (unsigned int) 0 ;
    std::vector<NameSpaceXml > *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"|O:new_NameSpaceVector",&obj0)) goto fail;
    if (obj0) {
        arg1 = (unsigned int) PyInt_AsLong(obj0);
        if (PyErr_Occurred()) SWIG_fail;
    }
    {
        try {
            result = (std::vector<NameSpaceXml > *)new std::vector<NameSpaceXml >(arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__vectorTNameSpaceXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_NameSpaceVector__SWIG_1(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    unsigned int arg1 ;
    NameSpaceXml *arg2 = 0 ;
    std::vector<NameSpaceXml > *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:new_NameSpaceVector",&obj0,&obj1)) goto fail;
    arg1 = (unsigned int) PyInt_AsLong(obj0);
    if (PyErr_Occurred()) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_NameSpaceXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            result = (std::vector<NameSpaceXml > *)new std::vector<NameSpaceXml >(arg1,(NameSpaceXml const &)*arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__vectorTNameSpaceXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_NameSpaceVector__SWIG_2(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<NameSpaceXml > *arg1 = 0 ;
    std::vector<NameSpaceXml > *result;
    std::vector<NameSpaceXml > temp1 ;
    std::vector<NameSpaceXml > *v1 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:new_NameSpaceVector",&obj0)) goto fail;
    {
        if (PyTuple_Check(obj0) || PyList_Check(obj0)) {
            unsigned int size = (PyTuple_Check(obj0) ?
            PyTuple_Size(obj0) :
            PyList_Size(obj0));
            temp1 = std::vector<NameSpaceXml >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                NameSpaceXml* x;
                PyObject* o = PySequence_GetItem(obj0,i);
                if ((SWIG_ConvertPtr(o,(void **) &x, 
                SWIGTYPE_p_NameSpaceXml,0)) != -1) {
                    temp1[i] = *x;
                    Py_DECREF(o);
                }else {
                    Py_DECREF(o);
                    PyErr_SetString(PyExc_TypeError,
                    "vector<""NameSpaceXml""> expected");
                    SWIG_fail;
                }
            }
        }else if (SWIG_ConvertPtr(obj0,(void **) &v1, 
        SWIGTYPE_p_std__vectorTNameSpaceXml_t,0) != -1) {
            arg1 = v1;
        }else {
            PyErr_SetString(PyExc_TypeError,"vector<" "NameSpaceXml" "> expected");
            SWIG_fail;
        }
    }
    {
        try {
            result = (std::vector<NameSpaceXml > *)new std::vector<NameSpaceXml >((std::vector<NameSpaceXml > const &)*arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__vectorTNameSpaceXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_NameSpaceVector(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[3];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if ((argc >= 0) && (argc <= 1)) {
        int _v;
        if (argc <= 0) {
            return _wrap_new_NameSpaceVector__SWIG_0(self,args);
        }
        {
            _v = (PyInt_Check(argv[0]) || PyLong_Check(argv[0])) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_NameSpaceVector__SWIG_0(self,args);
        }
    }
    if (argc == 1) {
        int _v;
        {
            /* native sequence? */
            if (PyTuple_Check(argv[0]) || PyList_Check(argv[0])) {
                unsigned int size = (PyTuple_Check(argv[0]) ?
                PyTuple_Size(argv[0]) :
                PyList_Size(argv[0]));
                if (size == 0) {
                    /* an empty sequence can be of any type */
                    _v = 1;
                }else {
                    /* check the first element only */
                    NameSpaceXml* x;
                    PyObject* o = PySequence_GetItem(argv[0],0);
                    if ((SWIG_ConvertPtr(o,(void **) &x, 
                    SWIGTYPE_p_NameSpaceXml,0)) != -1)
                    _v = 1;
                    else
                    _v = 0;
                    Py_DECREF(o);
                }
            }else {
                /* wrapped vector? */
                std::vector<NameSpaceXml >* v;
                if (SWIG_ConvertPtr(argv[0],(void **) &v, 
                SWIGTYPE_p_std__vectorTNameSpaceXml_t,0) != -1)
                _v = 1;
                else
                _v = 0;
            }
        }
        if (_v) {
            return _wrap_new_NameSpaceVector__SWIG_2(self,args);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = (PyInt_Check(argv[0]) || PyLong_Check(argv[0])) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                if (SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_NameSpaceXml, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                }else {
                    _v = 1;
                }
            }
            if (_v) {
                return _wrap_new_NameSpaceVector__SWIG_1(self,args);
            }
        }
    }
    
    PyErr_SetString(PyExc_TypeError,"No matching function for overloaded 'new_NameSpaceVector'");
    return NULL;
}


static PyObject *_wrap_NameSpaceVector___len__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<NameSpaceXml > *arg1 = (std::vector<NameSpaceXml > *) 0 ;
    unsigned int result;
    std::vector<NameSpaceXml > temp1 ;
    std::vector<NameSpaceXml > *v1 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:NameSpaceVector___len__",&obj0)) goto fail;
    {
        if (PyTuple_Check(obj0) || PyList_Check(obj0)) {
            unsigned int size = (PyTuple_Check(obj0) ?
            PyTuple_Size(obj0) :
            PyList_Size(obj0));
            temp1 = std::vector<NameSpaceXml >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                NameSpaceXml* x;
                PyObject* o = PySequence_GetItem(obj0,i);
                if ((SWIG_ConvertPtr(o,(void **) &x, 
                SWIGTYPE_p_NameSpaceXml,0)) != -1) {
                    temp1[i] = *x;
                    Py_DECREF(o);
                }else {
                    Py_DECREF(o);
                    PyErr_SetString(PyExc_TypeError,
                    "vector<""NameSpaceXml""> expected");
                    SWIG_fail;
                }
            }
        }else if (SWIG_ConvertPtr(obj0,(void **) &v1, 
        SWIGTYPE_p_std__vectorTNameSpaceXml_t,0) != -1) {
            arg1 = v1;
        }else {
            PyErr_SetString(PyExc_TypeError,"vector<" "NameSpaceXml" "> expected");
            SWIG_fail;
        }
    }
    {
        try {
            result = (unsigned int)((std::vector<NameSpaceXml > const *)arg1)->size();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NameSpaceVector_clear(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<NameSpaceXml > *arg1 = (std::vector<NameSpaceXml > *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:NameSpaceVector_clear",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTNameSpaceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            (arg1)->clear();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NameSpaceVector_append(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<NameSpaceXml > *arg1 = (std::vector<NameSpaceXml > *) 0 ;
    NameSpaceXml *arg2 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:NameSpaceVector_append",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTNameSpaceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_NameSpaceXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            (arg1)->push_back((NameSpaceXml const &)*arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NameSpaceVector___nonzero__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<NameSpaceXml > *arg1 = (std::vector<NameSpaceXml > *) 0 ;
    bool result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:NameSpaceVector___nonzero__",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTNameSpaceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (bool)std_vectorlNameSpaceXml_g___nonzero_____(arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NameSpaceVector_pop(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<NameSpaceXml > *arg1 = (std::vector<NameSpaceXml > *) 0 ;
    SwigValueWrapper< NameSpaceXml > result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:NameSpaceVector_pop",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTNameSpaceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = std_vectorlNameSpaceXml_g_pop___(arg1);
            
        }catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    {
        NameSpaceXml * resultptr;
        resultptr = new NameSpaceXml((NameSpaceXml &) result);
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_NameSpaceXml, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NameSpaceVector___getitem__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<NameSpaceXml > *arg1 = (std::vector<NameSpaceXml > *) 0 ;
    int arg2 ;
    NameSpaceXml *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:NameSpaceVector___getitem__",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTNameSpaceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            {
                NameSpaceXml &_result_ref = std_vectorlNameSpaceXml_g___getitem_____(arg1,arg2);
                result = (NameSpaceXml *) &_result_ref;
            }
            
        }catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_NameSpaceXml, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NameSpaceVector___getslice__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<NameSpaceXml > *arg1 = (std::vector<NameSpaceXml > *) 0 ;
    int arg2 ;
    int arg3 ;
    std::vector<NameSpaceXml > result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oii:NameSpaceVector___getslice__",&obj0,&arg2,&arg3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTNameSpaceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = std_vectorlNameSpaceXml_g___getslice_____(arg1,arg2,arg3);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    {
        resultobj = PyTuple_New((&result)->size());
        for (unsigned int i=0; i<(&result)->size(); i++) {
            NameSpaceXml* ptr = new NameSpaceXml(((std::vector<NameSpaceXml > &)result)[i]);
            PyTuple_SetItem(resultobj,i,
            SWIG_NewPointerObj((void *) ptr, 
            SWIGTYPE_p_NameSpaceXml, 1));
        }
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NameSpaceVector___setitem__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<NameSpaceXml > *arg1 = (std::vector<NameSpaceXml > *) 0 ;
    int arg2 ;
    NameSpaceXml *arg3 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OiO:NameSpaceVector___setitem__",&obj0,&arg2,&obj2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTNameSpaceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_NameSpaceXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg3 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            std_vectorlNameSpaceXml_g___setitem_____(arg1,arg2,(NameSpaceXml const &)*arg3);
            
        }catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NameSpaceVector___setslice__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<NameSpaceXml > *arg1 = (std::vector<NameSpaceXml > *) 0 ;
    int arg2 ;
    int arg3 ;
    std::vector<NameSpaceXml > *arg4 = 0 ;
    std::vector<NameSpaceXml > temp4 ;
    std::vector<NameSpaceXml > *v4 ;
    PyObject * obj0 = 0 ;
    PyObject * obj3 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OiiO:NameSpaceVector___setslice__",&obj0,&arg2,&arg3,&obj3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTNameSpaceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        if (PyTuple_Check(obj3) || PyList_Check(obj3)) {
            unsigned int size = (PyTuple_Check(obj3) ?
            PyTuple_Size(obj3) :
            PyList_Size(obj3));
            temp4 = std::vector<NameSpaceXml >(size);
            arg4 = &temp4;
            for (unsigned int i=0; i<size; i++) {
                NameSpaceXml* x;
                PyObject* o = PySequence_GetItem(obj3,i);
                if ((SWIG_ConvertPtr(o,(void **) &x, 
                SWIGTYPE_p_NameSpaceXml,0)) != -1) {
                    temp4[i] = *x;
                    Py_DECREF(o);
                }else {
                    Py_DECREF(o);
                    PyErr_SetString(PyExc_TypeError,
                    "vector<""NameSpaceXml""> expected");
                    SWIG_fail;
                }
            }
        }else if (SWIG_ConvertPtr(obj3,(void **) &v4, 
        SWIGTYPE_p_std__vectorTNameSpaceXml_t,0) != -1) {
            arg4 = v4;
        }else {
            PyErr_SetString(PyExc_TypeError,"vector<" "NameSpaceXml" "> expected");
            SWIG_fail;
        }
    }
    {
        try {
            std_vectorlNameSpaceXml_g___setslice_____(arg1,arg2,arg3,(std::vector<NameSpaceXml > const &)*arg4);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NameSpaceVector___delitem__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<NameSpaceXml > *arg1 = (std::vector<NameSpaceXml > *) 0 ;
    int arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:NameSpaceVector___delitem__",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTNameSpaceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            std_vectorlNameSpaceXml_g___delitem_____(arg1,arg2);
            
        }catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NameSpaceVector___delslice__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<NameSpaceXml > *arg1 = (std::vector<NameSpaceXml > *) 0 ;
    int arg2 ;
    int arg3 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oii:NameSpaceVector___delslice__",&obj0,&arg2,&arg3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTNameSpaceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            std_vectorlNameSpaceXml_g___delslice_____(arg1,arg2,arg3);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_NameSpaceVector(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<NameSpaceXml > *arg1 = (std::vector<NameSpaceXml > *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_NameSpaceVector",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTNameSpaceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * NameSpaceVector_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_std__vectorTNameSpaceXml_t, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_new_NameSpaceArray(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<NameSpaceXml > *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_NameSpaceArray")) goto fail;
    {
        try {
            result = (ArrayXml<NameSpaceXml > *)new ArrayXml<NameSpaceXml >();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ArrayXmlTNameSpaceXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NameSpaceArray_add(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<NameSpaceXml > *arg1 = (ArrayXml<NameSpaceXml > *) 0 ;
    NameSpaceXml *arg2 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:NameSpaceArray_add",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTNameSpaceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_NameSpaceXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            (arg1)->add((NameSpaceXml const &)*arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NameSpaceArray_toStringBuffer(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<NameSpaceXml > *arg1 = (ArrayXml<NameSpaceXml > *) 0 ;
    string *arg2 = 0 ;
    char *arg3 = (char *) " " ;
    char *arg4 = (char *) "" ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO|ss:NameSpaceArray_toStringBuffer",&obj0,&obj1,&arg3,&arg4)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTNameSpaceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_string,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            (arg1)->toStringBuffer(*arg2,arg3,arg4);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NameSpaceArray___setitem__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<NameSpaceXml > *arg1 = (ArrayXml<NameSpaceXml > *) 0 ;
    int arg2 ;
    NameSpaceXml *arg3 = (NameSpaceXml *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OiO:NameSpaceArray___setitem__",&obj0,&arg2,&obj2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTNameSpaceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_NameSpaceXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            ArrayXmllNameSpaceXml_g___setitem_____(arg1,arg2,arg3);
            
        }catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NameSpaceArray___getitem__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<NameSpaceXml > *arg1 = (ArrayXml<NameSpaceXml > *) 0 ;
    int arg2 ;
    NameSpaceXml *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:NameSpaceArray___getitem__",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTNameSpaceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (NameSpaceXml *)ArrayXmllNameSpaceXml_g___getitem_____(arg1,arg2);
            
        }catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_NameSpaceXml, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NameSpaceArray___str__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<NameSpaceXml > *arg1 = (ArrayXml<NameSpaceXml > *) 0 ;
    string result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:NameSpaceArray___str__",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTNameSpaceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = ArrayXmllNameSpaceXml_g___str_____(arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    {
        resultobj = PyString_FromString((&result)->c_str());
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NameSpaceArray___iter__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<NameSpaceXml > *arg1 = (ArrayXml<NameSpaceXml > *) 0 ;
    ArrayIterator<NameSpaceXml > result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:NameSpaceArray___iter__",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTNameSpaceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = ArrayXmllNameSpaceXml_g___iter_____(arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    {
        ArrayIterator<NameSpaceXml > * resultptr;
        resultptr = new ArrayIterator<NameSpaceXml >((ArrayIterator<NameSpaceXml > &) result);
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_ArrayIteratorTNameSpaceXml_t, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_NameSpaceArray(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<NameSpaceXml > *arg1 = (ArrayXml<NameSpaceXml > *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_NameSpaceArray",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTNameSpaceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * NameSpaceArray_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_ArrayXmlTNameSpaceXml_t, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_NameSpaceIterator_it_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<NameSpaceXml > *arg1 = (ArrayIterator<NameSpaceXml > *) 0 ;
    int arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:NameSpaceIterator_it_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTNameSpaceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->it = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NameSpaceIterator_it_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<NameSpaceXml > *arg1 = (ArrayIterator<NameSpaceXml > *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:NameSpaceIterator_it_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTNameSpaceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (int) ((arg1)->it);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NameSpaceIterator_c_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<NameSpaceXml > *arg1 = (ArrayIterator<NameSpaceXml > *) 0 ;
    ArrayXml<NameSpaceXml > *arg2 = (ArrayXml<NameSpaceXml > *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:NameSpaceIterator_c_set",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTNameSpaceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_ArrayXmlTNameSpaceXml_t,SWIG_POINTER_EXCEPTION | SWIG_POINTER_DISOWN )) == -1) SWIG_fail;
    if (arg1) (arg1)->c = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NameSpaceIterator_c_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<NameSpaceXml > *arg1 = (ArrayIterator<NameSpaceXml > *) 0 ;
    ArrayXml<NameSpaceXml > *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:NameSpaceIterator_c_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTNameSpaceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (ArrayXml<NameSpaceXml > *) ((arg1)->c);
    
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ArrayXmlTNameSpaceXml_t, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_NameSpaceIterator__SWIG_0(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<NameSpaceXml > *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_NameSpaceIterator")) goto fail;
    {
        try {
            result = (ArrayIterator<NameSpaceXml > *)new ArrayIterator<NameSpaceXml >();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ArrayIteratorTNameSpaceXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_NameSpaceIterator__SWIG_1(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<NameSpaceXml > *arg1 = 0 ;
    ArrayIterator<NameSpaceXml > *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:new_NameSpaceIterator",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTNameSpaceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            result = (ArrayIterator<NameSpaceXml > *)new ArrayIterator<NameSpaceXml >((ArrayIterator<NameSpaceXml > const &)*arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ArrayIteratorTNameSpaceXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_NameSpaceIterator__SWIG_2(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    ArrayXml<NameSpaceXml > *arg2 = (ArrayXml<NameSpaceXml > *) 0 ;
    ArrayIterator<NameSpaceXml > *result;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"iO:new_NameSpaceIterator",&arg1,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_ArrayXmlTNameSpaceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (ArrayIterator<NameSpaceXml > *)new ArrayIterator<NameSpaceXml >(arg1,arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ArrayIteratorTNameSpaceXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_NameSpaceIterator(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[3];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 0) {
        return _wrap_new_NameSpaceIterator__SWIG_0(self,args);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_ArrayIteratorTNameSpaceXml_t, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            }else {
                _v = 1;
            }
        }
        if (_v) {
            return _wrap_new_NameSpaceIterator__SWIG_1(self,args);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = (PyInt_Check(argv[0]) || PyLong_Check(argv[0])) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                if (SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_ArrayXmlTNameSpaceXml_t, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                }else {
                    _v = 1;
                }
            }
            if (_v) {
                return _wrap_new_NameSpaceIterator__SWIG_2(self,args);
            }
        }
    }
    
    PyErr_SetString(PyExc_TypeError,"No matching function for overloaded 'new_NameSpaceIterator'");
    return NULL;
}


static PyObject *_wrap_NameSpaceIterator___iter__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<NameSpaceXml > *arg1 = (ArrayIterator<NameSpaceXml > *) 0 ;
    ArrayIterator<NameSpaceXml > result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:NameSpaceIterator___iter__",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTNameSpaceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (arg1)->__iter__();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    {
        ArrayIterator<NameSpaceXml > * resultptr;
        resultptr = new ArrayIterator<NameSpaceXml >((ArrayIterator<NameSpaceXml > &) result);
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_ArrayIteratorTNameSpaceXml_t, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NameSpaceIterator_next(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<NameSpaceXml > *arg1 = (ArrayIterator<NameSpaceXml > *) 0 ;
    NameSpaceXml *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:NameSpaceIterator_next",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTNameSpaceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (NameSpaceXml *)(arg1)->next();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_NameSpaceXml, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_NameSpaceIterator(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<NameSpaceXml > *arg1 = (ArrayIterator<NameSpaceXml > *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_NameSpaceIterator",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTNameSpaceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * NameSpaceIterator_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_ArrayIteratorTNameSpaceXml_t, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_new_StringVector__SWIG_0(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    unsigned int arg1 = (unsigned int) 0 ;
    std::vector<string > *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"|O:new_StringVector",&obj0)) goto fail;
    if (obj0) {
        arg1 = (unsigned int) PyInt_AsLong(obj0);
        if (PyErr_Occurred()) SWIG_fail;
    }
    {
        try {
            result = (std::vector<string > *)new std::vector<string >(arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__vectorTstring_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_StringVector__SWIG_1(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    unsigned int arg1 ;
    string *arg2 = 0 ;
    std::vector<string > *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:new_StringVector",&obj0,&obj1)) goto fail;
    arg1 = (unsigned int) PyInt_AsLong(obj0);
    if (PyErr_Occurred()) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_string,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            result = (std::vector<string > *)new std::vector<string >(arg1,(string const &)*arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__vectorTstring_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_StringVector__SWIG_2(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<string > *arg1 = 0 ;
    std::vector<string > *result;
    std::vector<string > temp1 ;
    std::vector<string > *v1 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:new_StringVector",&obj0)) goto fail;
    {
        if (PyTuple_Check(obj0) || PyList_Check(obj0)) {
            unsigned int size = (PyTuple_Check(obj0) ?
            PyTuple_Size(obj0) :
            PyList_Size(obj0));
            temp1 = std::vector<string >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                string* x;
                PyObject* o = PySequence_GetItem(obj0,i);
                if ((SWIG_ConvertPtr(o,(void **) &x, 
                SWIGTYPE_p_string,0)) != -1) {
                    temp1[i] = *x;
                    Py_DECREF(o);
                }else {
                    Py_DECREF(o);
                    PyErr_SetString(PyExc_TypeError,
                    "vector<""string""> expected");
                    SWIG_fail;
                }
            }
        }else if (SWIG_ConvertPtr(obj0,(void **) &v1, 
        SWIGTYPE_p_std__vectorTstring_t,0) != -1) {
            arg1 = v1;
        }else {
            PyErr_SetString(PyExc_TypeError,"vector<" "string" "> expected");
            SWIG_fail;
        }
    }
    {
        try {
            result = (std::vector<string > *)new std::vector<string >((std::vector<string > const &)*arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__vectorTstring_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_StringVector(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[3];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if ((argc >= 0) && (argc <= 1)) {
        int _v;
        if (argc <= 0) {
            return _wrap_new_StringVector__SWIG_0(self,args);
        }
        {
            _v = (PyInt_Check(argv[0]) || PyLong_Check(argv[0])) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_StringVector__SWIG_0(self,args);
        }
    }
    if (argc == 1) {
        int _v;
        {
            /* native sequence? */
            if (PyTuple_Check(argv[0]) || PyList_Check(argv[0])) {
                unsigned int size = (PyTuple_Check(argv[0]) ?
                PyTuple_Size(argv[0]) :
                PyList_Size(argv[0]));
                if (size == 0) {
                    /* an empty sequence can be of any type */
                    _v = 1;
                }else {
                    /* check the first element only */
                    string* x;
                    PyObject* o = PySequence_GetItem(argv[0],0);
                    if ((SWIG_ConvertPtr(o,(void **) &x, 
                    SWIGTYPE_p_string,0)) != -1)
                    _v = 1;
                    else
                    _v = 0;
                    Py_DECREF(o);
                }
            }else {
                /* wrapped vector? */
                std::vector<string >* v;
                if (SWIG_ConvertPtr(argv[0],(void **) &v, 
                SWIGTYPE_p_std__vectorTstring_t,0) != -1)
                _v = 1;
                else
                _v = 0;
            }
        }
        if (_v) {
            return _wrap_new_StringVector__SWIG_2(self,args);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = (PyInt_Check(argv[0]) || PyLong_Check(argv[0])) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                if (SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_string, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                }else {
                    _v = 1;
                }
            }
            if (_v) {
                return _wrap_new_StringVector__SWIG_1(self,args);
            }
        }
    }
    
    PyErr_SetString(PyExc_TypeError,"No matching function for overloaded 'new_StringVector'");
    return NULL;
}


static PyObject *_wrap_StringVector___len__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<string > *arg1 = (std::vector<string > *) 0 ;
    unsigned int result;
    std::vector<string > temp1 ;
    std::vector<string > *v1 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:StringVector___len__",&obj0)) goto fail;
    {
        if (PyTuple_Check(obj0) || PyList_Check(obj0)) {
            unsigned int size = (PyTuple_Check(obj0) ?
            PyTuple_Size(obj0) :
            PyList_Size(obj0));
            temp1 = std::vector<string >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                string* x;
                PyObject* o = PySequence_GetItem(obj0,i);
                if ((SWIG_ConvertPtr(o,(void **) &x, 
                SWIGTYPE_p_string,0)) != -1) {
                    temp1[i] = *x;
                    Py_DECREF(o);
                }else {
                    Py_DECREF(o);
                    PyErr_SetString(PyExc_TypeError,
                    "vector<""string""> expected");
                    SWIG_fail;
                }
            }
        }else if (SWIG_ConvertPtr(obj0,(void **) &v1, 
        SWIGTYPE_p_std__vectorTstring_t,0) != -1) {
            arg1 = v1;
        }else {
            PyErr_SetString(PyExc_TypeError,"vector<" "string" "> expected");
            SWIG_fail;
        }
    }
    {
        try {
            result = (unsigned int)((std::vector<string > const *)arg1)->size();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_StringVector_clear(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<string > *arg1 = (std::vector<string > *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:StringVector_clear",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTstring_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            (arg1)->clear();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_StringVector_append(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<string > *arg1 = (std::vector<string > *) 0 ;
    string *arg2 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:StringVector_append",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTstring_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_string,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            (arg1)->push_back((string const &)*arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_StringVector___nonzero__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<string > *arg1 = (std::vector<string > *) 0 ;
    bool result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:StringVector___nonzero__",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTstring_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (bool)std_vectorlstring_g___nonzero_____(arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_StringVector_pop(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<string > *arg1 = (std::vector<string > *) 0 ;
    string result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:StringVector_pop",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTstring_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = std_vectorlstring_g_pop___(arg1);
            
        }catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    {
        resultobj = PyString_FromString((&result)->c_str());
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_StringVector___getitem__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<string > *arg1 = (std::vector<string > *) 0 ;
    int arg2 ;
    string *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:StringVector___getitem__",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTstring_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            {
                string &_result_ref = std_vectorlstring_g___getitem_____(arg1,arg2);
                result = (string *) &_result_ref;
            }
            
        }catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_string, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_StringVector___getslice__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<string > *arg1 = (std::vector<string > *) 0 ;
    int arg2 ;
    int arg3 ;
    std::vector<string > result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oii:StringVector___getslice__",&obj0,&arg2,&arg3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTstring_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = std_vectorlstring_g___getslice_____(arg1,arg2,arg3);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    {
        resultobj = PyTuple_New((&result)->size());
        for (unsigned int i=0; i<(&result)->size(); i++) {
            string* ptr = new string(((std::vector<string > &)result)[i]);
            PyTuple_SetItem(resultobj,i,
            SWIG_NewPointerObj((void *) ptr, 
            SWIGTYPE_p_string, 1));
        }
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_StringVector___setitem__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<string > *arg1 = (std::vector<string > *) 0 ;
    int arg2 ;
    string *arg3 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OiO:StringVector___setitem__",&obj0,&arg2,&obj2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTstring_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_string,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg3 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            std_vectorlstring_g___setitem_____(arg1,arg2,(string const &)*arg3);
            
        }catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_StringVector___setslice__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<string > *arg1 = (std::vector<string > *) 0 ;
    int arg2 ;
    int arg3 ;
    std::vector<string > *arg4 = 0 ;
    std::vector<string > temp4 ;
    std::vector<string > *v4 ;
    PyObject * obj0 = 0 ;
    PyObject * obj3 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OiiO:StringVector___setslice__",&obj0,&arg2,&arg3,&obj3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTstring_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        if (PyTuple_Check(obj3) || PyList_Check(obj3)) {
            unsigned int size = (PyTuple_Check(obj3) ?
            PyTuple_Size(obj3) :
            PyList_Size(obj3));
            temp4 = std::vector<string >(size);
            arg4 = &temp4;
            for (unsigned int i=0; i<size; i++) {
                string* x;
                PyObject* o = PySequence_GetItem(obj3,i);
                if ((SWIG_ConvertPtr(o,(void **) &x, 
                SWIGTYPE_p_string,0)) != -1) {
                    temp4[i] = *x;
                    Py_DECREF(o);
                }else {
                    Py_DECREF(o);
                    PyErr_SetString(PyExc_TypeError,
                    "vector<""string""> expected");
                    SWIG_fail;
                }
            }
        }else if (SWIG_ConvertPtr(obj3,(void **) &v4, 
        SWIGTYPE_p_std__vectorTstring_t,0) != -1) {
            arg4 = v4;
        }else {
            PyErr_SetString(PyExc_TypeError,"vector<" "string" "> expected");
            SWIG_fail;
        }
    }
    {
        try {
            std_vectorlstring_g___setslice_____(arg1,arg2,arg3,(std::vector<string > const &)*arg4);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_StringVector___delitem__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<string > *arg1 = (std::vector<string > *) 0 ;
    int arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:StringVector___delitem__",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTstring_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            std_vectorlstring_g___delitem_____(arg1,arg2);
            
        }catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_StringVector___delslice__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<string > *arg1 = (std::vector<string > *) 0 ;
    int arg2 ;
    int arg3 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oii:StringVector___delslice__",&obj0,&arg2,&arg3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTstring_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            std_vectorlstring_g___delslice_____(arg1,arg2,arg3);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_StringVector(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<string > *arg1 = (std::vector<string > *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_StringVector",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTstring_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * StringVector_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_std__vectorTstring_t, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_StringArray_add(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    StringArray *arg1 = (StringArray *) 0 ;
    string *arg2 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:StringArray_add",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_StringArray,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_string,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            (arg1)->add((string const &)*arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_StringArray_toStringBuffer(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    StringArray *arg1 = (StringArray *) 0 ;
    string *arg2 = 0 ;
    char *arg3 = (char *) " " ;
    char *arg4 = (char *) "" ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO|ss:StringArray_toStringBuffer",&obj0,&obj1,&arg3,&arg4)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_StringArray,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_string,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            (arg1)->toStringBuffer(*arg2,arg3,arg4);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_StringArray(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    StringArray *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_StringArray")) goto fail;
    {
        try {
            result = (StringArray *)new StringArray();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_StringArray, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_StringArray(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    StringArray *arg1 = (StringArray *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_StringArray",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_StringArray,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * StringArray_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_StringArray, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_new_PropertyVector__SWIG_0(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    unsigned int arg1 = (unsigned int) 0 ;
    std::vector<PropertyXml > *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"|O:new_PropertyVector",&obj0)) goto fail;
    if (obj0) {
        arg1 = (unsigned int) PyInt_AsLong(obj0);
        if (PyErr_Occurred()) SWIG_fail;
    }
    {
        try {
            result = (std::vector<PropertyXml > *)new std::vector<PropertyXml >(arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__vectorTPropertyXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_PropertyVector__SWIG_1(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    unsigned int arg1 ;
    PropertyXml *arg2 = 0 ;
    std::vector<PropertyXml > *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:new_PropertyVector",&obj0,&obj1)) goto fail;
    arg1 = (unsigned int) PyInt_AsLong(obj0);
    if (PyErr_Occurred()) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_PropertyXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            result = (std::vector<PropertyXml > *)new std::vector<PropertyXml >(arg1,(PropertyXml const &)*arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__vectorTPropertyXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_PropertyVector__SWIG_2(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<PropertyXml > *arg1 = 0 ;
    std::vector<PropertyXml > *result;
    std::vector<PropertyXml > temp1 ;
    std::vector<PropertyXml > *v1 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:new_PropertyVector",&obj0)) goto fail;
    {
        if (PyTuple_Check(obj0) || PyList_Check(obj0)) {
            unsigned int size = (PyTuple_Check(obj0) ?
            PyTuple_Size(obj0) :
            PyList_Size(obj0));
            temp1 = std::vector<PropertyXml >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                PropertyXml* x;
                PyObject* o = PySequence_GetItem(obj0,i);
                if ((SWIG_ConvertPtr(o,(void **) &x, 
                SWIGTYPE_p_PropertyXml,0)) != -1) {
                    temp1[i] = *x;
                    Py_DECREF(o);
                }else {
                    Py_DECREF(o);
                    PyErr_SetString(PyExc_TypeError,
                    "vector<""PropertyXml""> expected");
                    SWIG_fail;
                }
            }
        }else if (SWIG_ConvertPtr(obj0,(void **) &v1, 
        SWIGTYPE_p_std__vectorTPropertyXml_t,0) != -1) {
            arg1 = v1;
        }else {
            PyErr_SetString(PyExc_TypeError,"vector<" "PropertyXml" "> expected");
            SWIG_fail;
        }
    }
    {
        try {
            result = (std::vector<PropertyXml > *)new std::vector<PropertyXml >((std::vector<PropertyXml > const &)*arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__vectorTPropertyXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_PropertyVector(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[3];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if ((argc >= 0) && (argc <= 1)) {
        int _v;
        if (argc <= 0) {
            return _wrap_new_PropertyVector__SWIG_0(self,args);
        }
        {
            _v = (PyInt_Check(argv[0]) || PyLong_Check(argv[0])) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_PropertyVector__SWIG_0(self,args);
        }
    }
    if (argc == 1) {
        int _v;
        {
            /* native sequence? */
            if (PyTuple_Check(argv[0]) || PyList_Check(argv[0])) {
                unsigned int size = (PyTuple_Check(argv[0]) ?
                PyTuple_Size(argv[0]) :
                PyList_Size(argv[0]));
                if (size == 0) {
                    /* an empty sequence can be of any type */
                    _v = 1;
                }else {
                    /* check the first element only */
                    PropertyXml* x;
                    PyObject* o = PySequence_GetItem(argv[0],0);
                    if ((SWIG_ConvertPtr(o,(void **) &x, 
                    SWIGTYPE_p_PropertyXml,0)) != -1)
                    _v = 1;
                    else
                    _v = 0;
                    Py_DECREF(o);
                }
            }else {
                /* wrapped vector? */
                std::vector<PropertyXml >* v;
                if (SWIG_ConvertPtr(argv[0],(void **) &v, 
                SWIGTYPE_p_std__vectorTPropertyXml_t,0) != -1)
                _v = 1;
                else
                _v = 0;
            }
        }
        if (_v) {
            return _wrap_new_PropertyVector__SWIG_2(self,args);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = (PyInt_Check(argv[0]) || PyLong_Check(argv[0])) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                if (SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_PropertyXml, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                }else {
                    _v = 1;
                }
            }
            if (_v) {
                return _wrap_new_PropertyVector__SWIG_1(self,args);
            }
        }
    }
    
    PyErr_SetString(PyExc_TypeError,"No matching function for overloaded 'new_PropertyVector'");
    return NULL;
}


static PyObject *_wrap_PropertyVector___len__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<PropertyXml > *arg1 = (std::vector<PropertyXml > *) 0 ;
    unsigned int result;
    std::vector<PropertyXml > temp1 ;
    std::vector<PropertyXml > *v1 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PropertyVector___len__",&obj0)) goto fail;
    {
        if (PyTuple_Check(obj0) || PyList_Check(obj0)) {
            unsigned int size = (PyTuple_Check(obj0) ?
            PyTuple_Size(obj0) :
            PyList_Size(obj0));
            temp1 = std::vector<PropertyXml >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                PropertyXml* x;
                PyObject* o = PySequence_GetItem(obj0,i);
                if ((SWIG_ConvertPtr(o,(void **) &x, 
                SWIGTYPE_p_PropertyXml,0)) != -1) {
                    temp1[i] = *x;
                    Py_DECREF(o);
                }else {
                    Py_DECREF(o);
                    PyErr_SetString(PyExc_TypeError,
                    "vector<""PropertyXml""> expected");
                    SWIG_fail;
                }
            }
        }else if (SWIG_ConvertPtr(obj0,(void **) &v1, 
        SWIGTYPE_p_std__vectorTPropertyXml_t,0) != -1) {
            arg1 = v1;
        }else {
            PyErr_SetString(PyExc_TypeError,"vector<" "PropertyXml" "> expected");
            SWIG_fail;
        }
    }
    {
        try {
            result = (unsigned int)((std::vector<PropertyXml > const *)arg1)->size();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PropertyVector_clear(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<PropertyXml > *arg1 = (std::vector<PropertyXml > *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PropertyVector_clear",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTPropertyXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            (arg1)->clear();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PropertyVector_append(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<PropertyXml > *arg1 = (std::vector<PropertyXml > *) 0 ;
    PropertyXml *arg2 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:PropertyVector_append",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTPropertyXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_PropertyXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            (arg1)->push_back((PropertyXml const &)*arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PropertyVector___nonzero__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<PropertyXml > *arg1 = (std::vector<PropertyXml > *) 0 ;
    bool result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PropertyVector___nonzero__",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTPropertyXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (bool)std_vectorlPropertyXml_g___nonzero_____(arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PropertyVector_pop(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<PropertyXml > *arg1 = (std::vector<PropertyXml > *) 0 ;
    SwigValueWrapper< PropertyXml > result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PropertyVector_pop",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTPropertyXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = std_vectorlPropertyXml_g_pop___(arg1);
            
        }catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    {
        PropertyXml * resultptr;
        resultptr = new PropertyXml((PropertyXml &) result);
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_PropertyXml, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PropertyVector___getitem__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<PropertyXml > *arg1 = (std::vector<PropertyXml > *) 0 ;
    int arg2 ;
    PropertyXml *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:PropertyVector___getitem__",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTPropertyXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            {
                PropertyXml &_result_ref = std_vectorlPropertyXml_g___getitem_____(arg1,arg2);
                result = (PropertyXml *) &_result_ref;
            }
            
        }catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PropertyXml, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PropertyVector___getslice__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<PropertyXml > *arg1 = (std::vector<PropertyXml > *) 0 ;
    int arg2 ;
    int arg3 ;
    std::vector<PropertyXml > result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oii:PropertyVector___getslice__",&obj0,&arg2,&arg3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTPropertyXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = std_vectorlPropertyXml_g___getslice_____(arg1,arg2,arg3);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    {
        resultobj = PyTuple_New((&result)->size());
        for (unsigned int i=0; i<(&result)->size(); i++) {
            PropertyXml* ptr = new PropertyXml(((std::vector<PropertyXml > &)result)[i]);
            PyTuple_SetItem(resultobj,i,
            SWIG_NewPointerObj((void *) ptr, 
            SWIGTYPE_p_PropertyXml, 1));
        }
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PropertyVector___setitem__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<PropertyXml > *arg1 = (std::vector<PropertyXml > *) 0 ;
    int arg2 ;
    PropertyXml *arg3 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OiO:PropertyVector___setitem__",&obj0,&arg2,&obj2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTPropertyXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_PropertyXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg3 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            std_vectorlPropertyXml_g___setitem_____(arg1,arg2,(PropertyXml const &)*arg3);
            
        }catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PropertyVector___setslice__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<PropertyXml > *arg1 = (std::vector<PropertyXml > *) 0 ;
    int arg2 ;
    int arg3 ;
    std::vector<PropertyXml > *arg4 = 0 ;
    std::vector<PropertyXml > temp4 ;
    std::vector<PropertyXml > *v4 ;
    PyObject * obj0 = 0 ;
    PyObject * obj3 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OiiO:PropertyVector___setslice__",&obj0,&arg2,&arg3,&obj3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTPropertyXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        if (PyTuple_Check(obj3) || PyList_Check(obj3)) {
            unsigned int size = (PyTuple_Check(obj3) ?
            PyTuple_Size(obj3) :
            PyList_Size(obj3));
            temp4 = std::vector<PropertyXml >(size);
            arg4 = &temp4;
            for (unsigned int i=0; i<size; i++) {
                PropertyXml* x;
                PyObject* o = PySequence_GetItem(obj3,i);
                if ((SWIG_ConvertPtr(o,(void **) &x, 
                SWIGTYPE_p_PropertyXml,0)) != -1) {
                    temp4[i] = *x;
                    Py_DECREF(o);
                }else {
                    Py_DECREF(o);
                    PyErr_SetString(PyExc_TypeError,
                    "vector<""PropertyXml""> expected");
                    SWIG_fail;
                }
            }
        }else if (SWIG_ConvertPtr(obj3,(void **) &v4, 
        SWIGTYPE_p_std__vectorTPropertyXml_t,0) != -1) {
            arg4 = v4;
        }else {
            PyErr_SetString(PyExc_TypeError,"vector<" "PropertyXml" "> expected");
            SWIG_fail;
        }
    }
    {
        try {
            std_vectorlPropertyXml_g___setslice_____(arg1,arg2,arg3,(std::vector<PropertyXml > const &)*arg4);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PropertyVector___delitem__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<PropertyXml > *arg1 = (std::vector<PropertyXml > *) 0 ;
    int arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:PropertyVector___delitem__",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTPropertyXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            std_vectorlPropertyXml_g___delitem_____(arg1,arg2);
            
        }catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PropertyVector___delslice__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<PropertyXml > *arg1 = (std::vector<PropertyXml > *) 0 ;
    int arg2 ;
    int arg3 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oii:PropertyVector___delslice__",&obj0,&arg2,&arg3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTPropertyXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            std_vectorlPropertyXml_g___delslice_____(arg1,arg2,arg3);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_PropertyVector(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<PropertyXml > *arg1 = (std::vector<PropertyXml > *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_PropertyVector",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTPropertyXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * PropertyVector_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_std__vectorTPropertyXml_t, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_new_PropertyArray(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<PropertyXml > *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_PropertyArray")) goto fail;
    {
        try {
            result = (ArrayXml<PropertyXml > *)new ArrayXml<PropertyXml >();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ArrayXmlTPropertyXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PropertyArray_add(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<PropertyXml > *arg1 = (ArrayXml<PropertyXml > *) 0 ;
    PropertyXml *arg2 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:PropertyArray_add",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTPropertyXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_PropertyXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            (arg1)->add((PropertyXml const &)*arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PropertyArray_toStringBuffer(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<PropertyXml > *arg1 = (ArrayXml<PropertyXml > *) 0 ;
    string *arg2 = 0 ;
    char *arg3 = (char *) " " ;
    char *arg4 = (char *) "" ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO|ss:PropertyArray_toStringBuffer",&obj0,&obj1,&arg3,&arg4)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTPropertyXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_string,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            (arg1)->toStringBuffer(*arg2,arg3,arg4);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PropertyArray___setitem__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<PropertyXml > *arg1 = (ArrayXml<PropertyXml > *) 0 ;
    int arg2 ;
    PropertyXml *arg3 = (PropertyXml *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OiO:PropertyArray___setitem__",&obj0,&arg2,&obj2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTPropertyXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_PropertyXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            ArrayXmllPropertyXml_g___setitem_____(arg1,arg2,arg3);
            
        }catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PropertyArray___getitem____SWIG_0(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<PropertyXml > *arg1 = (ArrayXml<PropertyXml > *) 0 ;
    int arg2 ;
    PropertyXml *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:PropertyArray___getitem__",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTPropertyXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (PropertyXml *)ArrayXmllPropertyXml_g___getitem_______SWIG_0(arg1,arg2);
            
        }catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PropertyXml, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PropertyArray___str__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<PropertyXml > *arg1 = (ArrayXml<PropertyXml > *) 0 ;
    string result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PropertyArray___str__",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTPropertyXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = ArrayXmllPropertyXml_g___str_____(arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    {
        resultobj = PyString_FromString((&result)->c_str());
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PropertyArray___iter__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<PropertyXml > *arg1 = (ArrayXml<PropertyXml > *) 0 ;
    ArrayIterator<PropertyXml > result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PropertyArray___iter__",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTPropertyXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = ArrayXmllPropertyXml_g___iter_____(arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    {
        ArrayIterator<PropertyXml > * resultptr;
        resultptr = new ArrayIterator<PropertyXml >((ArrayIterator<PropertyXml > &) result);
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_ArrayIteratorTPropertyXml_t, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PropertyArray___getitem____SWIG_1(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<PropertyXml > *arg1 = (ArrayXml<PropertyXml > *) 0 ;
    char *arg2 ;
    ValueXml *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Os:PropertyArray___getitem__",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTPropertyXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (ValueXml *)ArrayXmllPropertyXml_g___getitem_______SWIG_1(arg1,arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ValueXml, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PropertyArray___getitem__(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[3];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_ArrayXmlTPropertyXml_t, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            }else {
                _v = 1;
            }
        }
        if (_v) {
            {
                _v = (PyInt_Check(argv[1]) || PyLong_Check(argv[1])) ? 1 : 0;
            }
            if (_v) {
                return _wrap_PropertyArray___getitem____SWIG_0(self,args);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_ArrayXmlTPropertyXml_t, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            }else {
                _v = 1;
            }
        }
        if (_v) {
            {
                _v = PyString_Check(argv[1]) ? 1 : 0;
            }
            if (_v) {
                return _wrap_PropertyArray___getitem____SWIG_1(self,args);
            }
        }
    }
    
    PyErr_SetString(PyExc_TypeError,"No matching function for overloaded 'PropertyArray___getitem__'");
    return NULL;
}


static PyObject *_wrap_PropertyArray___delitem__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<PropertyXml > *arg1 = (ArrayXml<PropertyXml > *) 0 ;
    string arg2 ;
    char *arg3 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOs:PropertyArray___delitem__",&obj0,&obj1,&arg3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTPropertyXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        arg2 = PyString_AsString(resultobj);
        if (PyErr_Occurred()) return NULL;
    }
    {
        try {
            ArrayXmllPropertyXml_g___delitem_____(arg1,arg2,arg3);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PropertyArray_keys(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<PropertyXml > *arg1 = (ArrayXml<PropertyXml > *) 0 ;
    std::vector<string > result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PropertyArray_keys",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTPropertyXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = ArrayXmllPropertyXml_g_keys___(arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    {
        resultobj = PyTuple_New((&result)->size());
        for (unsigned int i=0; i<(&result)->size(); i++) {
            string* ptr = new string(((std::vector<string > &)result)[i]);
            PyTuple_SetItem(resultobj,i,
            SWIG_NewPointerObj((void *) ptr, 
            SWIGTYPE_p_string, 1));
        }
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_PropertyArray(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<PropertyXml > *arg1 = (ArrayXml<PropertyXml > *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_PropertyArray",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTPropertyXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * PropertyArray_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_ArrayXmlTPropertyXml_t, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_PropertyIterator_it_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<PropertyXml > *arg1 = (ArrayIterator<PropertyXml > *) 0 ;
    int arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:PropertyIterator_it_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTPropertyXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->it = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PropertyIterator_it_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<PropertyXml > *arg1 = (ArrayIterator<PropertyXml > *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PropertyIterator_it_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTPropertyXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (int) ((arg1)->it);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PropertyIterator_c_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<PropertyXml > *arg1 = (ArrayIterator<PropertyXml > *) 0 ;
    ArrayXml<PropertyXml > *arg2 = (ArrayXml<PropertyXml > *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:PropertyIterator_c_set",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTPropertyXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_ArrayXmlTPropertyXml_t,SWIG_POINTER_EXCEPTION | SWIG_POINTER_DISOWN )) == -1) SWIG_fail;
    if (arg1) (arg1)->c = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PropertyIterator_c_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<PropertyXml > *arg1 = (ArrayIterator<PropertyXml > *) 0 ;
    ArrayXml<PropertyXml > *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PropertyIterator_c_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTPropertyXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (ArrayXml<PropertyXml > *) ((arg1)->c);
    
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ArrayXmlTPropertyXml_t, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_PropertyIterator__SWIG_0(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<PropertyXml > *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_PropertyIterator")) goto fail;
    {
        try {
            result = (ArrayIterator<PropertyXml > *)new ArrayIterator<PropertyXml >();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ArrayIteratorTPropertyXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_PropertyIterator__SWIG_1(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<PropertyXml > *arg1 = 0 ;
    ArrayIterator<PropertyXml > *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:new_PropertyIterator",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTPropertyXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            result = (ArrayIterator<PropertyXml > *)new ArrayIterator<PropertyXml >((ArrayIterator<PropertyXml > const &)*arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ArrayIteratorTPropertyXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_PropertyIterator__SWIG_2(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    ArrayXml<PropertyXml > *arg2 = (ArrayXml<PropertyXml > *) 0 ;
    ArrayIterator<PropertyXml > *result;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"iO:new_PropertyIterator",&arg1,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_ArrayXmlTPropertyXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (ArrayIterator<PropertyXml > *)new ArrayIterator<PropertyXml >(arg1,arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ArrayIteratorTPropertyXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_PropertyIterator(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[3];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 0) {
        return _wrap_new_PropertyIterator__SWIG_0(self,args);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_ArrayIteratorTPropertyXml_t, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            }else {
                _v = 1;
            }
        }
        if (_v) {
            return _wrap_new_PropertyIterator__SWIG_1(self,args);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = (PyInt_Check(argv[0]) || PyLong_Check(argv[0])) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                if (SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_ArrayXmlTPropertyXml_t, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                }else {
                    _v = 1;
                }
            }
            if (_v) {
                return _wrap_new_PropertyIterator__SWIG_2(self,args);
            }
        }
    }
    
    PyErr_SetString(PyExc_TypeError,"No matching function for overloaded 'new_PropertyIterator'");
    return NULL;
}


static PyObject *_wrap_PropertyIterator___iter__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<PropertyXml > *arg1 = (ArrayIterator<PropertyXml > *) 0 ;
    ArrayIterator<PropertyXml > result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PropertyIterator___iter__",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTPropertyXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (arg1)->__iter__();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    {
        ArrayIterator<PropertyXml > * resultptr;
        resultptr = new ArrayIterator<PropertyXml >((ArrayIterator<PropertyXml > &) result);
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_ArrayIteratorTPropertyXml_t, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PropertyIterator_next(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<PropertyXml > *arg1 = (ArrayIterator<PropertyXml > *) 0 ;
    PropertyXml *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PropertyIterator_next",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTPropertyXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (PropertyXml *)(arg1)->next();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PropertyXml, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_PropertyIterator(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<PropertyXml > *arg1 = (ArrayIterator<PropertyXml > *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_PropertyIterator",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTPropertyXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * PropertyIterator_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_ArrayIteratorTPropertyXml_t, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_new_InstanceNameVector__SWIG_0(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    unsigned int arg1 = (unsigned int) 0 ;
    std::vector<InstanceNameXml > *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"|O:new_InstanceNameVector",&obj0)) goto fail;
    if (obj0) {
        arg1 = (unsigned int) PyInt_AsLong(obj0);
        if (PyErr_Occurred()) SWIG_fail;
    }
    {
        try {
            result = (std::vector<InstanceNameXml > *)new std::vector<InstanceNameXml >(arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__vectorTInstanceNameXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_InstanceNameVector__SWIG_1(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    unsigned int arg1 ;
    InstanceNameXml *arg2 = 0 ;
    std::vector<InstanceNameXml > *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:new_InstanceNameVector",&obj0,&obj1)) goto fail;
    arg1 = (unsigned int) PyInt_AsLong(obj0);
    if (PyErr_Occurred()) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_InstanceNameXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            result = (std::vector<InstanceNameXml > *)new std::vector<InstanceNameXml >(arg1,(InstanceNameXml const &)*arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__vectorTInstanceNameXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_InstanceNameVector__SWIG_2(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<InstanceNameXml > *arg1 = 0 ;
    std::vector<InstanceNameXml > *result;
    std::vector<InstanceNameXml > temp1 ;
    std::vector<InstanceNameXml > *v1 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:new_InstanceNameVector",&obj0)) goto fail;
    {
        if (PyTuple_Check(obj0) || PyList_Check(obj0)) {
            unsigned int size = (PyTuple_Check(obj0) ?
            PyTuple_Size(obj0) :
            PyList_Size(obj0));
            temp1 = std::vector<InstanceNameXml >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                InstanceNameXml* x;
                PyObject* o = PySequence_GetItem(obj0,i);
                if ((SWIG_ConvertPtr(o,(void **) &x, 
                SWIGTYPE_p_InstanceNameXml,0)) != -1) {
                    temp1[i] = *x;
                    Py_DECREF(o);
                }else {
                    Py_DECREF(o);
                    PyErr_SetString(PyExc_TypeError,
                    "vector<""InstanceNameXml""> expected");
                    SWIG_fail;
                }
            }
        }else if (SWIG_ConvertPtr(obj0,(void **) &v1, 
        SWIGTYPE_p_std__vectorTInstanceNameXml_t,0) != -1) {
            arg1 = v1;
        }else {
            PyErr_SetString(PyExc_TypeError,"vector<" "InstanceNameXml" "> expected");
            SWIG_fail;
        }
    }
    {
        try {
            result = (std::vector<InstanceNameXml > *)new std::vector<InstanceNameXml >((std::vector<InstanceNameXml > const &)*arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__vectorTInstanceNameXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_InstanceNameVector(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[3];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if ((argc >= 0) && (argc <= 1)) {
        int _v;
        if (argc <= 0) {
            return _wrap_new_InstanceNameVector__SWIG_0(self,args);
        }
        {
            _v = (PyInt_Check(argv[0]) || PyLong_Check(argv[0])) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_InstanceNameVector__SWIG_0(self,args);
        }
    }
    if (argc == 1) {
        int _v;
        {
            /* native sequence? */
            if (PyTuple_Check(argv[0]) || PyList_Check(argv[0])) {
                unsigned int size = (PyTuple_Check(argv[0]) ?
                PyTuple_Size(argv[0]) :
                PyList_Size(argv[0]));
                if (size == 0) {
                    /* an empty sequence can be of any type */
                    _v = 1;
                }else {
                    /* check the first element only */
                    InstanceNameXml* x;
                    PyObject* o = PySequence_GetItem(argv[0],0);
                    if ((SWIG_ConvertPtr(o,(void **) &x, 
                    SWIGTYPE_p_InstanceNameXml,0)) != -1)
                    _v = 1;
                    else
                    _v = 0;
                    Py_DECREF(o);
                }
            }else {
                /* wrapped vector? */
                std::vector<InstanceNameXml >* v;
                if (SWIG_ConvertPtr(argv[0],(void **) &v, 
                SWIGTYPE_p_std__vectorTInstanceNameXml_t,0) != -1)
                _v = 1;
                else
                _v = 0;
            }
        }
        if (_v) {
            return _wrap_new_InstanceNameVector__SWIG_2(self,args);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = (PyInt_Check(argv[0]) || PyLong_Check(argv[0])) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                if (SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_InstanceNameXml, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                }else {
                    _v = 1;
                }
            }
            if (_v) {
                return _wrap_new_InstanceNameVector__SWIG_1(self,args);
            }
        }
    }
    
    PyErr_SetString(PyExc_TypeError,"No matching function for overloaded 'new_InstanceNameVector'");
    return NULL;
}


static PyObject *_wrap_InstanceNameVector___len__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<InstanceNameXml > *arg1 = (std::vector<InstanceNameXml > *) 0 ;
    unsigned int result;
    std::vector<InstanceNameXml > temp1 ;
    std::vector<InstanceNameXml > *v1 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:InstanceNameVector___len__",&obj0)) goto fail;
    {
        if (PyTuple_Check(obj0) || PyList_Check(obj0)) {
            unsigned int size = (PyTuple_Check(obj0) ?
            PyTuple_Size(obj0) :
            PyList_Size(obj0));
            temp1 = std::vector<InstanceNameXml >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                InstanceNameXml* x;
                PyObject* o = PySequence_GetItem(obj0,i);
                if ((SWIG_ConvertPtr(o,(void **) &x, 
                SWIGTYPE_p_InstanceNameXml,0)) != -1) {
                    temp1[i] = *x;
                    Py_DECREF(o);
                }else {
                    Py_DECREF(o);
                    PyErr_SetString(PyExc_TypeError,
                    "vector<""InstanceNameXml""> expected");
                    SWIG_fail;
                }
            }
        }else if (SWIG_ConvertPtr(obj0,(void **) &v1, 
        SWIGTYPE_p_std__vectorTInstanceNameXml_t,0) != -1) {
            arg1 = v1;
        }else {
            PyErr_SetString(PyExc_TypeError,"vector<" "InstanceNameXml" "> expected");
            SWIG_fail;
        }
    }
    {
        try {
            result = (unsigned int)((std::vector<InstanceNameXml > const *)arg1)->size();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_InstanceNameVector_clear(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<InstanceNameXml > *arg1 = (std::vector<InstanceNameXml > *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:InstanceNameVector_clear",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTInstanceNameXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            (arg1)->clear();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_InstanceNameVector_append(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<InstanceNameXml > *arg1 = (std::vector<InstanceNameXml > *) 0 ;
    InstanceNameXml *arg2 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:InstanceNameVector_append",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTInstanceNameXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_InstanceNameXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            (arg1)->push_back((InstanceNameXml const &)*arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_InstanceNameVector___nonzero__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<InstanceNameXml > *arg1 = (std::vector<InstanceNameXml > *) 0 ;
    bool result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:InstanceNameVector___nonzero__",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTInstanceNameXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (bool)std_vectorlInstanceNameXml_g___nonzero_____(arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_InstanceNameVector_pop(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<InstanceNameXml > *arg1 = (std::vector<InstanceNameXml > *) 0 ;
    SwigValueWrapper< InstanceNameXml > result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:InstanceNameVector_pop",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTInstanceNameXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = std_vectorlInstanceNameXml_g_pop___(arg1);
            
        }catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    {
        InstanceNameXml * resultptr;
        resultptr = new InstanceNameXml((InstanceNameXml &) result);
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_InstanceNameXml, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_InstanceNameVector___getitem__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<InstanceNameXml > *arg1 = (std::vector<InstanceNameXml > *) 0 ;
    int arg2 ;
    InstanceNameXml *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:InstanceNameVector___getitem__",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTInstanceNameXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            {
                InstanceNameXml &_result_ref = std_vectorlInstanceNameXml_g___getitem_____(arg1,arg2);
                result = (InstanceNameXml *) &_result_ref;
            }
            
        }catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_InstanceNameXml, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_InstanceNameVector___getslice__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<InstanceNameXml > *arg1 = (std::vector<InstanceNameXml > *) 0 ;
    int arg2 ;
    int arg3 ;
    std::vector<InstanceNameXml > result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oii:InstanceNameVector___getslice__",&obj0,&arg2,&arg3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTInstanceNameXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = std_vectorlInstanceNameXml_g___getslice_____(arg1,arg2,arg3);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    {
        resultobj = PyTuple_New((&result)->size());
        for (unsigned int i=0; i<(&result)->size(); i++) {
            InstanceNameXml* ptr = new InstanceNameXml(((std::vector<InstanceNameXml > &)result)[i]);
            PyTuple_SetItem(resultobj,i,
            SWIG_NewPointerObj((void *) ptr, 
            SWIGTYPE_p_InstanceNameXml, 1));
        }
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_InstanceNameVector___setitem__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<InstanceNameXml > *arg1 = (std::vector<InstanceNameXml > *) 0 ;
    int arg2 ;
    InstanceNameXml *arg3 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OiO:InstanceNameVector___setitem__",&obj0,&arg2,&obj2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTInstanceNameXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_InstanceNameXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg3 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            std_vectorlInstanceNameXml_g___setitem_____(arg1,arg2,(InstanceNameXml const &)*arg3);
            
        }catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_InstanceNameVector___setslice__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<InstanceNameXml > *arg1 = (std::vector<InstanceNameXml > *) 0 ;
    int arg2 ;
    int arg3 ;
    std::vector<InstanceNameXml > *arg4 = 0 ;
    std::vector<InstanceNameXml > temp4 ;
    std::vector<InstanceNameXml > *v4 ;
    PyObject * obj0 = 0 ;
    PyObject * obj3 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OiiO:InstanceNameVector___setslice__",&obj0,&arg2,&arg3,&obj3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTInstanceNameXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        if (PyTuple_Check(obj3) || PyList_Check(obj3)) {
            unsigned int size = (PyTuple_Check(obj3) ?
            PyTuple_Size(obj3) :
            PyList_Size(obj3));
            temp4 = std::vector<InstanceNameXml >(size);
            arg4 = &temp4;
            for (unsigned int i=0; i<size; i++) {
                InstanceNameXml* x;
                PyObject* o = PySequence_GetItem(obj3,i);
                if ((SWIG_ConvertPtr(o,(void **) &x, 
                SWIGTYPE_p_InstanceNameXml,0)) != -1) {
                    temp4[i] = *x;
                    Py_DECREF(o);
                }else {
                    Py_DECREF(o);
                    PyErr_SetString(PyExc_TypeError,
                    "vector<""InstanceNameXml""> expected");
                    SWIG_fail;
                }
            }
        }else if (SWIG_ConvertPtr(obj3,(void **) &v4, 
        SWIGTYPE_p_std__vectorTInstanceNameXml_t,0) != -1) {
            arg4 = v4;
        }else {
            PyErr_SetString(PyExc_TypeError,"vector<" "InstanceNameXml" "> expected");
            SWIG_fail;
        }
    }
    {
        try {
            std_vectorlInstanceNameXml_g___setslice_____(arg1,arg2,arg3,(std::vector<InstanceNameXml > const &)*arg4);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_InstanceNameVector___delitem__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<InstanceNameXml > *arg1 = (std::vector<InstanceNameXml > *) 0 ;
    int arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:InstanceNameVector___delitem__",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTInstanceNameXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            std_vectorlInstanceNameXml_g___delitem_____(arg1,arg2);
            
        }catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_InstanceNameVector___delslice__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<InstanceNameXml > *arg1 = (std::vector<InstanceNameXml > *) 0 ;
    int arg2 ;
    int arg3 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oii:InstanceNameVector___delslice__",&obj0,&arg2,&arg3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTInstanceNameXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            std_vectorlInstanceNameXml_g___delslice_____(arg1,arg2,arg3);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_InstanceNameVector(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<InstanceNameXml > *arg1 = (std::vector<InstanceNameXml > *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_InstanceNameVector",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTInstanceNameXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * InstanceNameVector_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_std__vectorTInstanceNameXml_t, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_new_InstanceNameArray(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<InstanceNameXml > *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_InstanceNameArray")) goto fail;
    {
        try {
            result = (ArrayXml<InstanceNameXml > *)new ArrayXml<InstanceNameXml >();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ArrayXmlTInstanceNameXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_InstanceNameArray_add(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<InstanceNameXml > *arg1 = (ArrayXml<InstanceNameXml > *) 0 ;
    InstanceNameXml *arg2 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:InstanceNameArray_add",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTInstanceNameXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_InstanceNameXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            (arg1)->add((InstanceNameXml const &)*arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_InstanceNameArray_toStringBuffer(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<InstanceNameXml > *arg1 = (ArrayXml<InstanceNameXml > *) 0 ;
    string *arg2 = 0 ;
    char *arg3 = (char *) " " ;
    char *arg4 = (char *) "" ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO|ss:InstanceNameArray_toStringBuffer",&obj0,&obj1,&arg3,&arg4)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTInstanceNameXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_string,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            (arg1)->toStringBuffer(*arg2,arg3,arg4);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_InstanceNameArray___setitem__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<InstanceNameXml > *arg1 = (ArrayXml<InstanceNameXml > *) 0 ;
    int arg2 ;
    InstanceNameXml *arg3 = (InstanceNameXml *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OiO:InstanceNameArray___setitem__",&obj0,&arg2,&obj2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTInstanceNameXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_InstanceNameXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            ArrayXmllInstanceNameXml_g___setitem_____(arg1,arg2,arg3);
            
        }catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_InstanceNameArray___getitem__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<InstanceNameXml > *arg1 = (ArrayXml<InstanceNameXml > *) 0 ;
    int arg2 ;
    InstanceNameXml *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:InstanceNameArray___getitem__",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTInstanceNameXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (InstanceNameXml *)ArrayXmllInstanceNameXml_g___getitem_____(arg1,arg2);
            
        }catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_InstanceNameXml, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_InstanceNameArray___str__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<InstanceNameXml > *arg1 = (ArrayXml<InstanceNameXml > *) 0 ;
    string result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:InstanceNameArray___str__",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTInstanceNameXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = ArrayXmllInstanceNameXml_g___str_____(arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    {
        resultobj = PyString_FromString((&result)->c_str());
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_InstanceNameArray___iter__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<InstanceNameXml > *arg1 = (ArrayXml<InstanceNameXml > *) 0 ;
    ArrayIterator<InstanceNameXml > result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:InstanceNameArray___iter__",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTInstanceNameXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = ArrayXmllInstanceNameXml_g___iter_____(arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    {
        ArrayIterator<InstanceNameXml > * resultptr;
        resultptr = new ArrayIterator<InstanceNameXml >((ArrayIterator<InstanceNameXml > &) result);
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_ArrayIteratorTInstanceNameXml_t, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_InstanceNameArray(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<InstanceNameXml > *arg1 = (ArrayXml<InstanceNameXml > *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_InstanceNameArray",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTInstanceNameXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * InstanceNameArray_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_ArrayXmlTInstanceNameXml_t, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_InstanceNameIterator_it_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<InstanceNameXml > *arg1 = (ArrayIterator<InstanceNameXml > *) 0 ;
    int arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:InstanceNameIterator_it_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTInstanceNameXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->it = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_InstanceNameIterator_it_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<InstanceNameXml > *arg1 = (ArrayIterator<InstanceNameXml > *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:InstanceNameIterator_it_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTInstanceNameXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (int) ((arg1)->it);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_InstanceNameIterator_c_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<InstanceNameXml > *arg1 = (ArrayIterator<InstanceNameXml > *) 0 ;
    ArrayXml<InstanceNameXml > *arg2 = (ArrayXml<InstanceNameXml > *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:InstanceNameIterator_c_set",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTInstanceNameXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_ArrayXmlTInstanceNameXml_t,SWIG_POINTER_EXCEPTION | SWIG_POINTER_DISOWN )) == -1) SWIG_fail;
    if (arg1) (arg1)->c = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_InstanceNameIterator_c_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<InstanceNameXml > *arg1 = (ArrayIterator<InstanceNameXml > *) 0 ;
    ArrayXml<InstanceNameXml > *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:InstanceNameIterator_c_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTInstanceNameXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (ArrayXml<InstanceNameXml > *) ((arg1)->c);
    
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ArrayXmlTInstanceNameXml_t, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_InstanceNameIterator__SWIG_0(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<InstanceNameXml > *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_InstanceNameIterator")) goto fail;
    {
        try {
            result = (ArrayIterator<InstanceNameXml > *)new ArrayIterator<InstanceNameXml >();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ArrayIteratorTInstanceNameXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_InstanceNameIterator__SWIG_1(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<InstanceNameXml > *arg1 = 0 ;
    ArrayIterator<InstanceNameXml > *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:new_InstanceNameIterator",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTInstanceNameXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            result = (ArrayIterator<InstanceNameXml > *)new ArrayIterator<InstanceNameXml >((ArrayIterator<InstanceNameXml > const &)*arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ArrayIteratorTInstanceNameXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_InstanceNameIterator__SWIG_2(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    ArrayXml<InstanceNameXml > *arg2 = (ArrayXml<InstanceNameXml > *) 0 ;
    ArrayIterator<InstanceNameXml > *result;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"iO:new_InstanceNameIterator",&arg1,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_ArrayXmlTInstanceNameXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (ArrayIterator<InstanceNameXml > *)new ArrayIterator<InstanceNameXml >(arg1,arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ArrayIteratorTInstanceNameXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_InstanceNameIterator(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[3];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 0) {
        return _wrap_new_InstanceNameIterator__SWIG_0(self,args);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_ArrayIteratorTInstanceNameXml_t, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            }else {
                _v = 1;
            }
        }
        if (_v) {
            return _wrap_new_InstanceNameIterator__SWIG_1(self,args);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = (PyInt_Check(argv[0]) || PyLong_Check(argv[0])) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                if (SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_ArrayXmlTInstanceNameXml_t, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                }else {
                    _v = 1;
                }
            }
            if (_v) {
                return _wrap_new_InstanceNameIterator__SWIG_2(self,args);
            }
        }
    }
    
    PyErr_SetString(PyExc_TypeError,"No matching function for overloaded 'new_InstanceNameIterator'");
    return NULL;
}


static PyObject *_wrap_InstanceNameIterator___iter__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<InstanceNameXml > *arg1 = (ArrayIterator<InstanceNameXml > *) 0 ;
    ArrayIterator<InstanceNameXml > result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:InstanceNameIterator___iter__",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTInstanceNameXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (arg1)->__iter__();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    {
        ArrayIterator<InstanceNameXml > * resultptr;
        resultptr = new ArrayIterator<InstanceNameXml >((ArrayIterator<InstanceNameXml > &) result);
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_ArrayIteratorTInstanceNameXml_t, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_InstanceNameIterator_next(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<InstanceNameXml > *arg1 = (ArrayIterator<InstanceNameXml > *) 0 ;
    InstanceNameXml *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:InstanceNameIterator_next",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTInstanceNameXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (InstanceNameXml *)(arg1)->next();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_InstanceNameXml, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_InstanceNameIterator(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<InstanceNameXml > *arg1 = (ArrayIterator<InstanceNameXml > *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_InstanceNameIterator",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTInstanceNameXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * InstanceNameIterator_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_ArrayIteratorTInstanceNameXml_t, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_new_InstanceVector__SWIG_0(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    unsigned int arg1 = (unsigned int) 0 ;
    std::vector<InstanceXml > *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"|O:new_InstanceVector",&obj0)) goto fail;
    if (obj0) {
        arg1 = (unsigned int) PyInt_AsLong(obj0);
        if (PyErr_Occurred()) SWIG_fail;
    }
    {
        try {
            result = (std::vector<InstanceXml > *)new std::vector<InstanceXml >(arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__vectorTInstanceXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_InstanceVector__SWIG_1(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    unsigned int arg1 ;
    InstanceXml *arg2 = 0 ;
    std::vector<InstanceXml > *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:new_InstanceVector",&obj0,&obj1)) goto fail;
    arg1 = (unsigned int) PyInt_AsLong(obj0);
    if (PyErr_Occurred()) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_InstanceXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            result = (std::vector<InstanceXml > *)new std::vector<InstanceXml >(arg1,(InstanceXml const &)*arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__vectorTInstanceXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_InstanceVector__SWIG_2(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<InstanceXml > *arg1 = 0 ;
    std::vector<InstanceXml > *result;
    std::vector<InstanceXml > temp1 ;
    std::vector<InstanceXml > *v1 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:new_InstanceVector",&obj0)) goto fail;
    {
        if (PyTuple_Check(obj0) || PyList_Check(obj0)) {
            unsigned int size = (PyTuple_Check(obj0) ?
            PyTuple_Size(obj0) :
            PyList_Size(obj0));
            temp1 = std::vector<InstanceXml >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                InstanceXml* x;
                PyObject* o = PySequence_GetItem(obj0,i);
                if ((SWIG_ConvertPtr(o,(void **) &x, 
                SWIGTYPE_p_InstanceXml,0)) != -1) {
                    temp1[i] = *x;
                    Py_DECREF(o);
                }else {
                    Py_DECREF(o);
                    PyErr_SetString(PyExc_TypeError,
                    "vector<""InstanceXml""> expected");
                    SWIG_fail;
                }
            }
        }else if (SWIG_ConvertPtr(obj0,(void **) &v1, 
        SWIGTYPE_p_std__vectorTInstanceXml_t,0) != -1) {
            arg1 = v1;
        }else {
            PyErr_SetString(PyExc_TypeError,"vector<" "InstanceXml" "> expected");
            SWIG_fail;
        }
    }
    {
        try {
            result = (std::vector<InstanceXml > *)new std::vector<InstanceXml >((std::vector<InstanceXml > const &)*arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__vectorTInstanceXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_InstanceVector(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[3];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if ((argc >= 0) && (argc <= 1)) {
        int _v;
        if (argc <= 0) {
            return _wrap_new_InstanceVector__SWIG_0(self,args);
        }
        {
            _v = (PyInt_Check(argv[0]) || PyLong_Check(argv[0])) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_InstanceVector__SWIG_0(self,args);
        }
    }
    if (argc == 1) {
        int _v;
        {
            /* native sequence? */
            if (PyTuple_Check(argv[0]) || PyList_Check(argv[0])) {
                unsigned int size = (PyTuple_Check(argv[0]) ?
                PyTuple_Size(argv[0]) :
                PyList_Size(argv[0]));
                if (size == 0) {
                    /* an empty sequence can be of any type */
                    _v = 1;
                }else {
                    /* check the first element only */
                    InstanceXml* x;
                    PyObject* o = PySequence_GetItem(argv[0],0);
                    if ((SWIG_ConvertPtr(o,(void **) &x, 
                    SWIGTYPE_p_InstanceXml,0)) != -1)
                    _v = 1;
                    else
                    _v = 0;
                    Py_DECREF(o);
                }
            }else {
                /* wrapped vector? */
                std::vector<InstanceXml >* v;
                if (SWIG_ConvertPtr(argv[0],(void **) &v, 
                SWIGTYPE_p_std__vectorTInstanceXml_t,0) != -1)
                _v = 1;
                else
                _v = 0;
            }
        }
        if (_v) {
            return _wrap_new_InstanceVector__SWIG_2(self,args);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = (PyInt_Check(argv[0]) || PyLong_Check(argv[0])) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                if (SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_InstanceXml, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                }else {
                    _v = 1;
                }
            }
            if (_v) {
                return _wrap_new_InstanceVector__SWIG_1(self,args);
            }
        }
    }
    
    PyErr_SetString(PyExc_TypeError,"No matching function for overloaded 'new_InstanceVector'");
    return NULL;
}


static PyObject *_wrap_InstanceVector___len__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<InstanceXml > *arg1 = (std::vector<InstanceXml > *) 0 ;
    unsigned int result;
    std::vector<InstanceXml > temp1 ;
    std::vector<InstanceXml > *v1 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:InstanceVector___len__",&obj0)) goto fail;
    {
        if (PyTuple_Check(obj0) || PyList_Check(obj0)) {
            unsigned int size = (PyTuple_Check(obj0) ?
            PyTuple_Size(obj0) :
            PyList_Size(obj0));
            temp1 = std::vector<InstanceXml >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                InstanceXml* x;
                PyObject* o = PySequence_GetItem(obj0,i);
                if ((SWIG_ConvertPtr(o,(void **) &x, 
                SWIGTYPE_p_InstanceXml,0)) != -1) {
                    temp1[i] = *x;
                    Py_DECREF(o);
                }else {
                    Py_DECREF(o);
                    PyErr_SetString(PyExc_TypeError,
                    "vector<""InstanceXml""> expected");
                    SWIG_fail;
                }
            }
        }else if (SWIG_ConvertPtr(obj0,(void **) &v1, 
        SWIGTYPE_p_std__vectorTInstanceXml_t,0) != -1) {
            arg1 = v1;
        }else {
            PyErr_SetString(PyExc_TypeError,"vector<" "InstanceXml" "> expected");
            SWIG_fail;
        }
    }
    {
        try {
            result = (unsigned int)((std::vector<InstanceXml > const *)arg1)->size();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_InstanceVector_clear(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<InstanceXml > *arg1 = (std::vector<InstanceXml > *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:InstanceVector_clear",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTInstanceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            (arg1)->clear();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_InstanceVector_append(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<InstanceXml > *arg1 = (std::vector<InstanceXml > *) 0 ;
    InstanceXml *arg2 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:InstanceVector_append",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTInstanceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_InstanceXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            (arg1)->push_back((InstanceXml const &)*arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_InstanceVector___nonzero__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<InstanceXml > *arg1 = (std::vector<InstanceXml > *) 0 ;
    bool result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:InstanceVector___nonzero__",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTInstanceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (bool)std_vectorlInstanceXml_g___nonzero_____(arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_InstanceVector_pop(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<InstanceXml > *arg1 = (std::vector<InstanceXml > *) 0 ;
    InstanceXml result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:InstanceVector_pop",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTInstanceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = std_vectorlInstanceXml_g_pop___(arg1);
            
        }catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    {
        InstanceXml * resultptr;
        resultptr = new InstanceXml((InstanceXml &) result);
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_InstanceXml, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_InstanceVector___getitem__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<InstanceXml > *arg1 = (std::vector<InstanceXml > *) 0 ;
    int arg2 ;
    InstanceXml *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:InstanceVector___getitem__",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTInstanceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            {
                InstanceXml &_result_ref = std_vectorlInstanceXml_g___getitem_____(arg1,arg2);
                result = (InstanceXml *) &_result_ref;
            }
            
        }catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_InstanceXml, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_InstanceVector___getslice__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<InstanceXml > *arg1 = (std::vector<InstanceXml > *) 0 ;
    int arg2 ;
    int arg3 ;
    std::vector<InstanceXml > result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oii:InstanceVector___getslice__",&obj0,&arg2,&arg3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTInstanceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = std_vectorlInstanceXml_g___getslice_____(arg1,arg2,arg3);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    {
        resultobj = PyTuple_New((&result)->size());
        for (unsigned int i=0; i<(&result)->size(); i++) {
            InstanceXml* ptr = new InstanceXml(((std::vector<InstanceXml > &)result)[i]);
            PyTuple_SetItem(resultobj,i,
            SWIG_NewPointerObj((void *) ptr, 
            SWIGTYPE_p_InstanceXml, 1));
        }
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_InstanceVector___setitem__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<InstanceXml > *arg1 = (std::vector<InstanceXml > *) 0 ;
    int arg2 ;
    InstanceXml *arg3 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OiO:InstanceVector___setitem__",&obj0,&arg2,&obj2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTInstanceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_InstanceXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg3 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            std_vectorlInstanceXml_g___setitem_____(arg1,arg2,(InstanceXml const &)*arg3);
            
        }catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_InstanceVector___setslice__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<InstanceXml > *arg1 = (std::vector<InstanceXml > *) 0 ;
    int arg2 ;
    int arg3 ;
    std::vector<InstanceXml > *arg4 = 0 ;
    std::vector<InstanceXml > temp4 ;
    std::vector<InstanceXml > *v4 ;
    PyObject * obj0 = 0 ;
    PyObject * obj3 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OiiO:InstanceVector___setslice__",&obj0,&arg2,&arg3,&obj3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTInstanceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        if (PyTuple_Check(obj3) || PyList_Check(obj3)) {
            unsigned int size = (PyTuple_Check(obj3) ?
            PyTuple_Size(obj3) :
            PyList_Size(obj3));
            temp4 = std::vector<InstanceXml >(size);
            arg4 = &temp4;
            for (unsigned int i=0; i<size; i++) {
                InstanceXml* x;
                PyObject* o = PySequence_GetItem(obj3,i);
                if ((SWIG_ConvertPtr(o,(void **) &x, 
                SWIGTYPE_p_InstanceXml,0)) != -1) {
                    temp4[i] = *x;
                    Py_DECREF(o);
                }else {
                    Py_DECREF(o);
                    PyErr_SetString(PyExc_TypeError,
                    "vector<""InstanceXml""> expected");
                    SWIG_fail;
                }
            }
        }else if (SWIG_ConvertPtr(obj3,(void **) &v4, 
        SWIGTYPE_p_std__vectorTInstanceXml_t,0) != -1) {
            arg4 = v4;
        }else {
            PyErr_SetString(PyExc_TypeError,"vector<" "InstanceXml" "> expected");
            SWIG_fail;
        }
    }
    {
        try {
            std_vectorlInstanceXml_g___setslice_____(arg1,arg2,arg3,(std::vector<InstanceXml > const &)*arg4);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_InstanceVector___delitem__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<InstanceXml > *arg1 = (std::vector<InstanceXml > *) 0 ;
    int arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:InstanceVector___delitem__",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTInstanceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            std_vectorlInstanceXml_g___delitem_____(arg1,arg2);
            
        }catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_InstanceVector___delslice__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<InstanceXml > *arg1 = (std::vector<InstanceXml > *) 0 ;
    int arg2 ;
    int arg3 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oii:InstanceVector___delslice__",&obj0,&arg2,&arg3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTInstanceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            std_vectorlInstanceXml_g___delslice_____(arg1,arg2,arg3);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_InstanceVector(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<InstanceXml > *arg1 = (std::vector<InstanceXml > *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_InstanceVector",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTInstanceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * InstanceVector_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_std__vectorTInstanceXml_t, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_new_InstanceArray(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<InstanceXml > *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_InstanceArray")) goto fail;
    {
        try {
            result = (ArrayXml<InstanceXml > *)new ArrayXml<InstanceXml >();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ArrayXmlTInstanceXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_InstanceArray_add(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<InstanceXml > *arg1 = (ArrayXml<InstanceXml > *) 0 ;
    InstanceXml *arg2 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:InstanceArray_add",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTInstanceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_InstanceXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            (arg1)->add((InstanceXml const &)*arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_InstanceArray_toStringBuffer(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<InstanceXml > *arg1 = (ArrayXml<InstanceXml > *) 0 ;
    string *arg2 = 0 ;
    char *arg3 = (char *) " " ;
    char *arg4 = (char *) "" ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO|ss:InstanceArray_toStringBuffer",&obj0,&obj1,&arg3,&arg4)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTInstanceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_string,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            (arg1)->toStringBuffer(*arg2,arg3,arg4);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_InstanceArray___setitem__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<InstanceXml > *arg1 = (ArrayXml<InstanceXml > *) 0 ;
    int arg2 ;
    InstanceXml *arg3 = (InstanceXml *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OiO:InstanceArray___setitem__",&obj0,&arg2,&obj2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTInstanceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_InstanceXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            ArrayXmllInstanceXml_g___setitem_____(arg1,arg2,arg3);
            
        }catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_InstanceArray___getitem__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<InstanceXml > *arg1 = (ArrayXml<InstanceXml > *) 0 ;
    int arg2 ;
    InstanceXml *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:InstanceArray___getitem__",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTInstanceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (InstanceXml *)ArrayXmllInstanceXml_g___getitem_____(arg1,arg2);
            
        }catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_InstanceXml, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_InstanceArray___str__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<InstanceXml > *arg1 = (ArrayXml<InstanceXml > *) 0 ;
    string result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:InstanceArray___str__",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTInstanceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = ArrayXmllInstanceXml_g___str_____(arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    {
        resultobj = PyString_FromString((&result)->c_str());
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_InstanceArray___iter__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<InstanceXml > *arg1 = (ArrayXml<InstanceXml > *) 0 ;
    ArrayIterator<InstanceXml > result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:InstanceArray___iter__",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTInstanceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = ArrayXmllInstanceXml_g___iter_____(arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    {
        ArrayIterator<InstanceXml > * resultptr;
        resultptr = new ArrayIterator<InstanceXml >((ArrayIterator<InstanceXml > &) result);
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_ArrayIteratorTInstanceXml_t, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_InstanceArray(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<InstanceXml > *arg1 = (ArrayXml<InstanceXml > *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_InstanceArray",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTInstanceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * InstanceArray_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_ArrayXmlTInstanceXml_t, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_InstanceIterator_it_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<InstanceXml > *arg1 = (ArrayIterator<InstanceXml > *) 0 ;
    int arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:InstanceIterator_it_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTInstanceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->it = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_InstanceIterator_it_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<InstanceXml > *arg1 = (ArrayIterator<InstanceXml > *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:InstanceIterator_it_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTInstanceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (int) ((arg1)->it);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_InstanceIterator_c_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<InstanceXml > *arg1 = (ArrayIterator<InstanceXml > *) 0 ;
    ArrayXml<InstanceXml > *arg2 = (ArrayXml<InstanceXml > *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:InstanceIterator_c_set",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTInstanceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_ArrayXmlTInstanceXml_t,SWIG_POINTER_EXCEPTION | SWIG_POINTER_DISOWN )) == -1) SWIG_fail;
    if (arg1) (arg1)->c = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_InstanceIterator_c_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<InstanceXml > *arg1 = (ArrayIterator<InstanceXml > *) 0 ;
    ArrayXml<InstanceXml > *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:InstanceIterator_c_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTInstanceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (ArrayXml<InstanceXml > *) ((arg1)->c);
    
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ArrayXmlTInstanceXml_t, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_InstanceIterator__SWIG_0(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<InstanceXml > *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_InstanceIterator")) goto fail;
    {
        try {
            result = (ArrayIterator<InstanceXml > *)new ArrayIterator<InstanceXml >();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ArrayIteratorTInstanceXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_InstanceIterator__SWIG_1(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<InstanceXml > *arg1 = 0 ;
    ArrayIterator<InstanceXml > *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:new_InstanceIterator",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTInstanceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            result = (ArrayIterator<InstanceXml > *)new ArrayIterator<InstanceXml >((ArrayIterator<InstanceXml > const &)*arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ArrayIteratorTInstanceXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_InstanceIterator__SWIG_2(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    ArrayXml<InstanceXml > *arg2 = (ArrayXml<InstanceXml > *) 0 ;
    ArrayIterator<InstanceXml > *result;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"iO:new_InstanceIterator",&arg1,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_ArrayXmlTInstanceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (ArrayIterator<InstanceXml > *)new ArrayIterator<InstanceXml >(arg1,arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ArrayIteratorTInstanceXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_InstanceIterator(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[3];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 0) {
        return _wrap_new_InstanceIterator__SWIG_0(self,args);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_ArrayIteratorTInstanceXml_t, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            }else {
                _v = 1;
            }
        }
        if (_v) {
            return _wrap_new_InstanceIterator__SWIG_1(self,args);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = (PyInt_Check(argv[0]) || PyLong_Check(argv[0])) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                if (SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_ArrayXmlTInstanceXml_t, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                }else {
                    _v = 1;
                }
            }
            if (_v) {
                return _wrap_new_InstanceIterator__SWIG_2(self,args);
            }
        }
    }
    
    PyErr_SetString(PyExc_TypeError,"No matching function for overloaded 'new_InstanceIterator'");
    return NULL;
}


static PyObject *_wrap_InstanceIterator___iter__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<InstanceXml > *arg1 = (ArrayIterator<InstanceXml > *) 0 ;
    ArrayIterator<InstanceXml > result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:InstanceIterator___iter__",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTInstanceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (arg1)->__iter__();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    {
        ArrayIterator<InstanceXml > * resultptr;
        resultptr = new ArrayIterator<InstanceXml >((ArrayIterator<InstanceXml > &) result);
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_ArrayIteratorTInstanceXml_t, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_InstanceIterator_next(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<InstanceXml > *arg1 = (ArrayIterator<InstanceXml > *) 0 ;
    InstanceXml *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:InstanceIterator_next",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTInstanceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (InstanceXml *)(arg1)->next();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_InstanceXml, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_InstanceIterator(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<InstanceXml > *arg1 = (ArrayIterator<InstanceXml > *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_InstanceIterator",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTInstanceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * InstanceIterator_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_ArrayIteratorTInstanceXml_t, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_new_KeyBindingVector__SWIG_0(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    unsigned int arg1 = (unsigned int) 0 ;
    std::vector<KeyBindingXml > *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"|O:new_KeyBindingVector",&obj0)) goto fail;
    if (obj0) {
        arg1 = (unsigned int) PyInt_AsLong(obj0);
        if (PyErr_Occurred()) SWIG_fail;
    }
    {
        try {
            result = (std::vector<KeyBindingXml > *)new std::vector<KeyBindingXml >(arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__vectorTKeyBindingXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_KeyBindingVector__SWIG_1(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    unsigned int arg1 ;
    KeyBindingXml *arg2 = 0 ;
    std::vector<KeyBindingXml > *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:new_KeyBindingVector",&obj0,&obj1)) goto fail;
    arg1 = (unsigned int) PyInt_AsLong(obj0);
    if (PyErr_Occurred()) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_KeyBindingXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            result = (std::vector<KeyBindingXml > *)new std::vector<KeyBindingXml >(arg1,(KeyBindingXml const &)*arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__vectorTKeyBindingXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_KeyBindingVector__SWIG_2(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<KeyBindingXml > *arg1 = 0 ;
    std::vector<KeyBindingXml > *result;
    std::vector<KeyBindingXml > temp1 ;
    std::vector<KeyBindingXml > *v1 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:new_KeyBindingVector",&obj0)) goto fail;
    {
        if (PyTuple_Check(obj0) || PyList_Check(obj0)) {
            unsigned int size = (PyTuple_Check(obj0) ?
            PyTuple_Size(obj0) :
            PyList_Size(obj0));
            temp1 = std::vector<KeyBindingXml >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                KeyBindingXml* x;
                PyObject* o = PySequence_GetItem(obj0,i);
                if ((SWIG_ConvertPtr(o,(void **) &x, 
                SWIGTYPE_p_KeyBindingXml,0)) != -1) {
                    temp1[i] = *x;
                    Py_DECREF(o);
                }else {
                    Py_DECREF(o);
                    PyErr_SetString(PyExc_TypeError,
                    "vector<""KeyBindingXml""> expected");
                    SWIG_fail;
                }
            }
        }else if (SWIG_ConvertPtr(obj0,(void **) &v1, 
        SWIGTYPE_p_std__vectorTKeyBindingXml_t,0) != -1) {
            arg1 = v1;
        }else {
            PyErr_SetString(PyExc_TypeError,"vector<" "KeyBindingXml" "> expected");
            SWIG_fail;
        }
    }
    {
        try {
            result = (std::vector<KeyBindingXml > *)new std::vector<KeyBindingXml >((std::vector<KeyBindingXml > const &)*arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__vectorTKeyBindingXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_KeyBindingVector(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[3];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if ((argc >= 0) && (argc <= 1)) {
        int _v;
        if (argc <= 0) {
            return _wrap_new_KeyBindingVector__SWIG_0(self,args);
        }
        {
            _v = (PyInt_Check(argv[0]) || PyLong_Check(argv[0])) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_KeyBindingVector__SWIG_0(self,args);
        }
    }
    if (argc == 1) {
        int _v;
        {
            /* native sequence? */
            if (PyTuple_Check(argv[0]) || PyList_Check(argv[0])) {
                unsigned int size = (PyTuple_Check(argv[0]) ?
                PyTuple_Size(argv[0]) :
                PyList_Size(argv[0]));
                if (size == 0) {
                    /* an empty sequence can be of any type */
                    _v = 1;
                }else {
                    /* check the first element only */
                    KeyBindingXml* x;
                    PyObject* o = PySequence_GetItem(argv[0],0);
                    if ((SWIG_ConvertPtr(o,(void **) &x, 
                    SWIGTYPE_p_KeyBindingXml,0)) != -1)
                    _v = 1;
                    else
                    _v = 0;
                    Py_DECREF(o);
                }
            }else {
                /* wrapped vector? */
                std::vector<KeyBindingXml >* v;
                if (SWIG_ConvertPtr(argv[0],(void **) &v, 
                SWIGTYPE_p_std__vectorTKeyBindingXml_t,0) != -1)
                _v = 1;
                else
                _v = 0;
            }
        }
        if (_v) {
            return _wrap_new_KeyBindingVector__SWIG_2(self,args);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = (PyInt_Check(argv[0]) || PyLong_Check(argv[0])) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                if (SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_KeyBindingXml, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                }else {
                    _v = 1;
                }
            }
            if (_v) {
                return _wrap_new_KeyBindingVector__SWIG_1(self,args);
            }
        }
    }
    
    PyErr_SetString(PyExc_TypeError,"No matching function for overloaded 'new_KeyBindingVector'");
    return NULL;
}


static PyObject *_wrap_KeyBindingVector___len__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<KeyBindingXml > *arg1 = (std::vector<KeyBindingXml > *) 0 ;
    unsigned int result;
    std::vector<KeyBindingXml > temp1 ;
    std::vector<KeyBindingXml > *v1 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:KeyBindingVector___len__",&obj0)) goto fail;
    {
        if (PyTuple_Check(obj0) || PyList_Check(obj0)) {
            unsigned int size = (PyTuple_Check(obj0) ?
            PyTuple_Size(obj0) :
            PyList_Size(obj0));
            temp1 = std::vector<KeyBindingXml >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                KeyBindingXml* x;
                PyObject* o = PySequence_GetItem(obj0,i);
                if ((SWIG_ConvertPtr(o,(void **) &x, 
                SWIGTYPE_p_KeyBindingXml,0)) != -1) {
                    temp1[i] = *x;
                    Py_DECREF(o);
                }else {
                    Py_DECREF(o);
                    PyErr_SetString(PyExc_TypeError,
                    "vector<""KeyBindingXml""> expected");
                    SWIG_fail;
                }
            }
        }else if (SWIG_ConvertPtr(obj0,(void **) &v1, 
        SWIGTYPE_p_std__vectorTKeyBindingXml_t,0) != -1) {
            arg1 = v1;
        }else {
            PyErr_SetString(PyExc_TypeError,"vector<" "KeyBindingXml" "> expected");
            SWIG_fail;
        }
    }
    {
        try {
            result = (unsigned int)((std::vector<KeyBindingXml > const *)arg1)->size();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_KeyBindingVector_clear(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<KeyBindingXml > *arg1 = (std::vector<KeyBindingXml > *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:KeyBindingVector_clear",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTKeyBindingXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            (arg1)->clear();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_KeyBindingVector_append(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<KeyBindingXml > *arg1 = (std::vector<KeyBindingXml > *) 0 ;
    KeyBindingXml *arg2 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:KeyBindingVector_append",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTKeyBindingXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_KeyBindingXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            (arg1)->push_back((KeyBindingXml const &)*arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_KeyBindingVector___nonzero__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<KeyBindingXml > *arg1 = (std::vector<KeyBindingXml > *) 0 ;
    bool result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:KeyBindingVector___nonzero__",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTKeyBindingXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (bool)std_vectorlKeyBindingXml_g___nonzero_____(arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_KeyBindingVector_pop(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<KeyBindingXml > *arg1 = (std::vector<KeyBindingXml > *) 0 ;
    SwigValueWrapper< KeyBindingXml > result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:KeyBindingVector_pop",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTKeyBindingXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = std_vectorlKeyBindingXml_g_pop___(arg1);
            
        }catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    {
        KeyBindingXml * resultptr;
        resultptr = new KeyBindingXml((KeyBindingXml &) result);
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_KeyBindingXml, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_KeyBindingVector___getitem__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<KeyBindingXml > *arg1 = (std::vector<KeyBindingXml > *) 0 ;
    int arg2 ;
    KeyBindingXml *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:KeyBindingVector___getitem__",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTKeyBindingXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            {
                KeyBindingXml &_result_ref = std_vectorlKeyBindingXml_g___getitem_____(arg1,arg2);
                result = (KeyBindingXml *) &_result_ref;
            }
            
        }catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_KeyBindingXml, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_KeyBindingVector___getslice__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<KeyBindingXml > *arg1 = (std::vector<KeyBindingXml > *) 0 ;
    int arg2 ;
    int arg3 ;
    std::vector<KeyBindingXml > result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oii:KeyBindingVector___getslice__",&obj0,&arg2,&arg3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTKeyBindingXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = std_vectorlKeyBindingXml_g___getslice_____(arg1,arg2,arg3);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    {
        resultobj = PyTuple_New((&result)->size());
        for (unsigned int i=0; i<(&result)->size(); i++) {
            KeyBindingXml* ptr = new KeyBindingXml(((std::vector<KeyBindingXml > &)result)[i]);
            PyTuple_SetItem(resultobj,i,
            SWIG_NewPointerObj((void *) ptr, 
            SWIGTYPE_p_KeyBindingXml, 1));
        }
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_KeyBindingVector___setitem__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<KeyBindingXml > *arg1 = (std::vector<KeyBindingXml > *) 0 ;
    int arg2 ;
    KeyBindingXml *arg3 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OiO:KeyBindingVector___setitem__",&obj0,&arg2,&obj2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTKeyBindingXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_KeyBindingXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg3 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            std_vectorlKeyBindingXml_g___setitem_____(arg1,arg2,(KeyBindingXml const &)*arg3);
            
        }catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_KeyBindingVector___setslice__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<KeyBindingXml > *arg1 = (std::vector<KeyBindingXml > *) 0 ;
    int arg2 ;
    int arg3 ;
    std::vector<KeyBindingXml > *arg4 = 0 ;
    std::vector<KeyBindingXml > temp4 ;
    std::vector<KeyBindingXml > *v4 ;
    PyObject * obj0 = 0 ;
    PyObject * obj3 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OiiO:KeyBindingVector___setslice__",&obj0,&arg2,&arg3,&obj3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTKeyBindingXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        if (PyTuple_Check(obj3) || PyList_Check(obj3)) {
            unsigned int size = (PyTuple_Check(obj3) ?
            PyTuple_Size(obj3) :
            PyList_Size(obj3));
            temp4 = std::vector<KeyBindingXml >(size);
            arg4 = &temp4;
            for (unsigned int i=0; i<size; i++) {
                KeyBindingXml* x;
                PyObject* o = PySequence_GetItem(obj3,i);
                if ((SWIG_ConvertPtr(o,(void **) &x, 
                SWIGTYPE_p_KeyBindingXml,0)) != -1) {
                    temp4[i] = *x;
                    Py_DECREF(o);
                }else {
                    Py_DECREF(o);
                    PyErr_SetString(PyExc_TypeError,
                    "vector<""KeyBindingXml""> expected");
                    SWIG_fail;
                }
            }
        }else if (SWIG_ConvertPtr(obj3,(void **) &v4, 
        SWIGTYPE_p_std__vectorTKeyBindingXml_t,0) != -1) {
            arg4 = v4;
        }else {
            PyErr_SetString(PyExc_TypeError,"vector<" "KeyBindingXml" "> expected");
            SWIG_fail;
        }
    }
    {
        try {
            std_vectorlKeyBindingXml_g___setslice_____(arg1,arg2,arg3,(std::vector<KeyBindingXml > const &)*arg4);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_KeyBindingVector___delitem__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<KeyBindingXml > *arg1 = (std::vector<KeyBindingXml > *) 0 ;
    int arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:KeyBindingVector___delitem__",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTKeyBindingXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            std_vectorlKeyBindingXml_g___delitem_____(arg1,arg2);
            
        }catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_KeyBindingVector___delslice__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<KeyBindingXml > *arg1 = (std::vector<KeyBindingXml > *) 0 ;
    int arg2 ;
    int arg3 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oii:KeyBindingVector___delslice__",&obj0,&arg2,&arg3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTKeyBindingXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            std_vectorlKeyBindingXml_g___delslice_____(arg1,arg2,arg3);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_KeyBindingVector(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<KeyBindingXml > *arg1 = (std::vector<KeyBindingXml > *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_KeyBindingVector",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTKeyBindingXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * KeyBindingVector_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_std__vectorTKeyBindingXml_t, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_new_KeyBindingArray(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<KeyBindingXml > *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_KeyBindingArray")) goto fail;
    {
        try {
            result = (ArrayXml<KeyBindingXml > *)new ArrayXml<KeyBindingXml >();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ArrayXmlTKeyBindingXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_KeyBindingArray_add(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<KeyBindingXml > *arg1 = (ArrayXml<KeyBindingXml > *) 0 ;
    KeyBindingXml *arg2 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:KeyBindingArray_add",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTKeyBindingXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_KeyBindingXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            (arg1)->add((KeyBindingXml const &)*arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_KeyBindingArray_toStringBuffer(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<KeyBindingXml > *arg1 = (ArrayXml<KeyBindingXml > *) 0 ;
    string *arg2 = 0 ;
    char *arg3 = (char *) " " ;
    char *arg4 = (char *) "" ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO|ss:KeyBindingArray_toStringBuffer",&obj0,&obj1,&arg3,&arg4)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTKeyBindingXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_string,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            (arg1)->toStringBuffer(*arg2,arg3,arg4);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_KeyBindingArray___setitem__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<KeyBindingXml > *arg1 = (ArrayXml<KeyBindingXml > *) 0 ;
    int arg2 ;
    KeyBindingXml *arg3 = (KeyBindingXml *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OiO:KeyBindingArray___setitem__",&obj0,&arg2,&obj2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTKeyBindingXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_KeyBindingXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            ArrayXmllKeyBindingXml_g___setitem_____(arg1,arg2,arg3);
            
        }catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_KeyBindingArray___getitem__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<KeyBindingXml > *arg1 = (ArrayXml<KeyBindingXml > *) 0 ;
    int arg2 ;
    KeyBindingXml *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:KeyBindingArray___getitem__",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTKeyBindingXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (KeyBindingXml *)ArrayXmllKeyBindingXml_g___getitem_____(arg1,arg2);
            
        }catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_KeyBindingXml, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_KeyBindingArray___str__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<KeyBindingXml > *arg1 = (ArrayXml<KeyBindingXml > *) 0 ;
    string result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:KeyBindingArray___str__",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTKeyBindingXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = ArrayXmllKeyBindingXml_g___str_____(arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    {
        resultobj = PyString_FromString((&result)->c_str());
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_KeyBindingArray___iter__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<KeyBindingXml > *arg1 = (ArrayXml<KeyBindingXml > *) 0 ;
    ArrayIterator<KeyBindingXml > result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:KeyBindingArray___iter__",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTKeyBindingXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = ArrayXmllKeyBindingXml_g___iter_____(arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    {
        ArrayIterator<KeyBindingXml > * resultptr;
        resultptr = new ArrayIterator<KeyBindingXml >((ArrayIterator<KeyBindingXml > &) result);
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_ArrayIteratorTKeyBindingXml_t, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_KeyBindingArray(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<KeyBindingXml > *arg1 = (ArrayXml<KeyBindingXml > *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_KeyBindingArray",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTKeyBindingXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * KeyBindingArray_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_ArrayXmlTKeyBindingXml_t, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_KeyBindingIterator_it_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<KeyBindingXml > *arg1 = (ArrayIterator<KeyBindingXml > *) 0 ;
    int arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:KeyBindingIterator_it_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTKeyBindingXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->it = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_KeyBindingIterator_it_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<KeyBindingXml > *arg1 = (ArrayIterator<KeyBindingXml > *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:KeyBindingIterator_it_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTKeyBindingXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (int) ((arg1)->it);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_KeyBindingIterator_c_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<KeyBindingXml > *arg1 = (ArrayIterator<KeyBindingXml > *) 0 ;
    ArrayXml<KeyBindingXml > *arg2 = (ArrayXml<KeyBindingXml > *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:KeyBindingIterator_c_set",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTKeyBindingXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_ArrayXmlTKeyBindingXml_t,SWIG_POINTER_EXCEPTION | SWIG_POINTER_DISOWN )) == -1) SWIG_fail;
    if (arg1) (arg1)->c = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_KeyBindingIterator_c_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<KeyBindingXml > *arg1 = (ArrayIterator<KeyBindingXml > *) 0 ;
    ArrayXml<KeyBindingXml > *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:KeyBindingIterator_c_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTKeyBindingXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (ArrayXml<KeyBindingXml > *) ((arg1)->c);
    
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ArrayXmlTKeyBindingXml_t, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_KeyBindingIterator__SWIG_0(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<KeyBindingXml > *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_KeyBindingIterator")) goto fail;
    {
        try {
            result = (ArrayIterator<KeyBindingXml > *)new ArrayIterator<KeyBindingXml >();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ArrayIteratorTKeyBindingXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_KeyBindingIterator__SWIG_1(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<KeyBindingXml > *arg1 = 0 ;
    ArrayIterator<KeyBindingXml > *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:new_KeyBindingIterator",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTKeyBindingXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            result = (ArrayIterator<KeyBindingXml > *)new ArrayIterator<KeyBindingXml >((ArrayIterator<KeyBindingXml > const &)*arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ArrayIteratorTKeyBindingXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_KeyBindingIterator__SWIG_2(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    ArrayXml<KeyBindingXml > *arg2 = (ArrayXml<KeyBindingXml > *) 0 ;
    ArrayIterator<KeyBindingXml > *result;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"iO:new_KeyBindingIterator",&arg1,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_ArrayXmlTKeyBindingXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (ArrayIterator<KeyBindingXml > *)new ArrayIterator<KeyBindingXml >(arg1,arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ArrayIteratorTKeyBindingXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_KeyBindingIterator(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[3];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 0) {
        return _wrap_new_KeyBindingIterator__SWIG_0(self,args);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_ArrayIteratorTKeyBindingXml_t, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            }else {
                _v = 1;
            }
        }
        if (_v) {
            return _wrap_new_KeyBindingIterator__SWIG_1(self,args);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = (PyInt_Check(argv[0]) || PyLong_Check(argv[0])) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                if (SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_ArrayXmlTKeyBindingXml_t, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                }else {
                    _v = 1;
                }
            }
            if (_v) {
                return _wrap_new_KeyBindingIterator__SWIG_2(self,args);
            }
        }
    }
    
    PyErr_SetString(PyExc_TypeError,"No matching function for overloaded 'new_KeyBindingIterator'");
    return NULL;
}


static PyObject *_wrap_KeyBindingIterator___iter__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<KeyBindingXml > *arg1 = (ArrayIterator<KeyBindingXml > *) 0 ;
    ArrayIterator<KeyBindingXml > result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:KeyBindingIterator___iter__",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTKeyBindingXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (arg1)->__iter__();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    {
        ArrayIterator<KeyBindingXml > * resultptr;
        resultptr = new ArrayIterator<KeyBindingXml >((ArrayIterator<KeyBindingXml > &) result);
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_ArrayIteratorTKeyBindingXml_t, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_KeyBindingIterator_next(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<KeyBindingXml > *arg1 = (ArrayIterator<KeyBindingXml > *) 0 ;
    KeyBindingXml *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:KeyBindingIterator_next",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTKeyBindingXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (KeyBindingXml *)(arg1)->next();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_KeyBindingXml, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_KeyBindingIterator(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<KeyBindingXml > *arg1 = (ArrayIterator<KeyBindingXml > *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_KeyBindingIterator",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTKeyBindingXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * KeyBindingIterator_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_ArrayIteratorTKeyBindingXml_t, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_new_ClassNameVector__SWIG_0(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    unsigned int arg1 = (unsigned int) 0 ;
    std::vector<ClassNameXml > *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"|O:new_ClassNameVector",&obj0)) goto fail;
    if (obj0) {
        arg1 = (unsigned int) PyInt_AsLong(obj0);
        if (PyErr_Occurred()) SWIG_fail;
    }
    {
        try {
            result = (std::vector<ClassNameXml > *)new std::vector<ClassNameXml >(arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__vectorTClassNameXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_ClassNameVector__SWIG_1(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    unsigned int arg1 ;
    ClassNameXml *arg2 = 0 ;
    std::vector<ClassNameXml > *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:new_ClassNameVector",&obj0,&obj1)) goto fail;
    arg1 = (unsigned int) PyInt_AsLong(obj0);
    if (PyErr_Occurred()) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_ClassNameXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            result = (std::vector<ClassNameXml > *)new std::vector<ClassNameXml >(arg1,(ClassNameXml const &)*arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__vectorTClassNameXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_ClassNameVector__SWIG_2(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<ClassNameXml > *arg1 = 0 ;
    std::vector<ClassNameXml > *result;
    std::vector<ClassNameXml > temp1 ;
    std::vector<ClassNameXml > *v1 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:new_ClassNameVector",&obj0)) goto fail;
    {
        if (PyTuple_Check(obj0) || PyList_Check(obj0)) {
            unsigned int size = (PyTuple_Check(obj0) ?
            PyTuple_Size(obj0) :
            PyList_Size(obj0));
            temp1 = std::vector<ClassNameXml >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                ClassNameXml* x;
                PyObject* o = PySequence_GetItem(obj0,i);
                if ((SWIG_ConvertPtr(o,(void **) &x, 
                SWIGTYPE_p_ClassNameXml,0)) != -1) {
                    temp1[i] = *x;
                    Py_DECREF(o);
                }else {
                    Py_DECREF(o);
                    PyErr_SetString(PyExc_TypeError,
                    "vector<""ClassNameXml""> expected");
                    SWIG_fail;
                }
            }
        }else if (SWIG_ConvertPtr(obj0,(void **) &v1, 
        SWIGTYPE_p_std__vectorTClassNameXml_t,0) != -1) {
            arg1 = v1;
        }else {
            PyErr_SetString(PyExc_TypeError,"vector<" "ClassNameXml" "> expected");
            SWIG_fail;
        }
    }
    {
        try {
            result = (std::vector<ClassNameXml > *)new std::vector<ClassNameXml >((std::vector<ClassNameXml > const &)*arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__vectorTClassNameXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_ClassNameVector(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[3];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if ((argc >= 0) && (argc <= 1)) {
        int _v;
        if (argc <= 0) {
            return _wrap_new_ClassNameVector__SWIG_0(self,args);
        }
        {
            _v = (PyInt_Check(argv[0]) || PyLong_Check(argv[0])) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_ClassNameVector__SWIG_0(self,args);
        }
    }
    if (argc == 1) {
        int _v;
        {
            /* native sequence? */
            if (PyTuple_Check(argv[0]) || PyList_Check(argv[0])) {
                unsigned int size = (PyTuple_Check(argv[0]) ?
                PyTuple_Size(argv[0]) :
                PyList_Size(argv[0]));
                if (size == 0) {
                    /* an empty sequence can be of any type */
                    _v = 1;
                }else {
                    /* check the first element only */
                    ClassNameXml* x;
                    PyObject* o = PySequence_GetItem(argv[0],0);
                    if ((SWIG_ConvertPtr(o,(void **) &x, 
                    SWIGTYPE_p_ClassNameXml,0)) != -1)
                    _v = 1;
                    else
                    _v = 0;
                    Py_DECREF(o);
                }
            }else {
                /* wrapped vector? */
                std::vector<ClassNameXml >* v;
                if (SWIG_ConvertPtr(argv[0],(void **) &v, 
                SWIGTYPE_p_std__vectorTClassNameXml_t,0) != -1)
                _v = 1;
                else
                _v = 0;
            }
        }
        if (_v) {
            return _wrap_new_ClassNameVector__SWIG_2(self,args);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = (PyInt_Check(argv[0]) || PyLong_Check(argv[0])) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                if (SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_ClassNameXml, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                }else {
                    _v = 1;
                }
            }
            if (_v) {
                return _wrap_new_ClassNameVector__SWIG_1(self,args);
            }
        }
    }
    
    PyErr_SetString(PyExc_TypeError,"No matching function for overloaded 'new_ClassNameVector'");
    return NULL;
}


static PyObject *_wrap_ClassNameVector___len__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<ClassNameXml > *arg1 = (std::vector<ClassNameXml > *) 0 ;
    unsigned int result;
    std::vector<ClassNameXml > temp1 ;
    std::vector<ClassNameXml > *v1 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:ClassNameVector___len__",&obj0)) goto fail;
    {
        if (PyTuple_Check(obj0) || PyList_Check(obj0)) {
            unsigned int size = (PyTuple_Check(obj0) ?
            PyTuple_Size(obj0) :
            PyList_Size(obj0));
            temp1 = std::vector<ClassNameXml >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                ClassNameXml* x;
                PyObject* o = PySequence_GetItem(obj0,i);
                if ((SWIG_ConvertPtr(o,(void **) &x, 
                SWIGTYPE_p_ClassNameXml,0)) != -1) {
                    temp1[i] = *x;
                    Py_DECREF(o);
                }else {
                    Py_DECREF(o);
                    PyErr_SetString(PyExc_TypeError,
                    "vector<""ClassNameXml""> expected");
                    SWIG_fail;
                }
            }
        }else if (SWIG_ConvertPtr(obj0,(void **) &v1, 
        SWIGTYPE_p_std__vectorTClassNameXml_t,0) != -1) {
            arg1 = v1;
        }else {
            PyErr_SetString(PyExc_TypeError,"vector<" "ClassNameXml" "> expected");
            SWIG_fail;
        }
    }
    {
        try {
            result = (unsigned int)((std::vector<ClassNameXml > const *)arg1)->size();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ClassNameVector_clear(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<ClassNameXml > *arg1 = (std::vector<ClassNameXml > *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:ClassNameVector_clear",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTClassNameXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            (arg1)->clear();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ClassNameVector_append(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<ClassNameXml > *arg1 = (std::vector<ClassNameXml > *) 0 ;
    ClassNameXml *arg2 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:ClassNameVector_append",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTClassNameXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_ClassNameXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            (arg1)->push_back((ClassNameXml const &)*arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ClassNameVector___nonzero__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<ClassNameXml > *arg1 = (std::vector<ClassNameXml > *) 0 ;
    bool result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:ClassNameVector___nonzero__",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTClassNameXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (bool)std_vectorlClassNameXml_g___nonzero_____(arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ClassNameVector_pop(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<ClassNameXml > *arg1 = (std::vector<ClassNameXml > *) 0 ;
    SwigValueWrapper< ClassNameXml > result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:ClassNameVector_pop",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTClassNameXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = std_vectorlClassNameXml_g_pop___(arg1);
            
        }catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    {
        ClassNameXml * resultptr;
        resultptr = new ClassNameXml((ClassNameXml &) result);
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_ClassNameXml, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ClassNameVector___getitem__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<ClassNameXml > *arg1 = (std::vector<ClassNameXml > *) 0 ;
    int arg2 ;
    ClassNameXml *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:ClassNameVector___getitem__",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTClassNameXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            {
                ClassNameXml &_result_ref = std_vectorlClassNameXml_g___getitem_____(arg1,arg2);
                result = (ClassNameXml *) &_result_ref;
            }
            
        }catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ClassNameXml, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ClassNameVector___getslice__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<ClassNameXml > *arg1 = (std::vector<ClassNameXml > *) 0 ;
    int arg2 ;
    int arg3 ;
    std::vector<ClassNameXml > result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oii:ClassNameVector___getslice__",&obj0,&arg2,&arg3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTClassNameXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = std_vectorlClassNameXml_g___getslice_____(arg1,arg2,arg3);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    {
        resultobj = PyTuple_New((&result)->size());
        for (unsigned int i=0; i<(&result)->size(); i++) {
            ClassNameXml* ptr = new ClassNameXml(((std::vector<ClassNameXml > &)result)[i]);
            PyTuple_SetItem(resultobj,i,
            SWIG_NewPointerObj((void *) ptr, 
            SWIGTYPE_p_ClassNameXml, 1));
        }
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ClassNameVector___setitem__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<ClassNameXml > *arg1 = (std::vector<ClassNameXml > *) 0 ;
    int arg2 ;
    ClassNameXml *arg3 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OiO:ClassNameVector___setitem__",&obj0,&arg2,&obj2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTClassNameXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_ClassNameXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg3 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            std_vectorlClassNameXml_g___setitem_____(arg1,arg2,(ClassNameXml const &)*arg3);
            
        }catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ClassNameVector___setslice__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<ClassNameXml > *arg1 = (std::vector<ClassNameXml > *) 0 ;
    int arg2 ;
    int arg3 ;
    std::vector<ClassNameXml > *arg4 = 0 ;
    std::vector<ClassNameXml > temp4 ;
    std::vector<ClassNameXml > *v4 ;
    PyObject * obj0 = 0 ;
    PyObject * obj3 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OiiO:ClassNameVector___setslice__",&obj0,&arg2,&arg3,&obj3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTClassNameXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        if (PyTuple_Check(obj3) || PyList_Check(obj3)) {
            unsigned int size = (PyTuple_Check(obj3) ?
            PyTuple_Size(obj3) :
            PyList_Size(obj3));
            temp4 = std::vector<ClassNameXml >(size);
            arg4 = &temp4;
            for (unsigned int i=0; i<size; i++) {
                ClassNameXml* x;
                PyObject* o = PySequence_GetItem(obj3,i);
                if ((SWIG_ConvertPtr(o,(void **) &x, 
                SWIGTYPE_p_ClassNameXml,0)) != -1) {
                    temp4[i] = *x;
                    Py_DECREF(o);
                }else {
                    Py_DECREF(o);
                    PyErr_SetString(PyExc_TypeError,
                    "vector<""ClassNameXml""> expected");
                    SWIG_fail;
                }
            }
        }else if (SWIG_ConvertPtr(obj3,(void **) &v4, 
        SWIGTYPE_p_std__vectorTClassNameXml_t,0) != -1) {
            arg4 = v4;
        }else {
            PyErr_SetString(PyExc_TypeError,"vector<" "ClassNameXml" "> expected");
            SWIG_fail;
        }
    }
    {
        try {
            std_vectorlClassNameXml_g___setslice_____(arg1,arg2,arg3,(std::vector<ClassNameXml > const &)*arg4);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ClassNameVector___delitem__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<ClassNameXml > *arg1 = (std::vector<ClassNameXml > *) 0 ;
    int arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:ClassNameVector___delitem__",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTClassNameXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            std_vectorlClassNameXml_g___delitem_____(arg1,arg2);
            
        }catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ClassNameVector___delslice__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<ClassNameXml > *arg1 = (std::vector<ClassNameXml > *) 0 ;
    int arg2 ;
    int arg3 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oii:ClassNameVector___delslice__",&obj0,&arg2,&arg3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTClassNameXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            std_vectorlClassNameXml_g___delslice_____(arg1,arg2,arg3);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_ClassNameVector(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<ClassNameXml > *arg1 = (std::vector<ClassNameXml > *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_ClassNameVector",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTClassNameXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * ClassNameVector_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_std__vectorTClassNameXml_t, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_new_ClassNameArray(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<ClassNameXml > *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_ClassNameArray")) goto fail;
    {
        try {
            result = (ArrayXml<ClassNameXml > *)new ArrayXml<ClassNameXml >();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ArrayXmlTClassNameXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ClassNameArray_add(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<ClassNameXml > *arg1 = (ArrayXml<ClassNameXml > *) 0 ;
    ClassNameXml *arg2 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:ClassNameArray_add",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTClassNameXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_ClassNameXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            (arg1)->add((ClassNameXml const &)*arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ClassNameArray_toStringBuffer(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<ClassNameXml > *arg1 = (ArrayXml<ClassNameXml > *) 0 ;
    string *arg2 = 0 ;
    char *arg3 = (char *) " " ;
    char *arg4 = (char *) "" ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO|ss:ClassNameArray_toStringBuffer",&obj0,&obj1,&arg3,&arg4)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTClassNameXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_string,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            (arg1)->toStringBuffer(*arg2,arg3,arg4);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ClassNameArray___setitem__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<ClassNameXml > *arg1 = (ArrayXml<ClassNameXml > *) 0 ;
    int arg2 ;
    ClassNameXml *arg3 = (ClassNameXml *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OiO:ClassNameArray___setitem__",&obj0,&arg2,&obj2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTClassNameXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_ClassNameXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            ArrayXmllClassNameXml_g___setitem_____(arg1,arg2,arg3);
            
        }catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ClassNameArray___getitem__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<ClassNameXml > *arg1 = (ArrayXml<ClassNameXml > *) 0 ;
    int arg2 ;
    ClassNameXml *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:ClassNameArray___getitem__",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTClassNameXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (ClassNameXml *)ArrayXmllClassNameXml_g___getitem_____(arg1,arg2);
            
        }catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ClassNameXml, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ClassNameArray___str__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<ClassNameXml > *arg1 = (ArrayXml<ClassNameXml > *) 0 ;
    string result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:ClassNameArray___str__",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTClassNameXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = ArrayXmllClassNameXml_g___str_____(arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    {
        resultobj = PyString_FromString((&result)->c_str());
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ClassNameArray___iter__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<ClassNameXml > *arg1 = (ArrayXml<ClassNameXml > *) 0 ;
    ArrayIterator<ClassNameXml > result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:ClassNameArray___iter__",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTClassNameXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = ArrayXmllClassNameXml_g___iter_____(arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    {
        ArrayIterator<ClassNameXml > * resultptr;
        resultptr = new ArrayIterator<ClassNameXml >((ArrayIterator<ClassNameXml > &) result);
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_ArrayIteratorTClassNameXml_t, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_ClassNameArray(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<ClassNameXml > *arg1 = (ArrayXml<ClassNameXml > *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_ClassNameArray",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTClassNameXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * ClassNameArray_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_ArrayXmlTClassNameXml_t, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_ClassNameIterator_it_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<ClassNameXml > *arg1 = (ArrayIterator<ClassNameXml > *) 0 ;
    int arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:ClassNameIterator_it_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTClassNameXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->it = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ClassNameIterator_it_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<ClassNameXml > *arg1 = (ArrayIterator<ClassNameXml > *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:ClassNameIterator_it_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTClassNameXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (int) ((arg1)->it);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ClassNameIterator_c_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<ClassNameXml > *arg1 = (ArrayIterator<ClassNameXml > *) 0 ;
    ArrayXml<ClassNameXml > *arg2 = (ArrayXml<ClassNameXml > *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:ClassNameIterator_c_set",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTClassNameXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_ArrayXmlTClassNameXml_t,SWIG_POINTER_EXCEPTION | SWIG_POINTER_DISOWN )) == -1) SWIG_fail;
    if (arg1) (arg1)->c = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ClassNameIterator_c_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<ClassNameXml > *arg1 = (ArrayIterator<ClassNameXml > *) 0 ;
    ArrayXml<ClassNameXml > *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:ClassNameIterator_c_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTClassNameXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (ArrayXml<ClassNameXml > *) ((arg1)->c);
    
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ArrayXmlTClassNameXml_t, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_ClassNameIterator__SWIG_0(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<ClassNameXml > *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_ClassNameIterator")) goto fail;
    {
        try {
            result = (ArrayIterator<ClassNameXml > *)new ArrayIterator<ClassNameXml >();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ArrayIteratorTClassNameXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_ClassNameIterator__SWIG_1(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<ClassNameXml > *arg1 = 0 ;
    ArrayIterator<ClassNameXml > *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:new_ClassNameIterator",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTClassNameXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            result = (ArrayIterator<ClassNameXml > *)new ArrayIterator<ClassNameXml >((ArrayIterator<ClassNameXml > const &)*arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ArrayIteratorTClassNameXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_ClassNameIterator__SWIG_2(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    ArrayXml<ClassNameXml > *arg2 = (ArrayXml<ClassNameXml > *) 0 ;
    ArrayIterator<ClassNameXml > *result;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"iO:new_ClassNameIterator",&arg1,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_ArrayXmlTClassNameXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (ArrayIterator<ClassNameXml > *)new ArrayIterator<ClassNameXml >(arg1,arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ArrayIteratorTClassNameXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_ClassNameIterator(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[3];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 0) {
        return _wrap_new_ClassNameIterator__SWIG_0(self,args);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_ArrayIteratorTClassNameXml_t, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            }else {
                _v = 1;
            }
        }
        if (_v) {
            return _wrap_new_ClassNameIterator__SWIG_1(self,args);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = (PyInt_Check(argv[0]) || PyLong_Check(argv[0])) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                if (SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_ArrayXmlTClassNameXml_t, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                }else {
                    _v = 1;
                }
            }
            if (_v) {
                return _wrap_new_ClassNameIterator__SWIG_2(self,args);
            }
        }
    }
    
    PyErr_SetString(PyExc_TypeError,"No matching function for overloaded 'new_ClassNameIterator'");
    return NULL;
}


static PyObject *_wrap_ClassNameIterator___iter__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<ClassNameXml > *arg1 = (ArrayIterator<ClassNameXml > *) 0 ;
    ArrayIterator<ClassNameXml > result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:ClassNameIterator___iter__",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTClassNameXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (arg1)->__iter__();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    {
        ArrayIterator<ClassNameXml > * resultptr;
        resultptr = new ArrayIterator<ClassNameXml >((ArrayIterator<ClassNameXml > &) result);
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_ArrayIteratorTClassNameXml_t, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ClassNameIterator_next(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<ClassNameXml > *arg1 = (ArrayIterator<ClassNameXml > *) 0 ;
    ClassNameXml *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:ClassNameIterator_next",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTClassNameXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (ClassNameXml *)(arg1)->next();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ClassNameXml, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_ClassNameIterator(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<ClassNameXml > *arg1 = (ArrayIterator<ClassNameXml > *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_ClassNameIterator",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTClassNameXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * ClassNameIterator_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_ArrayIteratorTClassNameXml_t, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_new_ClassVector__SWIG_0(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    unsigned int arg1 = (unsigned int) 0 ;
    std::vector<ClassXml > *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"|O:new_ClassVector",&obj0)) goto fail;
    if (obj0) {
        arg1 = (unsigned int) PyInt_AsLong(obj0);
        if (PyErr_Occurred()) SWIG_fail;
    }
    {
        try {
            result = (std::vector<ClassXml > *)new std::vector<ClassXml >(arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__vectorTClassXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_ClassVector__SWIG_1(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    unsigned int arg1 ;
    ClassXml *arg2 = 0 ;
    std::vector<ClassXml > *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:new_ClassVector",&obj0,&obj1)) goto fail;
    arg1 = (unsigned int) PyInt_AsLong(obj0);
    if (PyErr_Occurred()) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_ClassXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            result = (std::vector<ClassXml > *)new std::vector<ClassXml >(arg1,(ClassXml const &)*arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__vectorTClassXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_ClassVector__SWIG_2(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<ClassXml > *arg1 = 0 ;
    std::vector<ClassXml > *result;
    std::vector<ClassXml > temp1 ;
    std::vector<ClassXml > *v1 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:new_ClassVector",&obj0)) goto fail;
    {
        if (PyTuple_Check(obj0) || PyList_Check(obj0)) {
            unsigned int size = (PyTuple_Check(obj0) ?
            PyTuple_Size(obj0) :
            PyList_Size(obj0));
            temp1 = std::vector<ClassXml >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                ClassXml* x;
                PyObject* o = PySequence_GetItem(obj0,i);
                if ((SWIG_ConvertPtr(o,(void **) &x, 
                SWIGTYPE_p_ClassXml,0)) != -1) {
                    temp1[i] = *x;
                    Py_DECREF(o);
                }else {
                    Py_DECREF(o);
                    PyErr_SetString(PyExc_TypeError,
                    "vector<""ClassXml""> expected");
                    SWIG_fail;
                }
            }
        }else if (SWIG_ConvertPtr(obj0,(void **) &v1, 
        SWIGTYPE_p_std__vectorTClassXml_t,0) != -1) {
            arg1 = v1;
        }else {
            PyErr_SetString(PyExc_TypeError,"vector<" "ClassXml" "> expected");
            SWIG_fail;
        }
    }
    {
        try {
            result = (std::vector<ClassXml > *)new std::vector<ClassXml >((std::vector<ClassXml > const &)*arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__vectorTClassXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_ClassVector(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[3];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if ((argc >= 0) && (argc <= 1)) {
        int _v;
        if (argc <= 0) {
            return _wrap_new_ClassVector__SWIG_0(self,args);
        }
        {
            _v = (PyInt_Check(argv[0]) || PyLong_Check(argv[0])) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_ClassVector__SWIG_0(self,args);
        }
    }
    if (argc == 1) {
        int _v;
        {
            /* native sequence? */
            if (PyTuple_Check(argv[0]) || PyList_Check(argv[0])) {
                unsigned int size = (PyTuple_Check(argv[0]) ?
                PyTuple_Size(argv[0]) :
                PyList_Size(argv[0]));
                if (size == 0) {
                    /* an empty sequence can be of any type */
                    _v = 1;
                }else {
                    /* check the first element only */
                    ClassXml* x;
                    PyObject* o = PySequence_GetItem(argv[0],0);
                    if ((SWIG_ConvertPtr(o,(void **) &x, 
                    SWIGTYPE_p_ClassXml,0)) != -1)
                    _v = 1;
                    else
                    _v = 0;
                    Py_DECREF(o);
                }
            }else {
                /* wrapped vector? */
                std::vector<ClassXml >* v;
                if (SWIG_ConvertPtr(argv[0],(void **) &v, 
                SWIGTYPE_p_std__vectorTClassXml_t,0) != -1)
                _v = 1;
                else
                _v = 0;
            }
        }
        if (_v) {
            return _wrap_new_ClassVector__SWIG_2(self,args);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = (PyInt_Check(argv[0]) || PyLong_Check(argv[0])) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                if (SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_ClassXml, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                }else {
                    _v = 1;
                }
            }
            if (_v) {
                return _wrap_new_ClassVector__SWIG_1(self,args);
            }
        }
    }
    
    PyErr_SetString(PyExc_TypeError,"No matching function for overloaded 'new_ClassVector'");
    return NULL;
}


static PyObject *_wrap_ClassVector___len__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<ClassXml > *arg1 = (std::vector<ClassXml > *) 0 ;
    unsigned int result;
    std::vector<ClassXml > temp1 ;
    std::vector<ClassXml > *v1 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:ClassVector___len__",&obj0)) goto fail;
    {
        if (PyTuple_Check(obj0) || PyList_Check(obj0)) {
            unsigned int size = (PyTuple_Check(obj0) ?
            PyTuple_Size(obj0) :
            PyList_Size(obj0));
            temp1 = std::vector<ClassXml >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                ClassXml* x;
                PyObject* o = PySequence_GetItem(obj0,i);
                if ((SWIG_ConvertPtr(o,(void **) &x, 
                SWIGTYPE_p_ClassXml,0)) != -1) {
                    temp1[i] = *x;
                    Py_DECREF(o);
                }else {
                    Py_DECREF(o);
                    PyErr_SetString(PyExc_TypeError,
                    "vector<""ClassXml""> expected");
                    SWIG_fail;
                }
            }
        }else if (SWIG_ConvertPtr(obj0,(void **) &v1, 
        SWIGTYPE_p_std__vectorTClassXml_t,0) != -1) {
            arg1 = v1;
        }else {
            PyErr_SetString(PyExc_TypeError,"vector<" "ClassXml" "> expected");
            SWIG_fail;
        }
    }
    {
        try {
            result = (unsigned int)((std::vector<ClassXml > const *)arg1)->size();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ClassVector_clear(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<ClassXml > *arg1 = (std::vector<ClassXml > *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:ClassVector_clear",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTClassXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            (arg1)->clear();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ClassVector_append(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<ClassXml > *arg1 = (std::vector<ClassXml > *) 0 ;
    ClassXml *arg2 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:ClassVector_append",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTClassXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_ClassXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            (arg1)->push_back((ClassXml const &)*arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ClassVector___nonzero__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<ClassXml > *arg1 = (std::vector<ClassXml > *) 0 ;
    bool result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:ClassVector___nonzero__",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTClassXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (bool)std_vectorlClassXml_g___nonzero_____(arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ClassVector_pop(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<ClassXml > *arg1 = (std::vector<ClassXml > *) 0 ;
    SwigValueWrapper< ClassXml > result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:ClassVector_pop",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTClassXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = std_vectorlClassXml_g_pop___(arg1);
            
        }catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    {
        ClassXml * resultptr;
        resultptr = new ClassXml((ClassXml &) result);
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_ClassXml, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ClassVector___getitem__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<ClassXml > *arg1 = (std::vector<ClassXml > *) 0 ;
    int arg2 ;
    ClassXml *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:ClassVector___getitem__",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTClassXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            {
                ClassXml &_result_ref = std_vectorlClassXml_g___getitem_____(arg1,arg2);
                result = (ClassXml *) &_result_ref;
            }
            
        }catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ClassXml, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ClassVector___getslice__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<ClassXml > *arg1 = (std::vector<ClassXml > *) 0 ;
    int arg2 ;
    int arg3 ;
    std::vector<ClassXml > result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oii:ClassVector___getslice__",&obj0,&arg2,&arg3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTClassXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = std_vectorlClassXml_g___getslice_____(arg1,arg2,arg3);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    {
        resultobj = PyTuple_New((&result)->size());
        for (unsigned int i=0; i<(&result)->size(); i++) {
            ClassXml* ptr = new ClassXml(((std::vector<ClassXml > &)result)[i]);
            PyTuple_SetItem(resultobj,i,
            SWIG_NewPointerObj((void *) ptr, 
            SWIGTYPE_p_ClassXml, 1));
        }
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ClassVector___setitem__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<ClassXml > *arg1 = (std::vector<ClassXml > *) 0 ;
    int arg2 ;
    ClassXml *arg3 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OiO:ClassVector___setitem__",&obj0,&arg2,&obj2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTClassXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_ClassXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg3 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            std_vectorlClassXml_g___setitem_____(arg1,arg2,(ClassXml const &)*arg3);
            
        }catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ClassVector___setslice__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<ClassXml > *arg1 = (std::vector<ClassXml > *) 0 ;
    int arg2 ;
    int arg3 ;
    std::vector<ClassXml > *arg4 = 0 ;
    std::vector<ClassXml > temp4 ;
    std::vector<ClassXml > *v4 ;
    PyObject * obj0 = 0 ;
    PyObject * obj3 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OiiO:ClassVector___setslice__",&obj0,&arg2,&arg3,&obj3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTClassXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        if (PyTuple_Check(obj3) || PyList_Check(obj3)) {
            unsigned int size = (PyTuple_Check(obj3) ?
            PyTuple_Size(obj3) :
            PyList_Size(obj3));
            temp4 = std::vector<ClassXml >(size);
            arg4 = &temp4;
            for (unsigned int i=0; i<size; i++) {
                ClassXml* x;
                PyObject* o = PySequence_GetItem(obj3,i);
                if ((SWIG_ConvertPtr(o,(void **) &x, 
                SWIGTYPE_p_ClassXml,0)) != -1) {
                    temp4[i] = *x;
                    Py_DECREF(o);
                }else {
                    Py_DECREF(o);
                    PyErr_SetString(PyExc_TypeError,
                    "vector<""ClassXml""> expected");
                    SWIG_fail;
                }
            }
        }else if (SWIG_ConvertPtr(obj3,(void **) &v4, 
        SWIGTYPE_p_std__vectorTClassXml_t,0) != -1) {
            arg4 = v4;
        }else {
            PyErr_SetString(PyExc_TypeError,"vector<" "ClassXml" "> expected");
            SWIG_fail;
        }
    }
    {
        try {
            std_vectorlClassXml_g___setslice_____(arg1,arg2,arg3,(std::vector<ClassXml > const &)*arg4);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ClassVector___delitem__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<ClassXml > *arg1 = (std::vector<ClassXml > *) 0 ;
    int arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:ClassVector___delitem__",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTClassXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            std_vectorlClassXml_g___delitem_____(arg1,arg2);
            
        }catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ClassVector___delslice__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<ClassXml > *arg1 = (std::vector<ClassXml > *) 0 ;
    int arg2 ;
    int arg3 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oii:ClassVector___delslice__",&obj0,&arg2,&arg3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTClassXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            std_vectorlClassXml_g___delslice_____(arg1,arg2,arg3);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_ClassVector(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<ClassXml > *arg1 = (std::vector<ClassXml > *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_ClassVector",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTClassXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * ClassVector_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_std__vectorTClassXml_t, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_new_ClassArray(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<ClassXml > *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_ClassArray")) goto fail;
    {
        try {
            result = (ArrayXml<ClassXml > *)new ArrayXml<ClassXml >();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ArrayXmlTClassXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ClassArray_add(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<ClassXml > *arg1 = (ArrayXml<ClassXml > *) 0 ;
    ClassXml *arg2 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:ClassArray_add",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTClassXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_ClassXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            (arg1)->add((ClassXml const &)*arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ClassArray_toStringBuffer(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<ClassXml > *arg1 = (ArrayXml<ClassXml > *) 0 ;
    string *arg2 = 0 ;
    char *arg3 = (char *) " " ;
    char *arg4 = (char *) "" ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO|ss:ClassArray_toStringBuffer",&obj0,&obj1,&arg3,&arg4)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTClassXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_string,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            (arg1)->toStringBuffer(*arg2,arg3,arg4);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ClassArray___setitem__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<ClassXml > *arg1 = (ArrayXml<ClassXml > *) 0 ;
    int arg2 ;
    ClassXml *arg3 = (ClassXml *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OiO:ClassArray___setitem__",&obj0,&arg2,&obj2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTClassXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_ClassXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            ArrayXmllClassXml_g___setitem_____(arg1,arg2,arg3);
            
        }catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ClassArray___getitem__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<ClassXml > *arg1 = (ArrayXml<ClassXml > *) 0 ;
    int arg2 ;
    ClassXml *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:ClassArray___getitem__",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTClassXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (ClassXml *)ArrayXmllClassXml_g___getitem_____(arg1,arg2);
            
        }catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ClassXml, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ClassArray___str__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<ClassXml > *arg1 = (ArrayXml<ClassXml > *) 0 ;
    string result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:ClassArray___str__",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTClassXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = ArrayXmllClassXml_g___str_____(arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    {
        resultobj = PyString_FromString((&result)->c_str());
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ClassArray___iter__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<ClassXml > *arg1 = (ArrayXml<ClassXml > *) 0 ;
    ArrayIterator<ClassXml > result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:ClassArray___iter__",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTClassXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = ArrayXmllClassXml_g___iter_____(arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    {
        ArrayIterator<ClassXml > * resultptr;
        resultptr = new ArrayIterator<ClassXml >((ArrayIterator<ClassXml > &) result);
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_ArrayIteratorTClassXml_t, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_ClassArray(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<ClassXml > *arg1 = (ArrayXml<ClassXml > *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_ClassArray",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTClassXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * ClassArray_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_ArrayXmlTClassXml_t, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_ClassIterator_it_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<ClassXml > *arg1 = (ArrayIterator<ClassXml > *) 0 ;
    int arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:ClassIterator_it_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTClassXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->it = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ClassIterator_it_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<ClassXml > *arg1 = (ArrayIterator<ClassXml > *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:ClassIterator_it_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTClassXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (int) ((arg1)->it);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ClassIterator_c_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<ClassXml > *arg1 = (ArrayIterator<ClassXml > *) 0 ;
    ArrayXml<ClassXml > *arg2 = (ArrayXml<ClassXml > *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:ClassIterator_c_set",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTClassXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_ArrayXmlTClassXml_t,SWIG_POINTER_EXCEPTION | SWIG_POINTER_DISOWN )) == -1) SWIG_fail;
    if (arg1) (arg1)->c = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ClassIterator_c_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<ClassXml > *arg1 = (ArrayIterator<ClassXml > *) 0 ;
    ArrayXml<ClassXml > *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:ClassIterator_c_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTClassXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (ArrayXml<ClassXml > *) ((arg1)->c);
    
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ArrayXmlTClassXml_t, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_ClassIterator__SWIG_0(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<ClassXml > *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_ClassIterator")) goto fail;
    {
        try {
            result = (ArrayIterator<ClassXml > *)new ArrayIterator<ClassXml >();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ArrayIteratorTClassXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_ClassIterator__SWIG_1(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<ClassXml > *arg1 = 0 ;
    ArrayIterator<ClassXml > *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:new_ClassIterator",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTClassXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            result = (ArrayIterator<ClassXml > *)new ArrayIterator<ClassXml >((ArrayIterator<ClassXml > const &)*arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ArrayIteratorTClassXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_ClassIterator__SWIG_2(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    ArrayXml<ClassXml > *arg2 = (ArrayXml<ClassXml > *) 0 ;
    ArrayIterator<ClassXml > *result;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"iO:new_ClassIterator",&arg1,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_ArrayXmlTClassXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (ArrayIterator<ClassXml > *)new ArrayIterator<ClassXml >(arg1,arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ArrayIteratorTClassXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_ClassIterator(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[3];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 0) {
        return _wrap_new_ClassIterator__SWIG_0(self,args);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_ArrayIteratorTClassXml_t, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            }else {
                _v = 1;
            }
        }
        if (_v) {
            return _wrap_new_ClassIterator__SWIG_1(self,args);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = (PyInt_Check(argv[0]) || PyLong_Check(argv[0])) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                if (SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_ArrayXmlTClassXml_t, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                }else {
                    _v = 1;
                }
            }
            if (_v) {
                return _wrap_new_ClassIterator__SWIG_2(self,args);
            }
        }
    }
    
    PyErr_SetString(PyExc_TypeError,"No matching function for overloaded 'new_ClassIterator'");
    return NULL;
}


static PyObject *_wrap_ClassIterator___iter__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<ClassXml > *arg1 = (ArrayIterator<ClassXml > *) 0 ;
    ArrayIterator<ClassXml > result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:ClassIterator___iter__",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTClassXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (arg1)->__iter__();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    {
        ArrayIterator<ClassXml > * resultptr;
        resultptr = new ArrayIterator<ClassXml >((ArrayIterator<ClassXml > &) result);
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_ArrayIteratorTClassXml_t, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ClassIterator_next(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<ClassXml > *arg1 = (ArrayIterator<ClassXml > *) 0 ;
    ClassXml *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:ClassIterator_next",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTClassXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (ClassXml *)(arg1)->next();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ClassXml, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_ClassIterator(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<ClassXml > *arg1 = (ArrayIterator<ClassXml > *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_ClassIterator",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTClassXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * ClassIterator_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_ArrayIteratorTClassXml_t, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_new_ObjectWithPathVector__SWIG_0(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    unsigned int arg1 = (unsigned int) 0 ;
    std::vector<ObjectWithPathXml > *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"|O:new_ObjectWithPathVector",&obj0)) goto fail;
    if (obj0) {
        arg1 = (unsigned int) PyInt_AsLong(obj0);
        if (PyErr_Occurred()) SWIG_fail;
    }
    {
        try {
            result = (std::vector<ObjectWithPathXml > *)new std::vector<ObjectWithPathXml >(arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__vectorTObjectWithPathXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_ObjectWithPathVector__SWIG_1(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    unsigned int arg1 ;
    ObjectWithPathXml *arg2 = 0 ;
    std::vector<ObjectWithPathXml > *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:new_ObjectWithPathVector",&obj0,&obj1)) goto fail;
    arg1 = (unsigned int) PyInt_AsLong(obj0);
    if (PyErr_Occurred()) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_ObjectWithPathXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            result = (std::vector<ObjectWithPathXml > *)new std::vector<ObjectWithPathXml >(arg1,(ObjectWithPathXml const &)*arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__vectorTObjectWithPathXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_ObjectWithPathVector__SWIG_2(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<ObjectWithPathXml > *arg1 = 0 ;
    std::vector<ObjectWithPathXml > *result;
    std::vector<ObjectWithPathXml > temp1 ;
    std::vector<ObjectWithPathXml > *v1 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:new_ObjectWithPathVector",&obj0)) goto fail;
    {
        if (PyTuple_Check(obj0) || PyList_Check(obj0)) {
            unsigned int size = (PyTuple_Check(obj0) ?
            PyTuple_Size(obj0) :
            PyList_Size(obj0));
            temp1 = std::vector<ObjectWithPathXml >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                ObjectWithPathXml* x;
                PyObject* o = PySequence_GetItem(obj0,i);
                if ((SWIG_ConvertPtr(o,(void **) &x, 
                SWIGTYPE_p_ObjectWithPathXml,0)) != -1) {
                    temp1[i] = *x;
                    Py_DECREF(o);
                }else {
                    Py_DECREF(o);
                    PyErr_SetString(PyExc_TypeError,
                    "vector<""ObjectWithPathXml""> expected");
                    SWIG_fail;
                }
            }
        }else if (SWIG_ConvertPtr(obj0,(void **) &v1, 
        SWIGTYPE_p_std__vectorTObjectWithPathXml_t,0) != -1) {
            arg1 = v1;
        }else {
            PyErr_SetString(PyExc_TypeError,"vector<" "ObjectWithPathXml" "> expected");
            SWIG_fail;
        }
    }
    {
        try {
            result = (std::vector<ObjectWithPathXml > *)new std::vector<ObjectWithPathXml >((std::vector<ObjectWithPathXml > const &)*arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__vectorTObjectWithPathXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_ObjectWithPathVector(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[3];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if ((argc >= 0) && (argc <= 1)) {
        int _v;
        if (argc <= 0) {
            return _wrap_new_ObjectWithPathVector__SWIG_0(self,args);
        }
        {
            _v = (PyInt_Check(argv[0]) || PyLong_Check(argv[0])) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_ObjectWithPathVector__SWIG_0(self,args);
        }
    }
    if (argc == 1) {
        int _v;
        {
            /* native sequence? */
            if (PyTuple_Check(argv[0]) || PyList_Check(argv[0])) {
                unsigned int size = (PyTuple_Check(argv[0]) ?
                PyTuple_Size(argv[0]) :
                PyList_Size(argv[0]));
                if (size == 0) {
                    /* an empty sequence can be of any type */
                    _v = 1;
                }else {
                    /* check the first element only */
                    ObjectWithPathXml* x;
                    PyObject* o = PySequence_GetItem(argv[0],0);
                    if ((SWIG_ConvertPtr(o,(void **) &x, 
                    SWIGTYPE_p_ObjectWithPathXml,0)) != -1)
                    _v = 1;
                    else
                    _v = 0;
                    Py_DECREF(o);
                }
            }else {
                /* wrapped vector? */
                std::vector<ObjectWithPathXml >* v;
                if (SWIG_ConvertPtr(argv[0],(void **) &v, 
                SWIGTYPE_p_std__vectorTObjectWithPathXml_t,0) != -1)
                _v = 1;
                else
                _v = 0;
            }
        }
        if (_v) {
            return _wrap_new_ObjectWithPathVector__SWIG_2(self,args);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = (PyInt_Check(argv[0]) || PyLong_Check(argv[0])) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                if (SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_ObjectWithPathXml, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                }else {
                    _v = 1;
                }
            }
            if (_v) {
                return _wrap_new_ObjectWithPathVector__SWIG_1(self,args);
            }
        }
    }
    
    PyErr_SetString(PyExc_TypeError,"No matching function for overloaded 'new_ObjectWithPathVector'");
    return NULL;
}


static PyObject *_wrap_ObjectWithPathVector___len__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<ObjectWithPathXml > *arg1 = (std::vector<ObjectWithPathXml > *) 0 ;
    unsigned int result;
    std::vector<ObjectWithPathXml > temp1 ;
    std::vector<ObjectWithPathXml > *v1 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:ObjectWithPathVector___len__",&obj0)) goto fail;
    {
        if (PyTuple_Check(obj0) || PyList_Check(obj0)) {
            unsigned int size = (PyTuple_Check(obj0) ?
            PyTuple_Size(obj0) :
            PyList_Size(obj0));
            temp1 = std::vector<ObjectWithPathXml >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                ObjectWithPathXml* x;
                PyObject* o = PySequence_GetItem(obj0,i);
                if ((SWIG_ConvertPtr(o,(void **) &x, 
                SWIGTYPE_p_ObjectWithPathXml,0)) != -1) {
                    temp1[i] = *x;
                    Py_DECREF(o);
                }else {
                    Py_DECREF(o);
                    PyErr_SetString(PyExc_TypeError,
                    "vector<""ObjectWithPathXml""> expected");
                    SWIG_fail;
                }
            }
        }else if (SWIG_ConvertPtr(obj0,(void **) &v1, 
        SWIGTYPE_p_std__vectorTObjectWithPathXml_t,0) != -1) {
            arg1 = v1;
        }else {
            PyErr_SetString(PyExc_TypeError,"vector<" "ObjectWithPathXml" "> expected");
            SWIG_fail;
        }
    }
    {
        try {
            result = (unsigned int)((std::vector<ObjectWithPathXml > const *)arg1)->size();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ObjectWithPathVector_clear(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<ObjectWithPathXml > *arg1 = (std::vector<ObjectWithPathXml > *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:ObjectWithPathVector_clear",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTObjectWithPathXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            (arg1)->clear();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ObjectWithPathVector_append(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<ObjectWithPathXml > *arg1 = (std::vector<ObjectWithPathXml > *) 0 ;
    ObjectWithPathXml *arg2 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:ObjectWithPathVector_append",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTObjectWithPathXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_ObjectWithPathXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            (arg1)->push_back((ObjectWithPathXml const &)*arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ObjectWithPathVector___nonzero__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<ObjectWithPathXml > *arg1 = (std::vector<ObjectWithPathXml > *) 0 ;
    bool result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:ObjectWithPathVector___nonzero__",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTObjectWithPathXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (bool)std_vectorlObjectWithPathXml_g___nonzero_____(arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ObjectWithPathVector_pop(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<ObjectWithPathXml > *arg1 = (std::vector<ObjectWithPathXml > *) 0 ;
    SwigValueWrapper< ObjectWithPathXml > result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:ObjectWithPathVector_pop",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTObjectWithPathXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = std_vectorlObjectWithPathXml_g_pop___(arg1);
            
        }catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    {
        ObjectWithPathXml * resultptr;
        resultptr = new ObjectWithPathXml((ObjectWithPathXml &) result);
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_ObjectWithPathXml, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ObjectWithPathVector___getitem__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<ObjectWithPathXml > *arg1 = (std::vector<ObjectWithPathXml > *) 0 ;
    int arg2 ;
    ObjectWithPathXml *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:ObjectWithPathVector___getitem__",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTObjectWithPathXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            {
                ObjectWithPathXml &_result_ref = std_vectorlObjectWithPathXml_g___getitem_____(arg1,arg2);
                result = (ObjectWithPathXml *) &_result_ref;
            }
            
        }catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ObjectWithPathXml, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ObjectWithPathVector___getslice__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<ObjectWithPathXml > *arg1 = (std::vector<ObjectWithPathXml > *) 0 ;
    int arg2 ;
    int arg3 ;
    std::vector<ObjectWithPathXml > result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oii:ObjectWithPathVector___getslice__",&obj0,&arg2,&arg3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTObjectWithPathXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = std_vectorlObjectWithPathXml_g___getslice_____(arg1,arg2,arg3);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    {
        resultobj = PyTuple_New((&result)->size());
        for (unsigned int i=0; i<(&result)->size(); i++) {
            ObjectWithPathXml* ptr = new ObjectWithPathXml(((std::vector<ObjectWithPathXml > &)result)[i]);
            PyTuple_SetItem(resultobj,i,
            SWIG_NewPointerObj((void *) ptr, 
            SWIGTYPE_p_ObjectWithPathXml, 1));
        }
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ObjectWithPathVector___setitem__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<ObjectWithPathXml > *arg1 = (std::vector<ObjectWithPathXml > *) 0 ;
    int arg2 ;
    ObjectWithPathXml *arg3 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OiO:ObjectWithPathVector___setitem__",&obj0,&arg2,&obj2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTObjectWithPathXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_ObjectWithPathXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg3 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            std_vectorlObjectWithPathXml_g___setitem_____(arg1,arg2,(ObjectWithPathXml const &)*arg3);
            
        }catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ObjectWithPathVector___setslice__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<ObjectWithPathXml > *arg1 = (std::vector<ObjectWithPathXml > *) 0 ;
    int arg2 ;
    int arg3 ;
    std::vector<ObjectWithPathXml > *arg4 = 0 ;
    std::vector<ObjectWithPathXml > temp4 ;
    std::vector<ObjectWithPathXml > *v4 ;
    PyObject * obj0 = 0 ;
    PyObject * obj3 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OiiO:ObjectWithPathVector___setslice__",&obj0,&arg2,&arg3,&obj3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTObjectWithPathXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        if (PyTuple_Check(obj3) || PyList_Check(obj3)) {
            unsigned int size = (PyTuple_Check(obj3) ?
            PyTuple_Size(obj3) :
            PyList_Size(obj3));
            temp4 = std::vector<ObjectWithPathXml >(size);
            arg4 = &temp4;
            for (unsigned int i=0; i<size; i++) {
                ObjectWithPathXml* x;
                PyObject* o = PySequence_GetItem(obj3,i);
                if ((SWIG_ConvertPtr(o,(void **) &x, 
                SWIGTYPE_p_ObjectWithPathXml,0)) != -1) {
                    temp4[i] = *x;
                    Py_DECREF(o);
                }else {
                    Py_DECREF(o);
                    PyErr_SetString(PyExc_TypeError,
                    "vector<""ObjectWithPathXml""> expected");
                    SWIG_fail;
                }
            }
        }else if (SWIG_ConvertPtr(obj3,(void **) &v4, 
        SWIGTYPE_p_std__vectorTObjectWithPathXml_t,0) != -1) {
            arg4 = v4;
        }else {
            PyErr_SetString(PyExc_TypeError,"vector<" "ObjectWithPathXml" "> expected");
            SWIG_fail;
        }
    }
    {
        try {
            std_vectorlObjectWithPathXml_g___setslice_____(arg1,arg2,arg3,(std::vector<ObjectWithPathXml > const &)*arg4);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ObjectWithPathVector___delitem__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<ObjectWithPathXml > *arg1 = (std::vector<ObjectWithPathXml > *) 0 ;
    int arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:ObjectWithPathVector___delitem__",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTObjectWithPathXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            std_vectorlObjectWithPathXml_g___delitem_____(arg1,arg2);
            
        }catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ObjectWithPathVector___delslice__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<ObjectWithPathXml > *arg1 = (std::vector<ObjectWithPathXml > *) 0 ;
    int arg2 ;
    int arg3 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oii:ObjectWithPathVector___delslice__",&obj0,&arg2,&arg3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTObjectWithPathXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            std_vectorlObjectWithPathXml_g___delslice_____(arg1,arg2,arg3);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_ObjectWithPathVector(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<ObjectWithPathXml > *arg1 = (std::vector<ObjectWithPathXml > *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_ObjectWithPathVector",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTObjectWithPathXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * ObjectWithPathVector_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_std__vectorTObjectWithPathXml_t, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_new_ObjectWithPathArray(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<ObjectWithPathXml > *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_ObjectWithPathArray")) goto fail;
    {
        try {
            result = (ArrayXml<ObjectWithPathXml > *)new ArrayXml<ObjectWithPathXml >();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ArrayXmlTObjectWithPathXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ObjectWithPathArray_add(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<ObjectWithPathXml > *arg1 = (ArrayXml<ObjectWithPathXml > *) 0 ;
    ObjectWithPathXml *arg2 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:ObjectWithPathArray_add",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTObjectWithPathXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_ObjectWithPathXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            (arg1)->add((ObjectWithPathXml const &)*arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ObjectWithPathArray_toStringBuffer(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<ObjectWithPathXml > *arg1 = (ArrayXml<ObjectWithPathXml > *) 0 ;
    string *arg2 = 0 ;
    char *arg3 = (char *) " " ;
    char *arg4 = (char *) "" ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO|ss:ObjectWithPathArray_toStringBuffer",&obj0,&obj1,&arg3,&arg4)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTObjectWithPathXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_string,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            (arg1)->toStringBuffer(*arg2,arg3,arg4);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ObjectWithPathArray___setitem__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<ObjectWithPathXml > *arg1 = (ArrayXml<ObjectWithPathXml > *) 0 ;
    int arg2 ;
    ObjectWithPathXml *arg3 = (ObjectWithPathXml *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OiO:ObjectWithPathArray___setitem__",&obj0,&arg2,&obj2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTObjectWithPathXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_ObjectWithPathXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            ArrayXmllObjectWithPathXml_g___setitem_____(arg1,arg2,arg3);
            
        }catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ObjectWithPathArray___getitem__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<ObjectWithPathXml > *arg1 = (ArrayXml<ObjectWithPathXml > *) 0 ;
    int arg2 ;
    ObjectWithPathXml *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:ObjectWithPathArray___getitem__",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTObjectWithPathXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (ObjectWithPathXml *)ArrayXmllObjectWithPathXml_g___getitem_____(arg1,arg2);
            
        }catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ObjectWithPathXml, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ObjectWithPathArray___str__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<ObjectWithPathXml > *arg1 = (ArrayXml<ObjectWithPathXml > *) 0 ;
    string result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:ObjectWithPathArray___str__",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTObjectWithPathXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = ArrayXmllObjectWithPathXml_g___str_____(arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    {
        resultobj = PyString_FromString((&result)->c_str());
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ObjectWithPathArray___iter__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<ObjectWithPathXml > *arg1 = (ArrayXml<ObjectWithPathXml > *) 0 ;
    ArrayIterator<ObjectWithPathXml > result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:ObjectWithPathArray___iter__",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTObjectWithPathXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = ArrayXmllObjectWithPathXml_g___iter_____(arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    {
        ArrayIterator<ObjectWithPathXml > * resultptr;
        resultptr = new ArrayIterator<ObjectWithPathXml >((ArrayIterator<ObjectWithPathXml > &) result);
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_ArrayIteratorTObjectWithPathXml_t, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_ObjectWithPathArray(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<ObjectWithPathXml > *arg1 = (ArrayXml<ObjectWithPathXml > *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_ObjectWithPathArray",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTObjectWithPathXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * ObjectWithPathArray_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_ArrayXmlTObjectWithPathXml_t, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_ObjectWithPathIterator_it_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<ObjectWithPathXml > *arg1 = (ArrayIterator<ObjectWithPathXml > *) 0 ;
    int arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:ObjectWithPathIterator_it_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTObjectWithPathXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->it = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ObjectWithPathIterator_it_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<ObjectWithPathXml > *arg1 = (ArrayIterator<ObjectWithPathXml > *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:ObjectWithPathIterator_it_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTObjectWithPathXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (int) ((arg1)->it);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ObjectWithPathIterator_c_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<ObjectWithPathXml > *arg1 = (ArrayIterator<ObjectWithPathXml > *) 0 ;
    ArrayXml<ObjectWithPathXml > *arg2 = (ArrayXml<ObjectWithPathXml > *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:ObjectWithPathIterator_c_set",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTObjectWithPathXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_ArrayXmlTObjectWithPathXml_t,SWIG_POINTER_EXCEPTION | SWIG_POINTER_DISOWN )) == -1) SWIG_fail;
    if (arg1) (arg1)->c = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ObjectWithPathIterator_c_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<ObjectWithPathXml > *arg1 = (ArrayIterator<ObjectWithPathXml > *) 0 ;
    ArrayXml<ObjectWithPathXml > *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:ObjectWithPathIterator_c_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTObjectWithPathXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (ArrayXml<ObjectWithPathXml > *) ((arg1)->c);
    
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ArrayXmlTObjectWithPathXml_t, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_ObjectWithPathIterator__SWIG_0(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<ObjectWithPathXml > *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_ObjectWithPathIterator")) goto fail;
    {
        try {
            result = (ArrayIterator<ObjectWithPathXml > *)new ArrayIterator<ObjectWithPathXml >();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ArrayIteratorTObjectWithPathXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_ObjectWithPathIterator__SWIG_1(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<ObjectWithPathXml > *arg1 = 0 ;
    ArrayIterator<ObjectWithPathXml > *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:new_ObjectWithPathIterator",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTObjectWithPathXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            result = (ArrayIterator<ObjectWithPathXml > *)new ArrayIterator<ObjectWithPathXml >((ArrayIterator<ObjectWithPathXml > const &)*arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ArrayIteratorTObjectWithPathXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_ObjectWithPathIterator__SWIG_2(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    ArrayXml<ObjectWithPathXml > *arg2 = (ArrayXml<ObjectWithPathXml > *) 0 ;
    ArrayIterator<ObjectWithPathXml > *result;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"iO:new_ObjectWithPathIterator",&arg1,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_ArrayXmlTObjectWithPathXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (ArrayIterator<ObjectWithPathXml > *)new ArrayIterator<ObjectWithPathXml >(arg1,arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ArrayIteratorTObjectWithPathXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_ObjectWithPathIterator(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[3];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 0) {
        return _wrap_new_ObjectWithPathIterator__SWIG_0(self,args);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_ArrayIteratorTObjectWithPathXml_t, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            }else {
                _v = 1;
            }
        }
        if (_v) {
            return _wrap_new_ObjectWithPathIterator__SWIG_1(self,args);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = (PyInt_Check(argv[0]) || PyLong_Check(argv[0])) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                if (SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_ArrayXmlTObjectWithPathXml_t, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                }else {
                    _v = 1;
                }
            }
            if (_v) {
                return _wrap_new_ObjectWithPathIterator__SWIG_2(self,args);
            }
        }
    }
    
    PyErr_SetString(PyExc_TypeError,"No matching function for overloaded 'new_ObjectWithPathIterator'");
    return NULL;
}


static PyObject *_wrap_ObjectWithPathIterator___iter__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<ObjectWithPathXml > *arg1 = (ArrayIterator<ObjectWithPathXml > *) 0 ;
    ArrayIterator<ObjectWithPathXml > result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:ObjectWithPathIterator___iter__",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTObjectWithPathXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (arg1)->__iter__();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    {
        ArrayIterator<ObjectWithPathXml > * resultptr;
        resultptr = new ArrayIterator<ObjectWithPathXml >((ArrayIterator<ObjectWithPathXml > &) result);
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_ArrayIteratorTObjectWithPathXml_t, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ObjectWithPathIterator_next(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<ObjectWithPathXml > *arg1 = (ArrayIterator<ObjectWithPathXml > *) 0 ;
    ObjectWithPathXml *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:ObjectWithPathIterator_next",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTObjectWithPathXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (ObjectWithPathXml *)(arg1)->next();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ObjectWithPathXml, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_ObjectWithPathIterator(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<ObjectWithPathXml > *arg1 = (ArrayIterator<ObjectWithPathXml > *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_ObjectWithPathIterator",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTObjectWithPathXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * ObjectWithPathIterator_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_ArrayIteratorTObjectWithPathXml_t, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_new_NamedInstanceVector__SWIG_0(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    unsigned int arg1 = (unsigned int) 0 ;
    std::vector<NamedInstanceXml > *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"|O:new_NamedInstanceVector",&obj0)) goto fail;
    if (obj0) {
        arg1 = (unsigned int) PyInt_AsLong(obj0);
        if (PyErr_Occurred()) SWIG_fail;
    }
    {
        try {
            result = (std::vector<NamedInstanceXml > *)new std::vector<NamedInstanceXml >(arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__vectorTNamedInstanceXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_NamedInstanceVector__SWIG_1(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    unsigned int arg1 ;
    NamedInstanceXml *arg2 = 0 ;
    std::vector<NamedInstanceXml > *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:new_NamedInstanceVector",&obj0,&obj1)) goto fail;
    arg1 = (unsigned int) PyInt_AsLong(obj0);
    if (PyErr_Occurred()) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_NamedInstanceXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            result = (std::vector<NamedInstanceXml > *)new std::vector<NamedInstanceXml >(arg1,(NamedInstanceXml const &)*arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__vectorTNamedInstanceXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_NamedInstanceVector__SWIG_2(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<NamedInstanceXml > *arg1 = 0 ;
    std::vector<NamedInstanceXml > *result;
    std::vector<NamedInstanceXml > temp1 ;
    std::vector<NamedInstanceXml > *v1 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:new_NamedInstanceVector",&obj0)) goto fail;
    {
        if (PyTuple_Check(obj0) || PyList_Check(obj0)) {
            unsigned int size = (PyTuple_Check(obj0) ?
            PyTuple_Size(obj0) :
            PyList_Size(obj0));
            temp1 = std::vector<NamedInstanceXml >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                NamedInstanceXml* x;
                PyObject* o = PySequence_GetItem(obj0,i);
                if ((SWIG_ConvertPtr(o,(void **) &x, 
                SWIGTYPE_p_NamedInstanceXml,0)) != -1) {
                    temp1[i] = *x;
                    Py_DECREF(o);
                }else {
                    Py_DECREF(o);
                    PyErr_SetString(PyExc_TypeError,
                    "vector<""NamedInstanceXml""> expected");
                    SWIG_fail;
                }
            }
        }else if (SWIG_ConvertPtr(obj0,(void **) &v1, 
        SWIGTYPE_p_std__vectorTNamedInstanceXml_t,0) != -1) {
            arg1 = v1;
        }else {
            PyErr_SetString(PyExc_TypeError,"vector<" "NamedInstanceXml" "> expected");
            SWIG_fail;
        }
    }
    {
        try {
            result = (std::vector<NamedInstanceXml > *)new std::vector<NamedInstanceXml >((std::vector<NamedInstanceXml > const &)*arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__vectorTNamedInstanceXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_NamedInstanceVector(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[3];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if ((argc >= 0) && (argc <= 1)) {
        int _v;
        if (argc <= 0) {
            return _wrap_new_NamedInstanceVector__SWIG_0(self,args);
        }
        {
            _v = (PyInt_Check(argv[0]) || PyLong_Check(argv[0])) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_NamedInstanceVector__SWIG_0(self,args);
        }
    }
    if (argc == 1) {
        int _v;
        {
            /* native sequence? */
            if (PyTuple_Check(argv[0]) || PyList_Check(argv[0])) {
                unsigned int size = (PyTuple_Check(argv[0]) ?
                PyTuple_Size(argv[0]) :
                PyList_Size(argv[0]));
                if (size == 0) {
                    /* an empty sequence can be of any type */
                    _v = 1;
                }else {
                    /* check the first element only */
                    NamedInstanceXml* x;
                    PyObject* o = PySequence_GetItem(argv[0],0);
                    if ((SWIG_ConvertPtr(o,(void **) &x, 
                    SWIGTYPE_p_NamedInstanceXml,0)) != -1)
                    _v = 1;
                    else
                    _v = 0;
                    Py_DECREF(o);
                }
            }else {
                /* wrapped vector? */
                std::vector<NamedInstanceXml >* v;
                if (SWIG_ConvertPtr(argv[0],(void **) &v, 
                SWIGTYPE_p_std__vectorTNamedInstanceXml_t,0) != -1)
                _v = 1;
                else
                _v = 0;
            }
        }
        if (_v) {
            return _wrap_new_NamedInstanceVector__SWIG_2(self,args);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = (PyInt_Check(argv[0]) || PyLong_Check(argv[0])) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                if (SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_NamedInstanceXml, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                }else {
                    _v = 1;
                }
            }
            if (_v) {
                return _wrap_new_NamedInstanceVector__SWIG_1(self,args);
            }
        }
    }
    
    PyErr_SetString(PyExc_TypeError,"No matching function for overloaded 'new_NamedInstanceVector'");
    return NULL;
}


static PyObject *_wrap_NamedInstanceVector___len__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<NamedInstanceXml > *arg1 = (std::vector<NamedInstanceXml > *) 0 ;
    unsigned int result;
    std::vector<NamedInstanceXml > temp1 ;
    std::vector<NamedInstanceXml > *v1 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:NamedInstanceVector___len__",&obj0)) goto fail;
    {
        if (PyTuple_Check(obj0) || PyList_Check(obj0)) {
            unsigned int size = (PyTuple_Check(obj0) ?
            PyTuple_Size(obj0) :
            PyList_Size(obj0));
            temp1 = std::vector<NamedInstanceXml >(size);
            arg1 = &temp1;
            for (unsigned int i=0; i<size; i++) {
                NamedInstanceXml* x;
                PyObject* o = PySequence_GetItem(obj0,i);
                if ((SWIG_ConvertPtr(o,(void **) &x, 
                SWIGTYPE_p_NamedInstanceXml,0)) != -1) {
                    temp1[i] = *x;
                    Py_DECREF(o);
                }else {
                    Py_DECREF(o);
                    PyErr_SetString(PyExc_TypeError,
                    "vector<""NamedInstanceXml""> expected");
                    SWIG_fail;
                }
            }
        }else if (SWIG_ConvertPtr(obj0,(void **) &v1, 
        SWIGTYPE_p_std__vectorTNamedInstanceXml_t,0) != -1) {
            arg1 = v1;
        }else {
            PyErr_SetString(PyExc_TypeError,"vector<" "NamedInstanceXml" "> expected");
            SWIG_fail;
        }
    }
    {
        try {
            result = (unsigned int)((std::vector<NamedInstanceXml > const *)arg1)->size();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NamedInstanceVector_clear(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<NamedInstanceXml > *arg1 = (std::vector<NamedInstanceXml > *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:NamedInstanceVector_clear",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTNamedInstanceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            (arg1)->clear();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NamedInstanceVector_append(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<NamedInstanceXml > *arg1 = (std::vector<NamedInstanceXml > *) 0 ;
    NamedInstanceXml *arg2 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:NamedInstanceVector_append",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTNamedInstanceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_NamedInstanceXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            (arg1)->push_back((NamedInstanceXml const &)*arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NamedInstanceVector___nonzero__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<NamedInstanceXml > *arg1 = (std::vector<NamedInstanceXml > *) 0 ;
    bool result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:NamedInstanceVector___nonzero__",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTNamedInstanceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (bool)std_vectorlNamedInstanceXml_g___nonzero_____(arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NamedInstanceVector_pop(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<NamedInstanceXml > *arg1 = (std::vector<NamedInstanceXml > *) 0 ;
    SwigValueWrapper< NamedInstanceXml > result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:NamedInstanceVector_pop",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTNamedInstanceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = std_vectorlNamedInstanceXml_g_pop___(arg1);
            
        }catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    {
        NamedInstanceXml * resultptr;
        resultptr = new NamedInstanceXml((NamedInstanceXml &) result);
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_NamedInstanceXml, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NamedInstanceVector___getitem__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<NamedInstanceXml > *arg1 = (std::vector<NamedInstanceXml > *) 0 ;
    int arg2 ;
    NamedInstanceXml *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:NamedInstanceVector___getitem__",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTNamedInstanceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            {
                NamedInstanceXml &_result_ref = std_vectorlNamedInstanceXml_g___getitem_____(arg1,arg2);
                result = (NamedInstanceXml *) &_result_ref;
            }
            
        }catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_NamedInstanceXml, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NamedInstanceVector___getslice__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<NamedInstanceXml > *arg1 = (std::vector<NamedInstanceXml > *) 0 ;
    int arg2 ;
    int arg3 ;
    std::vector<NamedInstanceXml > result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oii:NamedInstanceVector___getslice__",&obj0,&arg2,&arg3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTNamedInstanceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = std_vectorlNamedInstanceXml_g___getslice_____(arg1,arg2,arg3);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    {
        resultobj = PyTuple_New((&result)->size());
        for (unsigned int i=0; i<(&result)->size(); i++) {
            NamedInstanceXml* ptr = new NamedInstanceXml(((std::vector<NamedInstanceXml > &)result)[i]);
            PyTuple_SetItem(resultobj,i,
            SWIG_NewPointerObj((void *) ptr, 
            SWIGTYPE_p_NamedInstanceXml, 1));
        }
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NamedInstanceVector___setitem__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<NamedInstanceXml > *arg1 = (std::vector<NamedInstanceXml > *) 0 ;
    int arg2 ;
    NamedInstanceXml *arg3 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OiO:NamedInstanceVector___setitem__",&obj0,&arg2,&obj2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTNamedInstanceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_NamedInstanceXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg3 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            std_vectorlNamedInstanceXml_g___setitem_____(arg1,arg2,(NamedInstanceXml const &)*arg3);
            
        }catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NamedInstanceVector___setslice__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<NamedInstanceXml > *arg1 = (std::vector<NamedInstanceXml > *) 0 ;
    int arg2 ;
    int arg3 ;
    std::vector<NamedInstanceXml > *arg4 = 0 ;
    std::vector<NamedInstanceXml > temp4 ;
    std::vector<NamedInstanceXml > *v4 ;
    PyObject * obj0 = 0 ;
    PyObject * obj3 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OiiO:NamedInstanceVector___setslice__",&obj0,&arg2,&arg3,&obj3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTNamedInstanceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        if (PyTuple_Check(obj3) || PyList_Check(obj3)) {
            unsigned int size = (PyTuple_Check(obj3) ?
            PyTuple_Size(obj3) :
            PyList_Size(obj3));
            temp4 = std::vector<NamedInstanceXml >(size);
            arg4 = &temp4;
            for (unsigned int i=0; i<size; i++) {
                NamedInstanceXml* x;
                PyObject* o = PySequence_GetItem(obj3,i);
                if ((SWIG_ConvertPtr(o,(void **) &x, 
                SWIGTYPE_p_NamedInstanceXml,0)) != -1) {
                    temp4[i] = *x;
                    Py_DECREF(o);
                }else {
                    Py_DECREF(o);
                    PyErr_SetString(PyExc_TypeError,
                    "vector<""NamedInstanceXml""> expected");
                    SWIG_fail;
                }
            }
        }else if (SWIG_ConvertPtr(obj3,(void **) &v4, 
        SWIGTYPE_p_std__vectorTNamedInstanceXml_t,0) != -1) {
            arg4 = v4;
        }else {
            PyErr_SetString(PyExc_TypeError,"vector<" "NamedInstanceXml" "> expected");
            SWIG_fail;
        }
    }
    {
        try {
            std_vectorlNamedInstanceXml_g___setslice_____(arg1,arg2,arg3,(std::vector<NamedInstanceXml > const &)*arg4);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NamedInstanceVector___delitem__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<NamedInstanceXml > *arg1 = (std::vector<NamedInstanceXml > *) 0 ;
    int arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:NamedInstanceVector___delitem__",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTNamedInstanceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            std_vectorlNamedInstanceXml_g___delitem_____(arg1,arg2);
            
        }catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NamedInstanceVector___delslice__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<NamedInstanceXml > *arg1 = (std::vector<NamedInstanceXml > *) 0 ;
    int arg2 ;
    int arg3 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oii:NamedInstanceVector___delslice__",&obj0,&arg2,&arg3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTNamedInstanceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            std_vectorlNamedInstanceXml_g___delslice_____(arg1,arg2,arg3);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_NamedInstanceVector(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    std::vector<NamedInstanceXml > *arg1 = (std::vector<NamedInstanceXml > *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_NamedInstanceVector",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_std__vectorTNamedInstanceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * NamedInstanceVector_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_std__vectorTNamedInstanceXml_t, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_new_NamedInstanceArray(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<NamedInstanceXml > *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_NamedInstanceArray")) goto fail;
    {
        try {
            result = (ArrayXml<NamedInstanceXml > *)new ArrayXml<NamedInstanceXml >();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ArrayXmlTNamedInstanceXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NamedInstanceArray_add(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<NamedInstanceXml > *arg1 = (ArrayXml<NamedInstanceXml > *) 0 ;
    NamedInstanceXml *arg2 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:NamedInstanceArray_add",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTNamedInstanceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_NamedInstanceXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            (arg1)->add((NamedInstanceXml const &)*arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NamedInstanceArray_toStringBuffer(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<NamedInstanceXml > *arg1 = (ArrayXml<NamedInstanceXml > *) 0 ;
    string *arg2 = 0 ;
    char *arg3 = (char *) " " ;
    char *arg4 = (char *) "" ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO|ss:NamedInstanceArray_toStringBuffer",&obj0,&obj1,&arg3,&arg4)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTNamedInstanceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_string,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            (arg1)->toStringBuffer(*arg2,arg3,arg4);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NamedInstanceArray___setitem__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<NamedInstanceXml > *arg1 = (ArrayXml<NamedInstanceXml > *) 0 ;
    int arg2 ;
    NamedInstanceXml *arg3 = (NamedInstanceXml *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OiO:NamedInstanceArray___setitem__",&obj0,&arg2,&obj2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTNamedInstanceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_NamedInstanceXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            ArrayXmllNamedInstanceXml_g___setitem_____(arg1,arg2,arg3);
            
        }catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NamedInstanceArray___getitem__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<NamedInstanceXml > *arg1 = (ArrayXml<NamedInstanceXml > *) 0 ;
    int arg2 ;
    NamedInstanceXml *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:NamedInstanceArray___getitem__",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTNamedInstanceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (NamedInstanceXml *)ArrayXmllNamedInstanceXml_g___getitem_____(arg1,arg2);
            
        }catch (std::out_of_range& e) {
            SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_NamedInstanceXml, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NamedInstanceArray___str__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<NamedInstanceXml > *arg1 = (ArrayXml<NamedInstanceXml > *) 0 ;
    string result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:NamedInstanceArray___str__",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTNamedInstanceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = ArrayXmllNamedInstanceXml_g___str_____(arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    {
        resultobj = PyString_FromString((&result)->c_str());
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NamedInstanceArray___iter__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<NamedInstanceXml > *arg1 = (ArrayXml<NamedInstanceXml > *) 0 ;
    ArrayIterator<NamedInstanceXml > result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:NamedInstanceArray___iter__",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTNamedInstanceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = ArrayXmllNamedInstanceXml_g___iter_____(arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    {
        ArrayIterator<NamedInstanceXml > * resultptr;
        resultptr = new ArrayIterator<NamedInstanceXml >((ArrayIterator<NamedInstanceXml > &) result);
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_ArrayIteratorTNamedInstanceXml_t, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_NamedInstanceArray(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayXml<NamedInstanceXml > *arg1 = (ArrayXml<NamedInstanceXml > *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_NamedInstanceArray",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayXmlTNamedInstanceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * NamedInstanceArray_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_ArrayXmlTNamedInstanceXml_t, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_NamedInstanceIterator_it_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<NamedInstanceXml > *arg1 = (ArrayIterator<NamedInstanceXml > *) 0 ;
    int arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:NamedInstanceIterator_it_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTNamedInstanceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->it = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NamedInstanceIterator_it_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<NamedInstanceXml > *arg1 = (ArrayIterator<NamedInstanceXml > *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:NamedInstanceIterator_it_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTNamedInstanceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (int) ((arg1)->it);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NamedInstanceIterator_c_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<NamedInstanceXml > *arg1 = (ArrayIterator<NamedInstanceXml > *) 0 ;
    ArrayXml<NamedInstanceXml > *arg2 = (ArrayXml<NamedInstanceXml > *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:NamedInstanceIterator_c_set",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTNamedInstanceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_ArrayXmlTNamedInstanceXml_t,SWIG_POINTER_EXCEPTION | SWIG_POINTER_DISOWN )) == -1) SWIG_fail;
    if (arg1) (arg1)->c = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NamedInstanceIterator_c_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<NamedInstanceXml > *arg1 = (ArrayIterator<NamedInstanceXml > *) 0 ;
    ArrayXml<NamedInstanceXml > *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:NamedInstanceIterator_c_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTNamedInstanceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (ArrayXml<NamedInstanceXml > *) ((arg1)->c);
    
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ArrayXmlTNamedInstanceXml_t, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_NamedInstanceIterator__SWIG_0(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<NamedInstanceXml > *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_NamedInstanceIterator")) goto fail;
    {
        try {
            result = (ArrayIterator<NamedInstanceXml > *)new ArrayIterator<NamedInstanceXml >();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ArrayIteratorTNamedInstanceXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_NamedInstanceIterator__SWIG_1(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<NamedInstanceXml > *arg1 = 0 ;
    ArrayIterator<NamedInstanceXml > *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:new_NamedInstanceIterator",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTNamedInstanceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            result = (ArrayIterator<NamedInstanceXml > *)new ArrayIterator<NamedInstanceXml >((ArrayIterator<NamedInstanceXml > const &)*arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ArrayIteratorTNamedInstanceXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_NamedInstanceIterator__SWIG_2(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    ArrayXml<NamedInstanceXml > *arg2 = (ArrayXml<NamedInstanceXml > *) 0 ;
    ArrayIterator<NamedInstanceXml > *result;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"iO:new_NamedInstanceIterator",&arg1,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_ArrayXmlTNamedInstanceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (ArrayIterator<NamedInstanceXml > *)new ArrayIterator<NamedInstanceXml >(arg1,arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ArrayIteratorTNamedInstanceXml_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_NamedInstanceIterator(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[3];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 0) {
        return _wrap_new_NamedInstanceIterator__SWIG_0(self,args);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_ArrayIteratorTNamedInstanceXml_t, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            }else {
                _v = 1;
            }
        }
        if (_v) {
            return _wrap_new_NamedInstanceIterator__SWIG_1(self,args);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = (PyInt_Check(argv[0]) || PyLong_Check(argv[0])) ? 1 : 0;
        }
        if (_v) {
            {
                void *ptr;
                if (SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_ArrayXmlTNamedInstanceXml_t, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                }else {
                    _v = 1;
                }
            }
            if (_v) {
                return _wrap_new_NamedInstanceIterator__SWIG_2(self,args);
            }
        }
    }
    
    PyErr_SetString(PyExc_TypeError,"No matching function for overloaded 'new_NamedInstanceIterator'");
    return NULL;
}


static PyObject *_wrap_NamedInstanceIterator___iter__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<NamedInstanceXml > *arg1 = (ArrayIterator<NamedInstanceXml > *) 0 ;
    ArrayIterator<NamedInstanceXml > result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:NamedInstanceIterator___iter__",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTNamedInstanceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (arg1)->__iter__();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    {
        ArrayIterator<NamedInstanceXml > * resultptr;
        resultptr = new ArrayIterator<NamedInstanceXml >((ArrayIterator<NamedInstanceXml > &) result);
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_ArrayIteratorTNamedInstanceXml_t, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NamedInstanceIterator_next(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<NamedInstanceXml > *arg1 = (ArrayIterator<NamedInstanceXml > *) 0 ;
    NamedInstanceXml *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:NamedInstanceIterator_next",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTNamedInstanceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (NamedInstanceXml *)(arg1)->next();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_NamedInstanceXml, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_NamedInstanceIterator(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ArrayIterator<NamedInstanceXml > *arg1 = (ArrayIterator<NamedInstanceXml > *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_NamedInstanceIterator",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ArrayIteratorTNamedInstanceXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * NamedInstanceIterator_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_ArrayIteratorTNamedInstanceXml_t, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_DoesNotExist_desc_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    DoesNotExist *arg1 = (DoesNotExist *) 0 ;
    string arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:DoesNotExist_desc_set",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_DoesNotExist,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        arg2 = PyString_AsString(resultobj);
        if (PyErr_Occurred()) return NULL;
    }
    if (arg1) (arg1)->desc = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_DoesNotExist_desc_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    DoesNotExist *arg1 = (DoesNotExist *) 0 ;
    string result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:DoesNotExist_desc_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_DoesNotExist,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result =  ((arg1)->desc);
    
    {
        resultobj = PyString_FromString((&result)->c_str());
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_DoesNotExist(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    string arg1 ;
    DoesNotExist *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:new_DoesNotExist",&obj0)) goto fail;
    {
        arg1 = PyString_AsString(resultobj);
        if (PyErr_Occurred()) return NULL;
    }
    {
        try {
            result = (DoesNotExist *)new DoesNotExist(arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_DoesNotExist, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_DoesNotExist(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    DoesNotExist *arg1 = (DoesNotExist *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_DoesNotExist",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_DoesNotExist,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * DoesNotExist_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_DoesNotExist, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_new_stringOption__SWIG_0(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Option<string > *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_stringOption")) goto fail;
    {
        try {
            result = (Option<string > *)new Option<string >();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_OptionTstring_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_stringOption__SWIG_1(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    string *arg1 = 0 ;
    Option<string > *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:new_stringOption",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_string,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            result = (Option<string > *)new Option<string >((string const &)*arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_OptionTstring_t, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_stringOption(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[2];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 1); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 0) {
        return _wrap_new_stringOption__SWIG_0(self,args);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_string, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            }else {
                _v = 1;
            }
        }
        if (_v) {
            return _wrap_new_stringOption__SWIG_1(self,args);
        }
    }
    
    PyErr_SetString(PyExc_TypeError,"No matching function for overloaded 'new_stringOption'");
    return NULL;
}


static PyObject *_wrap_stringOption_exists(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Option<string > *arg1 = (Option<string > *) 0 ;
    bool result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:stringOption_exists",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_OptionTstring_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (bool)(arg1)->exists();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_stringOption_val(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Option<string > *arg1 = (Option<string > *) 0 ;
    string *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:stringOption_val",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_OptionTstring_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            {
                string &_result_ref = (arg1)->val();
                result = (string *) &_result_ref;
            }
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_string, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_stringOption(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Option<string > *arg1 = (Option<string > *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_stringOption",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_OptionTstring_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * stringOption_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_OptionTstring_t, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_new_MethodXml(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    XmlBuffer *arg1 = 0 ;
    MethodXml *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:new_MethodXml",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_XmlBuffer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            result = (MethodXml *)new MethodXml(*arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_MethodXml, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_MethodXml(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    MethodXml *arg1 = (MethodXml *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_MethodXml",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_MethodXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * MethodXml_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_MethodXml, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_QualifierXml_str_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    QualifierXml *arg1 = (QualifierXml *) 0 ;
    string arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:QualifierXml_str_set",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_QualifierXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        arg2 = PyString_AsString(resultobj);
        if (PyErr_Occurred()) return NULL;
    }
    if (arg1) (arg1)->str = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_QualifierXml_str_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    QualifierXml *arg1 = (QualifierXml *) 0 ;
    string result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:QualifierXml_str_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_QualifierXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result =  ((arg1)->str);
    
    {
        resultobj = PyString_FromString((&result)->c_str());
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_QualifierXml_key_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    QualifierXml *arg1 = (QualifierXml *) 0 ;
    int arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:QualifierXml_key_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_QualifierXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->key = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_QualifierXml_key_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    QualifierXml *arg1 = (QualifierXml *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:QualifierXml_key_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_QualifierXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (int) ((arg1)->key);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_QualifierXml(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    XmlBuffer *arg1 = 0 ;
    QualifierXml *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:new_QualifierXml",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_XmlBuffer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            result = (QualifierXml *)new QualifierXml(*arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_QualifierXml, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_QualifierXml(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    QualifierXml *arg1 = (QualifierXml *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_QualifierXml",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_QualifierXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * QualifierXml_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_QualifierXml, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_AValue_attr_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    AValue *arg1 = (AValue *) 0 ;
    string arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:AValue_attr_set",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_AValue,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        arg2 = PyString_AsString(resultobj);
        if (PyErr_Occurred()) return NULL;
    }
    if (arg1) (arg1)->attr = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_AValue_attr_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    AValue *arg1 = (AValue *) 0 ;
    string result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:AValue_attr_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_AValue,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result =  ((arg1)->attr);
    
    {
        resultobj = PyString_FromString((&result)->c_str());
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_AValue_val_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    AValue *arg1 = (AValue *) 0 ;
    string arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:AValue_val_set",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_AValue,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        arg2 = PyString_AsString(resultobj);
        if (PyErr_Occurred()) return NULL;
    }
    if (arg1) (arg1)->val = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_AValue_val_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    AValue *arg1 = (AValue *) 0 ;
    string result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:AValue_val_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_AValue,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result =  ((arg1)->val);
    
    {
        resultobj = PyString_FromString((&result)->c_str());
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_AValue_vals_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    AValue *arg1 = (AValue *) 0 ;
    StringArray *arg2 = (StringArray *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:AValue_vals_set",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_AValue,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_StringArray,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->vals = *arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_AValue_vals_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    AValue *arg1 = (AValue *) 0 ;
    StringArray *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:AValue_vals_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_AValue,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (StringArray *)& ((arg1)->vals);
    
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_StringArray, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_AValue(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg1 ;
    char *arg2 ;
    AValue *result;
    
    if(!PyArg_ParseTuple(args,(char *)"ss:new_AValue",&arg1,&arg2)) goto fail;
    {
        try {
            result = (AValue *)new AValue((char const *)arg1,(char const *)arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AValue, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_AValue_add(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    AValue *arg1 = (AValue *) 0 ;
    char *arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Os:AValue_add",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_AValue,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            (arg1)->add((char const *)arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_AValue(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    AValue *arg1 = (AValue *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_AValue",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_AValue,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * AValue_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_AValue, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_new_AVPs(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg1 ;
    AVPs *result;
    
    if(!PyArg_ParseTuple(args,(char *)"s:new_AVPs",&arg1)) goto fail;
    {
        try {
            result = (AVPs *)new AVPs(arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AVPs, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_AVPs_makeAVPs(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg1 ;
    unsigned int arg2 ;
    AVPs *result;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"sO:AVPs_makeAVPs",&arg1,&obj1)) goto fail;
    arg2 = (unsigned int) PyInt_AsLong(obj1);
    if (PyErr_Occurred()) SWIG_fail;
    {
        try {
            result = (AVPs *)AVPs::makeAVPs(arg1,arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AVPs, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_AVPs_get__SWIG_0(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    AVPs *arg1 = (AVPs *) 0 ;
    unsigned int arg2 ;
    AValue *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:AVPs_get",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_AVPs,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    arg2 = (unsigned int) PyInt_AsLong(obj1);
    if (PyErr_Occurred()) SWIG_fail;
    {
        try {
            result = (AValue *)(arg1)->get(arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AValue, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_AVPs_get__SWIG_1(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    AVPs *arg1 = (AVPs *) 0 ;
    char *arg2 ;
    AValue *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Os:AVPs_get",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_AVPs,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (AValue *)(arg1)->get((char const *)arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AValue, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_AVPs_get(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[3];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_AVPs, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            }else {
                _v = 1;
            }
        }
        if (_v) {
            {
                _v = (PyInt_Check(argv[1]) || PyLong_Check(argv[1])) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AVPs_get__SWIG_0(self,args);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_AVPs, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            }else {
                _v = 1;
            }
        }
        if (_v) {
            {
                _v = PyString_Check(argv[1]) ? 1 : 0;
            }
            if (_v) {
                return _wrap_AVPs_get__SWIG_1(self,args);
            }
        }
    }
    
    PyErr_SetString(PyExc_TypeError,"No matching function for overloaded 'AVPs_get'");
    return NULL;
}


static PyObject *_wrap_AVPs_check(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    AVPs *arg1 = (AVPs *) 0 ;
    char *arg2 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Os:AVPs_check",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_AVPs,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (int)(arg1)->check((char const *)arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_AVPs_notGotten(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    AVPs *arg1 = (AVPs *) 0 ;
    Option<string > result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:AVPs_notGotten",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_AVPs,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (arg1)->notGotten();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    {
        Option<string > * resultptr;
        resultptr = new Option<string >((Option<string > &) result);
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_OptionTstring_t, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_AVPs(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    AVPs *arg1 = (AVPs *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_AVPs",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_AVPs,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * AVPs_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_AVPs, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_new_AList(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg1 ;
    AList *result;
    
    if(!PyArg_ParseTuple(args,(char *)"s:new_AList",&arg1)) goto fail;
    {
        try {
            result = (AList *)new AList(arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_AList, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_AList(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    AList *arg1 = (AList *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_AList",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_AList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_AList_attrv_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    AList *arg1 = (AList *) 0 ;
    char **arg2 = (char **) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:AList_attrv_set",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_AList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_p_char,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->attrv = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_AList_attrv_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    AList *arg1 = (AList *) 0 ;
    char **result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:AList_attrv_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_AList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (char **) ((arg1)->attrv);
    
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_p_char, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_AList_attrl_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    AList *arg1 = (AList *) 0 ;
    char *arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Os:AList_attrl_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_AList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        if (arg1->attrl) delete [] arg1->attrl;
        if (arg2) {
            arg1->attrl = (char *) (new char[strlen(arg2)+1]);
            strcpy((char *) arg1->attrl,arg2);
        }else {
            arg1->attrl = 0;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_AList_attrl_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    AList *arg1 = (AList *) 0 ;
    char *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:AList_attrl_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_AList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (char *) ((arg1)->attrl);
    
    resultobj = result ? PyString_FromString(result) : Py_BuildValue((char*)"");
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_AList_attrs_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    AList *arg1 = (AList *) 0 ;
    int arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:AList_attrs_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_AList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->attrs = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_AList_attrs_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    AList *arg1 = (AList *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:AList_attrs_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_AList,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (int) ((arg1)->attrs);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject * AList_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_AList, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_XmlException_getMsg(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    XmlException *arg1 = (XmlException *) 0 ;
    string result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:XmlException_getMsg",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_XmlException,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (arg1)->getMsg();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    {
        resultobj = PyString_FromString((&result)->c_str());
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_XmlException(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    XmlException *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_XmlException")) goto fail;
    {
        try {
            result = (XmlException *)new XmlException();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_XmlException, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_XmlException(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    XmlException *arg1 = (XmlException *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_XmlException",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_XmlException,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * XmlException_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_XmlException, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_new_URLException(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    string *arg1 = 0 ;
    URLException *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:new_URLException",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_string,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            result = (URLException *)new URLException((string const &)*arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_URLException, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_URLException(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    URLException *arg1 = (URLException *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_URLException",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_URLException,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * URLException_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_URLException, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_new_ParseException(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    string *arg1 = 0 ;
    ParseException *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:new_ParseException",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_string,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            result = (ParseException *)new ParseException((string const &)*arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ParseException, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_ParseException(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ParseException *arg1 = (ParseException *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_ParseException",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ParseException,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * ParseException_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_ParseException, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_new_HttpException(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    string *arg1 = 0 ;
    HttpException *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:new_HttpException",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_string,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            result = (HttpException *)new HttpException((string const &)*arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_HttpException, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_HttpException(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    HttpException *arg1 = (HttpException *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_HttpException",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_HttpException,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * HttpException_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_HttpException, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_new_CmdException(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    string *arg1 = 0 ;
    CmdException *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:new_CmdException",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_string,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            result = (CmdException *)new CmdException((string const &)*arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_CmdException, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_CmdException(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    CmdException *arg1 = (CmdException *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_CmdException",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_CmdException,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * CmdException_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_CmdException, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_ErrorXml_desc_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ErrorXml *arg1 = (ErrorXml *) 0 ;
    string arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:ErrorXml_desc_set",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ErrorXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        arg2 = PyString_AsString(resultobj);
        if (PyErr_Occurred()) return NULL;
    }
    if (arg1) (arg1)->desc = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ErrorXml_desc_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ErrorXml *arg1 = (ErrorXml *) 0 ;
    string result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:ErrorXml_desc_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ErrorXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result =  ((arg1)->desc);
    
    {
        resultobj = PyString_FromString((&result)->c_str());
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ErrorXml_code_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ErrorXml *arg1 = (ErrorXml *) 0 ;
    string arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:ErrorXml_code_set",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ErrorXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        arg2 = PyString_AsString(resultobj);
        if (PyErr_Occurred()) return NULL;
    }
    if (arg1) (arg1)->code = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ErrorXml_code_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ErrorXml *arg1 = (ErrorXml *) 0 ;
    string result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:ErrorXml_code_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ErrorXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result =  ((arg1)->code);
    
    {
        resultobj = PyString_FromString((&result)->c_str());
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_ErrorXml(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    XmlBuffer *arg1 = 0 ;
    ErrorXml *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:new_ErrorXml",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_XmlBuffer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            result = (ErrorXml *)new ErrorXml(*arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ErrorXml, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_ErrorXml(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ErrorXml *arg1 = (ErrorXml *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_ErrorXml",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ErrorXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * ErrorXml_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_ErrorXml, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_KeyValueXml_valType_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    KeyValueXml *arg1 = (KeyValueXml *) 0 ;
    string arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:KeyValueXml_valType_set",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_KeyValueXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        arg2 = PyString_AsString(resultobj);
        if (PyErr_Occurred()) return NULL;
    }
    if (arg1) (arg1)->valType = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_KeyValueXml_valType_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    KeyValueXml *arg1 = (KeyValueXml *) 0 ;
    string result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:KeyValueXml_valType_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_KeyValueXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result =  ((arg1)->valType);
    
    {
        resultobj = PyString_FromString((&result)->c_str());
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_KeyValueXml_val_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    KeyValueXml *arg1 = (KeyValueXml *) 0 ;
    string arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:KeyValueXml_val_set",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_KeyValueXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        arg2 = PyString_AsString(resultobj);
        if (PyErr_Occurred()) return NULL;
    }
    if (arg1) (arg1)->val = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_KeyValueXml_val_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    KeyValueXml *arg1 = (KeyValueXml *) 0 ;
    string result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:KeyValueXml_val_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_KeyValueXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result =  ((arg1)->val);
    
    {
        resultobj = PyString_FromString((&result)->c_str());
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_KeyValueXml__SWIG_0(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    XmlBuffer *arg1 = 0 ;
    KeyValueXml *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:new_KeyValueXml",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_XmlBuffer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            result = (KeyValueXml *)new KeyValueXml(*arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_KeyValueXml, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_KeyValueXml__SWIG_1(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg1 ;
    KeyValueXml *result;
    
    if(!PyArg_ParseTuple(args,(char *)"s:new_KeyValueXml",&arg1)) goto fail;
    {
        try {
            result = (KeyValueXml *)new KeyValueXml((char const *)arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_KeyValueXml, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_KeyValueXml(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[2];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 1); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_XmlBuffer, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            }else {
                _v = 1;
            }
        }
        if (_v) {
            return _wrap_new_KeyValueXml__SWIG_0(self,args);
        }
    }
    if (argc == 1) {
        int _v;
        {
            _v = PyString_Check(argv[0]) ? 1 : 0;
        }
        if (_v) {
            return _wrap_new_KeyValueXml__SWIG_1(self,args);
        }
    }
    
    PyErr_SetString(PyExc_TypeError,"No matching function for overloaded 'new_KeyValueXml'");
    return NULL;
}


static PyObject *_wrap_KeyValueXml_toStringBuffer(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    KeyValueXml *arg1 = (KeyValueXml *) 0 ;
    string *arg2 = 0 ;
    char *arg3 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOs:KeyValueXml_toStringBuffer",&obj0,&obj1,&arg3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_KeyValueXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_string,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            (arg1)->toStringBuffer(*arg2,arg3);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_KeyValueXml___str__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    KeyValueXml *arg1 = (KeyValueXml *) 0 ;
    string result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:KeyValueXml___str__",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_KeyValueXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = KeyValueXml___str__(arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    {
        resultobj = PyString_FromString((&result)->c_str());
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_KeyValueXml(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    KeyValueXml *arg1 = (KeyValueXml *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_KeyValueXml",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_KeyValueXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * KeyValueXml_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_KeyValueXml, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_NameSpaceXml_name_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NameSpaceXml *arg1 = (NameSpaceXml *) 0 ;
    string arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:NameSpaceXml_name_set",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_NameSpaceXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        arg2 = PyString_AsString(resultobj);
        if (PyErr_Occurred()) return NULL;
    }
    if (arg1) (arg1)->name = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NameSpaceXml_name_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NameSpaceXml *arg1 = (NameSpaceXml *) 0 ;
    string result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:NameSpaceXml_name_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_NameSpaceXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result =  ((arg1)->name);
    
    {
        resultobj = PyString_FromString((&result)->c_str());
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_NameSpaceXml(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    XmlBuffer *arg1 = 0 ;
    NameSpaceXml *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:new_NameSpaceXml",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_XmlBuffer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            result = (NameSpaceXml *)new NameSpaceXml(*arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_NameSpaceXml, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NameSpaceXml_toStringBuffer(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NameSpaceXml *arg1 = (NameSpaceXml *) 0 ;
    string *arg2 = 0 ;
    char *arg3 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOs:NameSpaceXml_toStringBuffer",&obj0,&obj1,&arg3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_NameSpaceXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_string,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            (arg1)->toStringBuffer(*arg2,arg3);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_NameSpaceXml(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NameSpaceXml *arg1 = (NameSpaceXml *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_NameSpaceXml",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_NameSpaceXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * NameSpaceXml_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_NameSpaceXml, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_HostXml_name_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    HostXml *arg1 = (HostXml *) 0 ;
    string arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:HostXml_name_set",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_HostXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        arg2 = PyString_AsString(resultobj);
        if (PyErr_Occurred()) return NULL;
    }
    if (arg1) (arg1)->name = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_HostXml_name_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    HostXml *arg1 = (HostXml *) 0 ;
    string result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:HostXml_name_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_HostXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result =  ((arg1)->name);
    
    {
        resultobj = PyString_FromString((&result)->c_str());
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_HostXml(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    XmlBuffer *arg1 = 0 ;
    HostXml *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:new_HostXml",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_XmlBuffer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            result = (HostXml *)new HostXml(*arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_HostXml, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_HostXml(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    HostXml *arg1 = (HostXml *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_HostXml",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_HostXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * HostXml_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_HostXml, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_new_LocalNameSpacePathXml(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    XmlBuffer *arg1 = 0 ;
    LocalNameSpacePathXml *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:new_LocalNameSpacePathXml",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_XmlBuffer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            result = (LocalNameSpacePathXml *)new LocalNameSpacePathXml(*arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_LocalNameSpacePathXml, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_LocalNameSpacePathXml(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    LocalNameSpacePathXml *arg1 = (LocalNameSpacePathXml *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_LocalNameSpacePathXml",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_LocalNameSpacePathXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * LocalNameSpacePathXml_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_LocalNameSpacePathXml, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_NameSpacePathXml_host_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NameSpacePathXml *arg1 = (NameSpacePathXml *) 0 ;
    HostXml *arg2 = (HostXml *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:NameSpacePathXml_host_set",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_NameSpacePathXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_HostXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->host = *arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NameSpacePathXml_host_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NameSpacePathXml *arg1 = (NameSpacePathXml *) 0 ;
    HostXml *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:NameSpacePathXml_host_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_NameSpacePathXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (HostXml *)& ((arg1)->host);
    
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_HostXml, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NameSpacePathXml_lns_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NameSpacePathXml *arg1 = (NameSpacePathXml *) 0 ;
    LocalNameSpacePathXml *arg2 = (LocalNameSpacePathXml *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:NameSpacePathXml_lns_set",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_NameSpacePathXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_LocalNameSpacePathXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->lns = *arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NameSpacePathXml_lns_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NameSpacePathXml *arg1 = (NameSpacePathXml *) 0 ;
    LocalNameSpacePathXml *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:NameSpacePathXml_lns_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_NameSpacePathXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (LocalNameSpacePathXml *)& ((arg1)->lns);
    
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_LocalNameSpacePathXml, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_NameSpacePathXml(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    XmlBuffer *arg1 = 0 ;
    NameSpacePathXml *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:new_NameSpacePathXml",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_XmlBuffer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            result = (NameSpacePathXml *)new NameSpacePathXml(*arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_NameSpacePathXml, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_NameSpacePathXml(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NameSpacePathXml *arg1 = (NameSpacePathXml *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_NameSpacePathXml",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_NameSpacePathXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * NameSpacePathXml_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_NameSpacePathXml, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_RetValXml_type_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    RetValXml *arg1 = (RetValXml *) 0 ;
    int arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:RetValXml_type_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_RetValXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->type = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_RetValXml_type_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    RetValXml *arg1 = (RetValXml *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:RetValXml_type_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_RetValXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (int) ((arg1)->type);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_RetValXml(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    RetValXml *arg1 = (RetValXml *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_RetValXml",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_RetValXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_RetValXml_clone(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    RetValXml *arg1 = (RetValXml *) 0 ;
    RetValXml *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:RetValXml_clone",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_RetValXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (RetValXml *)(arg1)->clone();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_RetValXml, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_RetValXml_getType(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    RetValXml *arg1 = (RetValXml *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:RetValXml_getType",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_RetValXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (int)(arg1)->getType();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_RetValXml_toStringBuffer(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    RetValXml *arg1 = (RetValXml *) 0 ;
    string *arg2 = 0 ;
    char *arg3 = (char *) "" ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO|s:RetValXml_toStringBuffer",&obj0,&obj1,&arg3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_RetValXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_string,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            (arg1)->toStringBuffer(*arg2,arg3);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_RetValXml___str__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    RetValXml *arg1 = (RetValXml *) 0 ;
    string result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:RetValXml___str__",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_RetValXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = RetValXml___str__(arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    {
        resultobj = PyString_FromString((&result)->c_str());
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_RetValXml___long__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    RetValXml *arg1 = (RetValXml *) 0 ;
    long long result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:RetValXml___long__",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_RetValXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (long long)RetValXml___long__(arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = PyLong_FromLongLong(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject * RetValXml_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_RetValXml, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_delete_ValueXml(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ValueXml *arg1 = (ValueXml *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_ValueXml",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ValueXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * ValueXml_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_ValueXml, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_KeyBindingXml_name_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    KeyBindingXml *arg1 = (KeyBindingXml *) 0 ;
    string arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:KeyBindingXml_name_set",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_KeyBindingXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        arg2 = PyString_AsString(resultobj);
        if (PyErr_Occurred()) return NULL;
    }
    if (arg1) (arg1)->name = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_KeyBindingXml_name_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    KeyBindingXml *arg1 = (KeyBindingXml *) 0 ;
    string result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:KeyBindingXml_name_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_KeyBindingXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result =  ((arg1)->name);
    
    {
        resultobj = PyString_FromString((&result)->c_str());
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_KeyBindingXml__SWIG_0(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    XmlBuffer *arg1 = 0 ;
    KeyBindingXml *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:new_KeyBindingXml",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_XmlBuffer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            result = (KeyBindingXml *)new KeyBindingXml(*arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_KeyBindingXml, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_KeyBindingXml__SWIG_1(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg1 ;
    char *arg2 ;
    KeyBindingXml *result;
    
    if(!PyArg_ParseTuple(args,(char *)"ss:new_KeyBindingXml",&arg1,&arg2)) goto fail;
    {
        try {
            result = (KeyBindingXml *)new KeyBindingXml(arg1,arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_KeyBindingXml, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_KeyBindingXml(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[3];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_XmlBuffer, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            }else {
                _v = 1;
            }
        }
        if (_v) {
            return _wrap_new_KeyBindingXml__SWIG_0(self,args);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = PyString_Check(argv[0]) ? 1 : 0;
        }
        if (_v) {
            {
                _v = PyString_Check(argv[1]) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_KeyBindingXml__SWIG_1(self,args);
            }
        }
    }
    
    PyErr_SetString(PyExc_TypeError,"No matching function for overloaded 'new_KeyBindingXml'");
    return NULL;
}


static PyObject *_wrap_KeyBindingXml_toStringBuffer(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    KeyBindingXml *arg1 = (KeyBindingXml *) 0 ;
    string *arg2 = 0 ;
    char *arg3 = (char *) "" ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO|s:KeyBindingXml_toStringBuffer",&obj0,&obj1,&arg3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_KeyBindingXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_string,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            (arg1)->toStringBuffer(*arg2,arg3);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_KeyBindingXml___str__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    KeyBindingXml *arg1 = (KeyBindingXml *) 0 ;
    string result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:KeyBindingXml___str__",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_KeyBindingXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = KeyBindingXml___str__(arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    {
        resultobj = PyString_FromString((&result)->c_str());
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_KeyBindingXml(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    KeyBindingXml *arg1 = (KeyBindingXml *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_KeyBindingXml",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_KeyBindingXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * KeyBindingXml_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_KeyBindingXml, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_InstanceNameXml_keys_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    InstanceNameXml *arg1 = (InstanceNameXml *) 0 ;
    KeyBindingArray *arg2 = (KeyBindingArray *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:InstanceNameXml_keys_set",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_InstanceNameXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_KeyBindingArray,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->keys = *arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_InstanceNameXml_keys_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    InstanceNameXml *arg1 = (InstanceNameXml *) 0 ;
    KeyBindingArray *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:InstanceNameXml_keys_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_InstanceNameXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (KeyBindingArray *)& ((arg1)->keys);
    
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_KeyBindingArray, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_InstanceNameXml_toStringBuffer(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    InstanceNameXml *arg1 = (InstanceNameXml *) 0 ;
    string *arg2 = 0 ;
    char *arg3 = (char *) "" ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO|s:InstanceNameXml_toStringBuffer",&obj0,&obj1,&arg3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_InstanceNameXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_string,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            (arg1)->toStringBuffer(*arg2,arg3);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_InstanceNameXml(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    InstanceNameXml *arg1 = (InstanceNameXml *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_InstanceNameXml",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_InstanceNameXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * InstanceNameXml_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_InstanceNameXml, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_delete_InstanceNamesXml(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    InstanceNamesXml *arg1 = (InstanceNamesXml *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_InstanceNamesXml",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_InstanceNamesXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * InstanceNamesXml_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_InstanceNamesXml, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_PropertyXml_name_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PropertyXml *arg1 = (PropertyXml *) 0 ;
    string arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:PropertyXml_name_set",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PropertyXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        arg2 = PyString_AsString(resultobj);
        if (PyErr_Occurred()) return NULL;
    }
    if (arg1) (arg1)->name = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PropertyXml_name_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PropertyXml *arg1 = (PropertyXml *) 0 ;
    string result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PropertyXml_name_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PropertyXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result =  ((arg1)->name);
    
    {
        resultobj = PyString_FromString((&result)->c_str());
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PropertyXml_type_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PropertyXml *arg1 = (PropertyXml *) 0 ;
    string arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:PropertyXml_type_set",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PropertyXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        arg2 = PyString_AsString(resultobj);
        if (PyErr_Occurred()) return NULL;
    }
    if (arg1) (arg1)->type = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PropertyXml_type_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PropertyXml *arg1 = (PropertyXml *) 0 ;
    string result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PropertyXml_type_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PropertyXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result =  ((arg1)->type);
    
    {
        resultobj = PyString_FromString((&result)->c_str());
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PropertyXml_origin_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PropertyXml *arg1 = (PropertyXml *) 0 ;
    string arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:PropertyXml_origin_set",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PropertyXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        arg2 = PyString_AsString(resultobj);
        if (PyErr_Occurred()) return NULL;
    }
    if (arg1) (arg1)->origin = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PropertyXml_origin_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PropertyXml *arg1 = (PropertyXml *) 0 ;
    string result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PropertyXml_origin_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PropertyXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result =  ((arg1)->origin);
    
    {
        resultobj = PyString_FromString((&result)->c_str());
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PropertyXml_propagated_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PropertyXml *arg1 = (PropertyXml *) 0 ;
    string arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:PropertyXml_propagated_set",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PropertyXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        arg2 = PyString_AsString(resultobj);
        if (PyErr_Occurred()) return NULL;
    }
    if (arg1) (arg1)->propagated = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PropertyXml_propagated_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PropertyXml *arg1 = (PropertyXml *) 0 ;
    string result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PropertyXml_propagated_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PropertyXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result =  ((arg1)->propagated);
    
    {
        resultobj = PyString_FromString((&result)->c_str());
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PropertyXml_refCls_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PropertyXml *arg1 = (PropertyXml *) 0 ;
    string arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:PropertyXml_refCls_set",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PropertyXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        arg2 = PyString_AsString(resultobj);
        if (PyErr_Occurred()) return NULL;
    }
    if (arg1) (arg1)->refCls = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PropertyXml_refCls_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PropertyXml *arg1 = (PropertyXml *) 0 ;
    string result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PropertyXml_refCls_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PropertyXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result =  ((arg1)->refCls);
    
    {
        resultobj = PyString_FromString((&result)->c_str());
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PropertyXml_arraySize_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PropertyXml *arg1 = (PropertyXml *) 0 ;
    string arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:PropertyXml_arraySize_set",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PropertyXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        arg2 = PyString_AsString(resultobj);
        if (PyErr_Occurred()) return NULL;
    }
    if (arg1) (arg1)->arraySize = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PropertyXml_arraySize_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PropertyXml *arg1 = (PropertyXml *) 0 ;
    string result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PropertyXml_arraySize_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PropertyXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result =  ((arg1)->arraySize);
    
    {
        resultobj = PyString_FromString((&result)->c_str());
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PropertyXml_pType_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PropertyXml *arg1 = (PropertyXml *) 0 ;
    int arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:PropertyXml_pType_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PropertyXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->pType = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PropertyXml_pType_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PropertyXml *arg1 = (PropertyXml *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PropertyXml_pType_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PropertyXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (int) ((arg1)->pType);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PropertyXml_str_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PropertyXml *arg1 = (PropertyXml *) 0 ;
    string arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:PropertyXml_str_set",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PropertyXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        arg2 = PyString_AsString(resultobj);
        if (PyErr_Occurred()) return NULL;
    }
    if (arg1) (arg1)->str = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PropertyXml_str_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PropertyXml *arg1 = (PropertyXml *) 0 ;
    string result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PropertyXml_str_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PropertyXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result =  ((arg1)->str);
    
    {
        resultobj = PyString_FromString((&result)->c_str());
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PropertyXml_qualifiers_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PropertyXml *arg1 = (PropertyXml *) 0 ;
    QualifierArray arg2 ;
    QualifierArray *argp2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:PropertyXml_qualifiers_set",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PropertyXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &argp2, SWIGTYPE_p_QualifierArray,SWIG_POINTER_EXCEPTION) == -1)) SWIG_fail;
    arg2 = *argp2; 
    if (arg1) (arg1)->qualifiers = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PropertyXml_qualifiers_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PropertyXml *arg1 = (PropertyXml *) 0 ;
    QualifierArray result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PropertyXml_qualifiers_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PropertyXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result =  ((arg1)->qualifiers);
    
    {
        QualifierArray * resultptr;
        resultptr = new QualifierArray((QualifierArray &) result);
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_QualifierArray, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PropertyXml_value_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PropertyXml *arg1 = (PropertyXml *) 0 ;
    Option<ValueXml > *arg2 = (Option<ValueXml > *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:PropertyXml_value_set",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PropertyXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_OptionTValueXml_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->value = *arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PropertyXml_value_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PropertyXml *arg1 = (PropertyXml *) 0 ;
    Option<ValueXml > *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PropertyXml_value_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PropertyXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (Option<ValueXml > *)& ((arg1)->value);
    
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_OptionTValueXml_t, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PropertyXml_key_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PropertyXml *arg1 = (PropertyXml *) 0 ;
    int arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:PropertyXml_key_set",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PropertyXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->key = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PropertyXml_key_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PropertyXml *arg1 = (PropertyXml *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PropertyXml_key_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PropertyXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (int) ((arg1)->key);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_PropertyXml__SWIG_0(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    XmlBuffer *arg1 = 0 ;
    PropertyXml *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:new_PropertyXml",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_XmlBuffer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            result = (PropertyXml *)new PropertyXml(*arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PropertyXml, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_PropertyXml__SWIG_1(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg1 ;
    int arg2 ;
    PropertyXml *result;
    
    if(!PyArg_ParseTuple(args,(char *)"si:new_PropertyXml",&arg1,&arg2)) goto fail;
    {
        try {
            result = (PropertyXml *)new PropertyXml(arg1,arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PropertyXml, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_PropertyXml(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[3];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_XmlBuffer, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            }else {
                _v = 1;
            }
        }
        if (_v) {
            return _wrap_new_PropertyXml__SWIG_0(self,args);
        }
    }
    if (argc == 2) {
        int _v;
        {
            _v = PyString_Check(argv[0]) ? 1 : 0;
        }
        if (_v) {
            {
                _v = (PyInt_Check(argv[1]) || PyLong_Check(argv[1])) ? 1 : 0;
            }
            if (_v) {
                return _wrap_new_PropertyXml__SWIG_1(self,args);
            }
        }
    }
    
    PyErr_SetString(PyExc_TypeError,"No matching function for overloaded 'new_PropertyXml'");
    return NULL;
}


static PyObject *_wrap_PropertyXml_addQualifier(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PropertyXml *arg1 = (PropertyXml *) 0 ;
    QualifierXml *arg2 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:PropertyXml_addQualifier",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PropertyXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_QualifierXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            (arg1)->addQualifier(*arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PropertyXml_toStringBuffer(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PropertyXml *arg1 = (PropertyXml *) 0 ;
    string *arg2 = 0 ;
    char *arg3 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOs:PropertyXml_toStringBuffer",&obj0,&obj1,&arg3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PropertyXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_string,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            (arg1)->toStringBuffer(*arg2,arg3);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PropertyXml_toXmlBuffer(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PropertyXml *arg1 = (PropertyXml *) 0 ;
    string *arg2 = 0 ;
    AValue *arg3 = (AValue *) 0 ;
    int arg4 = (int) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO|i:PropertyXml_toXmlBuffer",&obj0,&obj1,&obj2,&arg4)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PropertyXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_string,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_AValue,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            (arg1)->toXmlBuffer(*arg2,arg3,arg4);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_PropertyXml___str__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PropertyXml *arg1 = (PropertyXml *) 0 ;
    string result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:PropertyXml___str__",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PropertyXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = PropertyXml___str__(arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    {
        resultobj = PyString_FromString((&result)->c_str());
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_PropertyXml(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PropertyXml *arg1 = (PropertyXml *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_PropertyXml",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_PropertyXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * PropertyXml_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_PropertyXml, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_ClassXml_clsName_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ClassXml *arg1 = (ClassXml *) 0 ;
    string arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:ClassXml_clsName_set",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ClassXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        arg2 = PyString_AsString(resultobj);
        if (PyErr_Occurred()) return NULL;
    }
    if (arg1) (arg1)->clsName = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ClassXml_clsName_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ClassXml *arg1 = (ClassXml *) 0 ;
    string result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:ClassXml_clsName_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ClassXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result =  ((arg1)->clsName);
    
    {
        resultobj = PyString_FromString((&result)->c_str());
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ClassXml_superClass_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ClassXml *arg1 = (ClassXml *) 0 ;
    string arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:ClassXml_superClass_set",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ClassXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        arg2 = PyString_AsString(resultobj);
        if (PyErr_Occurred()) return NULL;
    }
    if (arg1) (arg1)->superClass = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ClassXml_superClass_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ClassXml *arg1 = (ClassXml *) 0 ;
    string result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:ClassXml_superClass_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ClassXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result =  ((arg1)->superClass);
    
    {
        resultobj = PyString_FromString((&result)->c_str());
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ClassXml_getProperties(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ClassXml *arg1 = (ClassXml *) 0 ;
    PropertyArray *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:ClassXml_getProperties",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ClassXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            {
                PropertyArray &_result_ref = (arg1)->getProperties();
                result = (PropertyArray *) &_result_ref;
            }
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PropertyArray, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ClassXml_getQualifiers(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ClassXml *arg1 = (ClassXml *) 0 ;
    QualifierArray *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:ClassXml_getQualifiers",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ClassXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            {
                QualifierArray &_result_ref = (arg1)->getQualifiers();
                result = (QualifierArray *) &_result_ref;
            }
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_QualifierArray, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ClassXml_getKeys(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ClassXml *arg1 = (ClassXml *) 0 ;
    PropertyArray *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:ClassXml_getKeys",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ClassXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            {
                PropertyArray &_result_ref = (arg1)->getKeys();
                result = (PropertyArray *) &_result_ref;
            }
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PropertyArray, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ClassXml_addQualifier(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ClassXml *arg1 = (ClassXml *) 0 ;
    QualifierXml *arg2 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:ClassXml_addQualifier",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ClassXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_QualifierXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            (arg1)->addQualifier(*arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ClassXml_addProperty(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ClassXml *arg1 = (ClassXml *) 0 ;
    PropertyXml *arg2 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:ClassXml_addProperty",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ClassXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_PropertyXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            (arg1)->addProperty(*arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ClassXml_addMethod(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ClassXml *arg1 = (ClassXml *) 0 ;
    MethodXml *arg2 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:ClassXml_addMethod",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ClassXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_MethodXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            (arg1)->addMethod(*arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ClassXml_toStringBuffer(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ClassXml *arg1 = (ClassXml *) 0 ;
    string *arg2 = 0 ;
    char *arg3 = (char *) "" ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO|s:ClassXml_toStringBuffer",&obj0,&obj1,&arg3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ClassXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_string,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            (arg1)->toStringBuffer(*arg2,arg3);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ClassXml_keysOk(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ClassXml *arg1 = (ClassXml *) 0 ;
    URL *arg2 = 0 ;
    int result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:ClassXml_keysOk",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ClassXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_URL,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            result = (int)(arg1)->keysOk(*arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_ClassXml(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ClassXml *arg1 = (ClassXml *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_ClassXml",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ClassXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * ClassXml_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_ClassXml, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_delete_ClassesXml(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ClassesXml *arg1 = (ClassesXml *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_ClassesXml",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ClassesXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * ClassesXml_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_ClassesXml, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_InstanceXml_propagateKeyFlags__SWIG_0(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    InstanceXml *arg1 = (InstanceXml *) 0 ;
    PropertyArray *arg2 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:InstanceXml_propagateKeyFlags",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_InstanceXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_PropertyArray,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            (arg1)->propagateKeyFlags(*arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_InstanceXml_propagateKeyFlags__SWIG_1(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    InstanceXml *arg1 = (InstanceXml *) 0 ;
    KeyBindingArray *arg2 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:InstanceXml_propagateKeyFlags",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_InstanceXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_KeyBindingArray,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            (arg1)->propagateKeyFlags(*arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_InstanceXml_propagateKeyFlags(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[3];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_InstanceXml, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            }else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_PropertyArray, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                }else {
                    _v = 1;
                }
            }
            if (_v) {
                return _wrap_InstanceXml_propagateKeyFlags__SWIG_0(self,args);
            }
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_InstanceXml, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            }else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_KeyBindingArray, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                }else {
                    _v = 1;
                }
            }
            if (_v) {
                return _wrap_InstanceXml_propagateKeyFlags__SWIG_1(self,args);
            }
        }
    }
    
    PyErr_SetString(PyExc_TypeError,"No matching function for overloaded 'InstanceXml_propagateKeyFlags'");
    return NULL;
}


static PyObject *_wrap_InstanceXml_getProperties(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    InstanceXml *arg1 = (InstanceXml *) 0 ;
    PropertyArray *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:InstanceXml_getProperties",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_InstanceXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            {
                PropertyArray &_result_ref = (arg1)->getProperties();
                result = (PropertyArray *) &_result_ref;
            }
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PropertyArray, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_InstanceXml_getQualifiers(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    InstanceXml *arg1 = (InstanceXml *) 0 ;
    QualifierArray *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:InstanceXml_getQualifiers",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_InstanceXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            {
                QualifierArray &_result_ref = (arg1)->getQualifiers();
                result = (QualifierArray *) &_result_ref;
            }
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_QualifierArray, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_InstanceXml_addQualifier(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    InstanceXml *arg1 = (InstanceXml *) 0 ;
    QualifierXml *arg2 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:InstanceXml_addQualifier",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_InstanceXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_QualifierXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            (arg1)->addQualifier(*arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_InstanceXml_addProperty(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    InstanceXml *arg1 = (InstanceXml *) 0 ;
    PropertyXml *arg2 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:InstanceXml_addProperty",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_InstanceXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_PropertyXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            (arg1)->addProperty(*arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_InstanceXml_toStringBuffer(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    InstanceXml *arg1 = (InstanceXml *) 0 ;
    string *arg2 = 0 ;
    char *arg3 = (char *) "" ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO|s:InstanceXml_toStringBuffer",&obj0,&obj1,&arg3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_InstanceXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_string,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            (arg1)->toStringBuffer(*arg2,arg3);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_InstanceXml(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    InstanceXml *arg1 = (InstanceXml *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_InstanceXml",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_InstanceXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * InstanceXml_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_InstanceXml, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_NamedInstanceXml_instname_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NamedInstanceXml *arg1 = (NamedInstanceXml *) 0 ;
    InstanceNameXml *arg2 = (InstanceNameXml *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:NamedInstanceXml_instname_set",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_NamedInstanceXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_InstanceNameXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->instname = *arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NamedInstanceXml_instname_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NamedInstanceXml *arg1 = (NamedInstanceXml *) 0 ;
    InstanceNameXml *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:NamedInstanceXml_instname_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_NamedInstanceXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (InstanceNameXml *)& ((arg1)->instname);
    
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_InstanceNameXml, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NamedInstanceXml_inst_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NamedInstanceXml *arg1 = (NamedInstanceXml *) 0 ;
    InstanceXml *arg2 = (InstanceXml *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:NamedInstanceXml_inst_set",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_NamedInstanceXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_InstanceXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->inst = *arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NamedInstanceXml_inst_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NamedInstanceXml *arg1 = (NamedInstanceXml *) 0 ;
    InstanceXml *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:NamedInstanceXml_inst_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_NamedInstanceXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (InstanceXml *)& ((arg1)->inst);
    
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_InstanceXml, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_NamedInstanceXml(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NamedInstanceXml *arg1 = (NamedInstanceXml *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_NamedInstanceXml",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_NamedInstanceXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * NamedInstanceXml_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_NamedInstanceXml, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_delete_InstancesXml(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    InstancesXml *arg1 = (InstancesXml *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_InstancesXml",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_InstancesXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * InstancesXml_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_InstancesXml, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_ObjectWithPathXml_ip_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ObjectWithPathXml *arg1 = (ObjectWithPathXml *) 0 ;
    InstancePathXml *arg2 = (InstancePathXml *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:ObjectWithPathXml_ip_set",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ObjectWithPathXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_InstancePathXml,SWIG_POINTER_EXCEPTION | SWIG_POINTER_DISOWN )) == -1) SWIG_fail;
    if (arg1) (arg1)->ip = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ObjectWithPathXml_ip_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ObjectWithPathXml *arg1 = (ObjectWithPathXml *) 0 ;
    InstancePathXml *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:ObjectWithPathXml_ip_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ObjectWithPathXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (InstancePathXml *) ((arg1)->ip);
    
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_InstancePathXml, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ObjectWithPathXml_inst_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ObjectWithPathXml *arg1 = (ObjectWithPathXml *) 0 ;
    InstanceXml *arg2 = (InstanceXml *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:ObjectWithPathXml_inst_set",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ObjectWithPathXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_InstanceXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->inst = *arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ObjectWithPathXml_inst_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ObjectWithPathXml *arg1 = (ObjectWithPathXml *) 0 ;
    InstanceXml *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:ObjectWithPathXml_inst_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ObjectWithPathXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (InstanceXml *)& ((arg1)->inst);
    
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_InstanceXml, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_ObjectWithPathXml(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ObjectWithPathXml *arg1 = (ObjectWithPathXml *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_ObjectWithPathXml",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ObjectWithPathXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * ObjectWithPathXml_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_ObjectWithPathXml, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_ObjectsWithPathXml_ia_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ObjectsWithPathXml *arg1 = (ObjectsWithPathXml *) 0 ;
    InstanceArray *arg2 = (InstanceArray *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:ObjectsWithPathXml_ia_set",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ObjectsWithPathXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_InstanceArray,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->ia = *arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ObjectsWithPathXml_ia_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ObjectsWithPathXml *arg1 = (ObjectsWithPathXml *) 0 ;
    InstanceArray *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:ObjectsWithPathXml_ia_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ObjectsWithPathXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (InstanceArray *)& ((arg1)->ia);
    
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_InstanceArray, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ObjectsWithPathXml_ipa_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ObjectsWithPathXml *arg1 = (ObjectsWithPathXml *) 0 ;
    InstancePathArray arg2 ;
    InstancePathArray *argp2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:ObjectsWithPathXml_ipa_set",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ObjectsWithPathXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &argp2, SWIGTYPE_p_InstancePathArray,SWIG_POINTER_EXCEPTION) == -1)) SWIG_fail;
    arg2 = *argp2; 
    if (arg1) (arg1)->ipa = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ObjectsWithPathXml_ipa_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ObjectsWithPathXml *arg1 = (ObjectsWithPathXml *) 0 ;
    InstancePathArray result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:ObjectsWithPathXml_ipa_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ObjectsWithPathXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result =  ((arg1)->ipa);
    
    {
        InstancePathArray * resultptr;
        resultptr = new InstancePathArray((InstancePathArray &) result);
        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_InstancePathArray, 1);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ObjectsWithPathXml_add(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ObjectsWithPathXml *arg1 = (ObjectsWithPathXml *) 0 ;
    ObjectWithPathXml *arg2 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:ObjectsWithPathXml_add",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ObjectsWithPathXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_ObjectWithPathXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            (arg1)->add(*arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ObjectsWithPathXml_getName(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ObjectsWithPathXml *arg1 = (ObjectsWithPathXml *) 0 ;
    int arg2 ;
    InstancePathXml *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:ObjectsWithPathXml_getName",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ObjectsWithPathXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            {
                InstancePathXml &_result_ref = (arg1)->getName(arg2);
                result = (InstancePathXml *) &_result_ref;
            }
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_InstancePathXml, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ObjectsWithPathXml_getInst(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ObjectsWithPathXml *arg1 = (ObjectsWithPathXml *) 0 ;
    int arg2 ;
    InstanceXml *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:ObjectsWithPathXml_getInst",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ObjectsWithPathXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            {
                InstanceXml &_result_ref = (arg1)->getInst(arg2);
                result = (InstanceXml *) &_result_ref;
            }
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_InstanceXml, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ObjectsWithPathXml_size(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ObjectsWithPathXml *arg1 = (ObjectsWithPathXml *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:ObjectsWithPathXml_size",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ObjectsWithPathXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (int)(arg1)->size();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_ObjectsWithPathXml(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ObjectsWithPathXml *arg1 = (ObjectsWithPathXml *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_ObjectsWithPathXml",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ObjectsWithPathXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * ObjectsWithPathXml_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_ObjectsWithPathXml, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_NamedInstancesXml_ia_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NamedInstancesXml *arg1 = (NamedInstancesXml *) 0 ;
    InstanceArray *arg2 = (InstanceArray *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:NamedInstancesXml_ia_set",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_NamedInstancesXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_InstanceArray,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->ia = *arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NamedInstancesXml_ia_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NamedInstancesXml *arg1 = (NamedInstancesXml *) 0 ;
    InstanceArray *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:NamedInstancesXml_ia_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_NamedInstancesXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (InstanceArray *)& ((arg1)->ia);
    
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_InstanceArray, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NamedInstancesXml_ina_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NamedInstancesXml *arg1 = (NamedInstancesXml *) 0 ;
    InstanceNameArray *arg2 = (InstanceNameArray *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:NamedInstancesXml_ina_set",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_NamedInstancesXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_InstanceNameArray,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->ina = *arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NamedInstancesXml_ina_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NamedInstancesXml *arg1 = (NamedInstancesXml *) 0 ;
    InstanceNameArray *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:NamedInstancesXml_ina_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_NamedInstancesXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (InstanceNameArray *)& ((arg1)->ina);
    
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_InstanceNameArray, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NamedInstancesXml_add(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NamedInstancesXml *arg1 = (NamedInstancesXml *) 0 ;
    NamedInstanceXml *arg2 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:NamedInstancesXml_add",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_NamedInstancesXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_NamedInstanceXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            (arg1)->add(*arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NamedInstancesXml_getName(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NamedInstancesXml *arg1 = (NamedInstancesXml *) 0 ;
    int arg2 ;
    InstanceNameXml *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:NamedInstancesXml_getName",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_NamedInstancesXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            {
                InstanceNameXml &_result_ref = (arg1)->getName(arg2);
                result = (InstanceNameXml *) &_result_ref;
            }
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_InstanceNameXml, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NamedInstancesXml_getInst(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NamedInstancesXml *arg1 = (NamedInstancesXml *) 0 ;
    int arg2 ;
    InstanceXml *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:NamedInstancesXml_getInst",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_NamedInstancesXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            {
                InstanceXml &_result_ref = (arg1)->getInst(arg2);
                result = (InstanceXml *) &_result_ref;
            }
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_InstanceXml, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_NamedInstancesXml___len__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NamedInstancesXml *arg1 = (NamedInstancesXml *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:NamedInstancesXml___len__",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_NamedInstancesXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (int)(arg1)->size();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_NamedInstancesXml(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    NamedInstancesXml *arg1 = (NamedInstancesXml *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_NamedInstancesXml",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_NamedInstancesXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * NamedInstancesXml_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_NamedInstancesXml, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_ClassNameXml_toStringBuffer(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ClassNameXml *arg1 = (ClassNameXml *) 0 ;
    string *arg2 = 0 ;
    char *arg3 = (char *) "" ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO|s:ClassNameXml_toStringBuffer",&obj0,&obj1,&arg3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ClassNameXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_string,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            (arg1)->toStringBuffer(*arg2,arg3);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_ClassNameXml(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ClassNameXml *arg1 = (ClassNameXml *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_ClassNameXml",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ClassNameXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * ClassNameXml_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_ClassNameXml, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_delete_ClassNamesXml(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ClassNamesXml *arg1 = (ClassNamesXml *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_ClassNamesXml",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ClassNamesXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * ClassNamesXml_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_ClassNamesXml, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_new_IReturnvalueXml(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    XmlBuffer *arg1 = 0 ;
    IReturnvalueXml *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:new_IReturnvalueXml",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_XmlBuffer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            result = (IReturnvalueXml *)new IReturnvalueXml(*arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_IReturnvalueXml, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_IReturnvalueXml_getReturnData(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    IReturnvalueXml *arg1 = (IReturnvalueXml *) 0 ;
    RetValXml *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:IReturnvalueXml_getReturnData",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_IReturnvalueXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (RetValXml *)(arg1)->getReturnData();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_RetValXml, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_IReturnvalueXml(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    IReturnvalueXml *arg1 = (IReturnvalueXml *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_IReturnvalueXml",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_IReturnvalueXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * IReturnvalueXml_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_IReturnvalueXml, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_new_IMethodresponseXml(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    XmlBuffer *arg1 = 0 ;
    int arg2 = (int) 0 ;
    IMethodresponseXml *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O|i:new_IMethodresponseXml",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_XmlBuffer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            result = (IMethodresponseXml *)new IMethodresponseXml(*arg1,arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_IMethodresponseXml, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_IMethodresponseXml_getReturnData(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    IMethodresponseXml *arg1 = (IMethodresponseXml *) 0 ;
    RetValXml *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:IMethodresponseXml_getReturnData",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_IMethodresponseXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (RetValXml *)(arg1)->getReturnData();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_RetValXml, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_IMethodresponseXml(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    IMethodresponseXml *arg1 = (IMethodresponseXml *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_IMethodresponseXml",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_IMethodresponseXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * IMethodresponseXml_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_IMethodresponseXml, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_new_SimplerspXml(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    XmlBuffer *arg1 = 0 ;
    int arg2 = (int) 0 ;
    SimplerspXml *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O|i:new_SimplerspXml",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_XmlBuffer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            result = (SimplerspXml *)new SimplerspXml(*arg1,arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_SimplerspXml, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_SimplerspXml_getReturnData(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    SimplerspXml *arg1 = (SimplerspXml *) 0 ;
    RetValXml *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:SimplerspXml_getReturnData",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_SimplerspXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (RetValXml *)(arg1)->getReturnData();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_RetValXml, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_SimplerspXml(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    SimplerspXml *arg1 = (SimplerspXml *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_SimplerspXml",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_SimplerspXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * SimplerspXml_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_SimplerspXml, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_new_MessageXml(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    XmlBuffer *arg1 = 0 ;
    int arg2 = (int) 0 ;
    MessageXml *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O|i:new_MessageXml",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_XmlBuffer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            result = (MessageXml *)new MessageXml(*arg1,arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_MessageXml, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_MessageXml_getResponse(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    MessageXml *arg1 = (MessageXml *) 0 ;
    SimplerspXml *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:MessageXml_getResponse",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_MessageXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (SimplerspXml *)(arg1)->getResponse();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_SimplerspXml, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_MessageXml(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    MessageXml *arg1 = (MessageXml *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_MessageXml",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_MessageXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * MessageXml_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_MessageXml, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_new_CimXml(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    string arg1 ;
    int arg2 = (int) 0 ;
    CimXml *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O|i:new_CimXml",&obj0,&arg2)) goto fail;
    {
        arg1 = PyString_AsString(resultobj);
        if (PyErr_Occurred()) return NULL;
    }
    {
        try {
            result = (CimXml *)new CimXml(arg1,arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_CimXml, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_CimXml_getResponse(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    CimXml *arg1 = (CimXml *) 0 ;
    SimplerspXml *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:CimXml_getResponse",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_CimXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (SimplerspXml *)(arg1)->getResponse();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_SimplerspXml, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_CimXml(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    CimXml *arg1 = (CimXml *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_CimXml",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_CimXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * CimXml_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_CimXml, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_URL_host_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    URL *arg1 = (URL *) 0 ;
    string arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:URL_host_set",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_URL,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        arg2 = PyString_AsString(resultobj);
        if (PyErr_Occurred()) return NULL;
    }
    if (arg1) (arg1)->host = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_URL_host_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    URL *arg1 = (URL *) 0 ;
    string result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:URL_host_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_URL,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result =  ((arg1)->host);
    
    {
        resultobj = PyString_FromString((&result)->c_str());
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_URL_port_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    URL *arg1 = (URL *) 0 ;
    string arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:URL_port_set",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_URL,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        arg2 = PyString_AsString(resultobj);
        if (PyErr_Occurred()) return NULL;
    }
    if (arg1) (arg1)->port = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_URL_port_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    URL *arg1 = (URL *) 0 ;
    string result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:URL_port_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_URL,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result =  ((arg1)->port);
    
    {
        resultobj = PyString_FromString((&result)->c_str());
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_URL_cName_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    URL *arg1 = (URL *) 0 ;
    string arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:URL_cName_set",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_URL,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        arg2 = PyString_AsString(resultobj);
        if (PyErr_Occurred()) return NULL;
    }
    if (arg1) (arg1)->cName = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_URL_cName_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    URL *arg1 = (URL *) 0 ;
    string result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:URL_cName_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_URL,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result =  ((arg1)->cName);
    
    {
        resultobj = PyString_FromString((&result)->c_str());
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_URL_user_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    URL *arg1 = (URL *) 0 ;
    string arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:URL_user_set",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_URL,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        arg2 = PyString_AsString(resultobj);
        if (PyErr_Occurred()) return NULL;
    }
    if (arg1) (arg1)->user = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_URL_user_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    URL *arg1 = (URL *) 0 ;
    string result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:URL_user_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_URL,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result =  ((arg1)->user);
    
    {
        resultobj = PyString_FromString((&result)->c_str());
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_URL_password_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    URL *arg1 = (URL *) 0 ;
    string arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:URL_password_set",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_URL,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        arg2 = PyString_AsString(resultobj);
        if (PyErr_Occurred()) return NULL;
    }
    if (arg1) (arg1)->password = arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_URL_password_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    URL *arg1 = (URL *) 0 ;
    string result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:URL_password_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_URL,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result =  ((arg1)->password);
    
    {
        resultobj = PyString_FromString((&result)->c_str());
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_URL_ns_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    URL *arg1 = (URL *) 0 ;
    StringArray *arg2 = (StringArray *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:URL_ns_set",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_URL,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_StringArray,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->ns = *arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_URL_ns_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    URL *arg1 = (URL *) 0 ;
    StringArray *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:URL_ns_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_URL,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (StringArray *)& ((arg1)->ns);
    
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_StringArray, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_URL_keys_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    URL *arg1 = (URL *) 0 ;
    PropertyArray *arg2 = (PropertyArray *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:URL_keys_set",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_URL,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_PropertyArray,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg1) (arg1)->keys = *arg2;
    
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_URL_keys_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    URL *arg1 = (URL *) 0 ;
    PropertyArray *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:URL_keys_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_URL,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (PropertyArray *)& ((arg1)->keys);
    
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_PropertyArray, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_URL(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg1 ;
    URL *result;
    
    if(!PyArg_ParseTuple(args,(char *)"s:new_URL",&arg1)) goto fail;
    {
        try {
            result = (URL *)new URL(arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_URL, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_URL_resolveIndirection(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    URL *arg1 = (URL *) 0 ;
    char *arg2 ;
    char *arg3 ;
    char *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oss:URL_resolveIndirection",&obj0,&arg2,&arg3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_URL,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (char *)(arg1)->resolveIndirection(arg2,arg3);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = result ? PyString_FromString(result) : Py_BuildValue((char*)"");
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_URL_refLookAhead(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    URL *arg1 = (URL *) 0 ;
    char *arg2 ;
    char **arg3 = (char **) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OsO:URL_refLookAhead",&obj0,&arg2,&obj2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_URL,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_p_char,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (int)(arg1)->refLookAhead(arg2,arg3);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_URL_toStringBuffer__SWIG_0(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    URL *arg1 = (URL *) 0 ;
    string *arg2 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:URL_toStringBuffer",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_URL,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_string,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            (arg1)->toStringBuffer(*arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_URL_toStringBuffer__SWIG_1(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    URL *arg1 = (URL *) 0 ;
    string *arg2 = 0 ;
    int arg3 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOi:URL_toStringBuffer",&obj0,&obj1,&arg3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_URL,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_string,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            (arg1)->toStringBuffer(*arg2,arg3);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_URL_toStringBuffer(PyObject *self, PyObject *args) {
    int argc;
    PyObject *argv[4];
    int ii;
    
    argc = PyObject_Length(args);
    for (ii = 0; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = PyTuple_GetItem(args,ii);
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_URL, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            }else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_string, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                }else {
                    _v = 1;
                }
            }
            if (_v) {
                return _wrap_URL_toStringBuffer__SWIG_0(self,args);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            if (SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_URL, 0) == -1) {
                _v = 0;
                PyErr_Clear();
            }else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_string, 0) == -1) {
                    _v = 0;
                    PyErr_Clear();
                }else {
                    _v = 1;
                }
            }
            if (_v) {
                {
                    _v = (PyInt_Check(argv[2]) || PyLong_Check(argv[2])) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_URL_toStringBuffer__SWIG_1(self,args);
                }
            }
        }
    }
    
    PyErr_SetString(PyExc_TypeError,"No matching function for overloaded 'URL_toStringBuffer'");
    return NULL;
}


static PyObject *_wrap_URL___str__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    URL *arg1 = (URL *) 0 ;
    string result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:URL___str__",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_URL,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = URL___str__(arg1);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    {
        resultobj = PyString_FromString((&result)->c_str());
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_URL(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    URL *arg1 = (URL *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_URL",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_URL,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * URL_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_URL, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_delete_Cimom(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Cimom *arg1 = (Cimom *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_Cimom",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Cimom,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Cimom_getClass(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Cimom *arg1 = (Cimom *) 0 ;
    URL *arg2 = 0 ;
    char *arg3 = (char *) NULL ;
    bool arg4 = (bool) true ;
    bool arg5 = (bool) true ;
    bool arg6 = (bool) false ;
    ClassXml *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj3 = 0 ;
    PyObject * obj4 = 0 ;
    PyObject * obj5 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO|sOOO:Cimom_getClass",&obj0,&obj1,&arg3,&obj3,&obj4,&obj5)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Cimom,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_URL,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    if (obj3) {
        arg4 = PyInt_AsLong(obj3) ? true : false;
        if (PyErr_Occurred()) SWIG_fail;
    }
    if (obj4) {
        arg5 = PyInt_AsLong(obj4) ? true : false;
        if (PyErr_Occurred()) SWIG_fail;
    }
    if (obj5) {
        arg6 = PyInt_AsLong(obj5) ? true : false;
        if (PyErr_Occurred()) SWIG_fail;
    }
    {
        try {
            result = (ClassXml *)(arg1)->getClass(*arg2,arg3,arg4,arg5,arg6);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ClassXml, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Cimom_getClass2str(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Cimom *arg1 = (Cimom *) 0 ;
    URL *arg2 = (URL *) 0 ;
    char *arg3 = (char *) NULL ;
    bool arg4 = (bool) true ;
    bool arg5 = (bool) true ;
    bool arg6 = (bool) false ;
    string result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj3 = 0 ;
    PyObject * obj4 = 0 ;
    PyObject * obj5 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO|sOOO:Cimom_getClass2str",&obj0,&obj1,&arg3,&obj3,&obj4,&obj5)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Cimom,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_URL,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (obj3) {
        arg4 = PyInt_AsLong(obj3) ? true : false;
        if (PyErr_Occurred()) SWIG_fail;
    }
    if (obj4) {
        arg5 = PyInt_AsLong(obj4) ? true : false;
        if (PyErr_Occurred()) SWIG_fail;
    }
    if (obj5) {
        arg6 = PyInt_AsLong(obj5) ? true : false;
        if (PyErr_Occurred()) SWIG_fail;
    }
    {
        try {
            result = (arg1)->getClass2str(arg2,arg3,arg4,arg5,arg6);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    {
        resultobj = PyString_FromString((&result)->c_str());
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Cimom_testInst(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Cimom *arg1 = (Cimom *) 0 ;
    URL *arg2 = 0 ;
    AValue *arg3 = (AValue *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:Cimom_testInst",&obj0,&obj1,&obj2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Cimom,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_URL,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_AValue,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (int)(arg1)->testInst(*arg2,arg3);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Cimom_getInstance(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Cimom *arg1 = (Cimom *) 0 ;
    URL *arg2 = 0 ;
    char *arg3 = (char *) NULL ;
    bool arg4 = (bool) true ;
    bool arg5 = (bool) true ;
    bool arg6 = (bool) false ;
    InstanceXml *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj3 = 0 ;
    PyObject * obj4 = 0 ;
    PyObject * obj5 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO|sOOO:Cimom_getInstance",&obj0,&obj1,&arg3,&obj3,&obj4,&obj5)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Cimom,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_URL,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    if (obj3) {
        arg4 = PyInt_AsLong(obj3) ? true : false;
        if (PyErr_Occurred()) SWIG_fail;
    }
    if (obj4) {
        arg5 = PyInt_AsLong(obj4) ? true : false;
        if (PyErr_Occurred()) SWIG_fail;
    }
    if (obj5) {
        arg6 = PyInt_AsLong(obj5) ? true : false;
        if (PyErr_Occurred()) SWIG_fail;
    }
    {
        try {
            result = (InstanceXml *)(arg1)->getInstance(*arg2,arg3,arg4,arg5,arg6);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_InstanceXml, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Cimom_enumInstances(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Cimom *arg1 = (Cimom *) 0 ;
    URL *arg2 = 0 ;
    char *arg3 = (char *) NULL ;
    bool arg4 = (bool) true ;
    bool arg5 = (bool) true ;
    bool arg6 = (bool) true ;
    bool arg7 = (bool) false ;
    NamedInstancesXml *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj3 = 0 ;
    PyObject * obj4 = 0 ;
    PyObject * obj5 = 0 ;
    PyObject * obj6 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO|sOOOO:Cimom_enumInstances",&obj0,&obj1,&arg3,&obj3,&obj4,&obj5,&obj6)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Cimom,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_URL,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    if (obj3) {
        arg4 = PyInt_AsLong(obj3) ? true : false;
        if (PyErr_Occurred()) SWIG_fail;
    }
    if (obj4) {
        arg5 = PyInt_AsLong(obj4) ? true : false;
        if (PyErr_Occurred()) SWIG_fail;
    }
    if (obj5) {
        arg6 = PyInt_AsLong(obj5) ? true : false;
        if (PyErr_Occurred()) SWIG_fail;
    }
    if (obj6) {
        arg7 = PyInt_AsLong(obj6) ? true : false;
        if (PyErr_Occurred()) SWIG_fail;
    }
    {
        try {
            result = (NamedInstancesXml *)(arg1)->enumInstances(*arg2,arg3,arg4,arg5,arg6,arg7);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_NamedInstancesXml, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Cimom_enumInstances2str(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Cimom *arg1 = (Cimom *) 0 ;
    URL *arg2 = (URL *) 0 ;
    char *arg3 = (char *) NULL ;
    bool arg4 = (bool) true ;
    bool arg5 = (bool) true ;
    bool arg6 = (bool) true ;
    bool arg7 = (bool) false ;
    string result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj3 = 0 ;
    PyObject * obj4 = 0 ;
    PyObject * obj5 = 0 ;
    PyObject * obj6 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO|sOOOO:Cimom_enumInstances2str",&obj0,&obj1,&arg3,&obj3,&obj4,&obj5,&obj6)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Cimom,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_URL,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (obj3) {
        arg4 = PyInt_AsLong(obj3) ? true : false;
        if (PyErr_Occurred()) SWIG_fail;
    }
    if (obj4) {
        arg5 = PyInt_AsLong(obj4) ? true : false;
        if (PyErr_Occurred()) SWIG_fail;
    }
    if (obj5) {
        arg6 = PyInt_AsLong(obj5) ? true : false;
        if (PyErr_Occurred()) SWIG_fail;
    }
    if (obj6) {
        arg7 = PyInt_AsLong(obj6) ? true : false;
        if (PyErr_Occurred()) SWIG_fail;
    }
    {
        try {
            result = (arg1)->enumInstances2str(arg2,arg3,arg4,arg5,arg6,arg7);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    {
        resultobj = PyString_FromString((&result)->c_str());
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Cimom_createInstance(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Cimom *arg1 = (Cimom *) 0 ;
    URL *arg2 = 0 ;
    ClassXml *arg3 = (ClassXml *) 0 ;
    char *arg4 ;
    InstanceNameXml *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOs:Cimom_createInstance",&obj0,&obj1,&obj2,&arg4)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Cimom,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_URL,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_ClassXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            result = (InstanceNameXml *)(arg1)->createInstance(*arg2,arg3,arg4);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_InstanceNameXml, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Cimom_enumInstanceNames(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Cimom *arg1 = (Cimom *) 0 ;
    URL *arg2 = 0 ;
    InstanceNamesXml *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:Cimom_enumInstanceNames",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Cimom,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_URL,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            result = (InstanceNamesXml *)(arg1)->enumInstanceNames(*arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_InstanceNamesXml, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Cimom_enumClasses(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Cimom *arg1 = (Cimom *) 0 ;
    URL *arg2 = 0 ;
    bool arg3 = (bool) true ;
    bool arg4 = (bool) true ;
    bool arg5 = (bool) true ;
    bool arg6 = (bool) false ;
    ClassesXml *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    PyObject * obj4 = 0 ;
    PyObject * obj5 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO|OOOO:Cimom_enumClasses",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Cimom,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_URL,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    if (obj2) {
        arg3 = PyInt_AsLong(obj2) ? true : false;
        if (PyErr_Occurred()) SWIG_fail;
    }
    if (obj3) {
        arg4 = PyInt_AsLong(obj3) ? true : false;
        if (PyErr_Occurred()) SWIG_fail;
    }
    if (obj4) {
        arg5 = PyInt_AsLong(obj4) ? true : false;
        if (PyErr_Occurred()) SWIG_fail;
    }
    if (obj5) {
        arg6 = PyInt_AsLong(obj5) ? true : false;
        if (PyErr_Occurred()) SWIG_fail;
    }
    {
        try {
            result = (ClassesXml *)(arg1)->enumClasses(*arg2,arg3,arg4,arg5,arg6);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ClassesXml, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Cimom_enumClassNames(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Cimom *arg1 = (Cimom *) 0 ;
    URL *arg2 = 0 ;
    bool arg3 = (bool) true ;
    ClassNamesXml *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO|O:Cimom_enumClassNames",&obj0,&obj1,&obj2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Cimom,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_URL,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    if (obj2) {
        arg3 = PyInt_AsLong(obj2) ? true : false;
        if (PyErr_Occurred()) SWIG_fail;
    }
    {
        try {
            result = (ClassNamesXml *)(arg1)->enumClassNames(*arg2,arg3);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ClassNamesXml, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Cimom_modifyInstance(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Cimom *arg1 = (Cimom *) 0 ;
    URL *arg2 = 0 ;
    InstanceXml *arg3 = (InstanceXml *) 0 ;
    char *arg4 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOs:Cimom_modifyInstance",&obj0,&obj1,&obj2,&arg4)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Cimom,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_URL,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_InstanceXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            (arg1)->modifyInstance(*arg2,arg3,arg4);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Cimom_associatorNames(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Cimom *arg1 = (Cimom *) 0 ;
    URL *arg2 = 0 ;
    char *arg3 ;
    char *arg4 ;
    char *arg5 ;
    char *arg6 ;
    InstanceNamesXml *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOssss:Cimom_associatorNames",&obj0,&obj1,&arg3,&arg4,&arg5,&arg6)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Cimom,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_URL,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            result = (InstanceNamesXml *)(arg1)->associatorNames(*arg2,arg3,arg4,arg5,arg6);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_InstanceNamesXml, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Cimom_associators(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Cimom *arg1 = (Cimom *) 0 ;
    URL *arg2 = 0 ;
    char *arg3 ;
    char *arg4 ;
    char *arg5 ;
    char *arg6 ;
    char *arg7 = (char *) NULL ;
    bool arg8 = (bool) true ;
    bool arg9 = (bool) true ;
    ObjectsWithPathXml *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj7 = 0 ;
    PyObject * obj8 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOssss|sOO:Cimom_associators",&obj0,&obj1,&arg3,&arg4,&arg5,&arg6,&arg7,&obj7,&obj8)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Cimom,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_URL,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    if (obj7) {
        arg8 = PyInt_AsLong(obj7) ? true : false;
        if (PyErr_Occurred()) SWIG_fail;
    }
    if (obj8) {
        arg9 = PyInt_AsLong(obj8) ? true : false;
        if (PyErr_Occurred()) SWIG_fail;
    }
    {
        try {
            result = (ObjectsWithPathXml *)(arg1)->associators(*arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ObjectsWithPathXml, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Cimom_associators2str(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Cimom *arg1 = (Cimom *) 0 ;
    URL *arg2 = (URL *) 0 ;
    char *arg3 ;
    char *arg4 ;
    char *arg5 ;
    char *arg6 ;
    char *arg7 = (char *) NULL ;
    bool arg8 = (bool) true ;
    bool arg9 = (bool) true ;
    string result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj7 = 0 ;
    PyObject * obj8 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOssss|sOO:Cimom_associators2str",&obj0,&obj1,&arg3,&arg4,&arg5,&arg6,&arg7,&obj7,&obj8)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Cimom,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_URL,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (obj7) {
        arg8 = PyInt_AsLong(obj7) ? true : false;
        if (PyErr_Occurred()) SWIG_fail;
    }
    if (obj8) {
        arg9 = PyInt_AsLong(obj8) ? true : false;
        if (PyErr_Occurred()) SWIG_fail;
    }
    {
        try {
            result = (arg1)->associators2str(arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    {
        resultobj = PyString_FromString((&result)->c_str());
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Cimom_referenceNames(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Cimom *arg1 = (Cimom *) 0 ;
    URL *arg2 = 0 ;
    char *arg3 ;
    char *arg4 ;
    InstanceNamesXml *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOss:Cimom_referenceNames",&obj0,&obj1,&arg3,&arg4)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Cimom,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_URL,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            result = (InstanceNamesXml *)(arg1)->referenceNames(*arg2,arg3,arg4);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_InstanceNamesXml, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Cimom_references(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Cimom *arg1 = (Cimom *) 0 ;
    URL *arg2 = 0 ;
    char *arg3 ;
    char *arg4 ;
    char *arg5 = (char *) NULL ;
    bool arg6 = (bool) true ;
    bool arg7 = (bool) true ;
    ObjectsWithPathXml *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj5 = 0 ;
    PyObject * obj6 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOss|sOO:Cimom_references",&obj0,&obj1,&arg3,&arg4,&arg5,&obj5,&obj6)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Cimom,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_URL,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    if (obj5) {
        arg6 = PyInt_AsLong(obj5) ? true : false;
        if (PyErr_Occurred()) SWIG_fail;
    }
    if (obj6) {
        arg7 = PyInt_AsLong(obj6) ? true : false;
        if (PyErr_Occurred()) SWIG_fail;
    }
    {
        try {
            result = (ObjectsWithPathXml *)(arg1)->references(*arg2,arg3,arg4,arg5,arg6,arg7);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ObjectsWithPathXml, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Cimom_references2str(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Cimom *arg1 = (Cimom *) 0 ;
    URL *arg2 = (URL *) 0 ;
    char *arg3 ;
    char *arg4 ;
    char *arg5 = (char *) NULL ;
    bool arg6 = (bool) true ;
    bool arg7 = (bool) true ;
    string result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj5 = 0 ;
    PyObject * obj6 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOss|sOO:Cimom_references2str",&obj0,&obj1,&arg3,&arg4,&arg5,&obj5,&obj6)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Cimom,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_URL,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (obj5) {
        arg6 = PyInt_AsLong(obj5) ? true : false;
        if (PyErr_Occurred()) SWIG_fail;
    }
    if (obj6) {
        arg7 = PyInt_AsLong(obj6) ? true : false;
        if (PyErr_Occurred()) SWIG_fail;
    }
    {
        try {
            result = (arg1)->references2str(arg2,arg3,arg4,arg5,arg6,arg7);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    {
        resultobj = PyString_FromString((&result)->c_str());
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Cimom_getProperty(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Cimom *arg1 = (Cimom *) 0 ;
    URL *arg2 = 0 ;
    char *arg3 ;
    ValueXml *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOs:Cimom_getProperty",&obj0,&obj1,&arg3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Cimom,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_URL,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            result = (ValueXml *)(arg1)->getProperty(*arg2,arg3);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ValueXml, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Cimom_setProperty(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Cimom *arg1 = (Cimom *) 0 ;
    URL *arg2 = 0 ;
    ClassXml *arg3 = (ClassXml *) 0 ;
    char *arg4 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOs:Cimom_setProperty",&obj0,&obj1,&obj2,&arg4)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Cimom,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_URL,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_ClassXml,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            (arg1)->setProperty(*arg2,arg3,arg4);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Cimom_deleteClass(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Cimom *arg1 = (Cimom *) 0 ;
    URL *arg2 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:Cimom_deleteClass",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Cimom,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_URL,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            (arg1)->deleteClass(*arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Cimom_deleteInstance(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Cimom *arg1 = (Cimom *) 0 ;
    URL *arg2 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:Cimom_deleteInstance",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Cimom,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_URL,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (arg2 == NULL) {
        PyErr_SetString(PyExc_TypeError,"null reference"); SWIG_fail; 
    }
    {
        try {
            (arg1)->deleteInstance(*arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Cimom_unescapeXml(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg1 ;
    int arg2 = (int) 0 ;
    string result;
    
    if(!PyArg_ParseTuple(args,(char *)"s|i:Cimom_unescapeXml",&arg1,&arg2)) goto fail;
    {
        try {
            result = Cimom::unescapeXml((char const *)arg1,arg2);
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    {
        resultobj = PyString_FromString((&result)->c_str());
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject * Cimom_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_Cimom, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_new_CimomGhttp(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    CimomGhttp *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_CimomGhttp")) goto fail;
    {
        try {
            result = (CimomGhttp *)new CimomGhttp();
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_CimomGhttp, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_CimomGhttp(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    CimomGhttp *arg1 = (CimomGhttp *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_CimomGhttp",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_CimomGhttp,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        try {
            delete arg1;
            
        }catch (XmlException e) {
            PyErr_SetString(PyExc_RuntimeError, e.getMsg().c_str());
            return NULL;
        }catch (std::range_error e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (std::out_of_range e) {
            PyErr_SetString(PyExc_StopIteration, "Array index out of bounds");
            return NULL;
        }catch (DoesNotExist e) {
            PyErr_SetString(PyExc_RuntimeError, e.desc.c_str());
            return NULL;
        }catch(...) {
            PyErr_SetString(PyExc_RuntimeError, "Indeterminate CIM Exception");
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * CimomGhttp_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_CimomGhttp, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyMethodDef SwigMethods[] = {
	 { (char *)"XmlBuffer_cur_set", _wrap_XmlBuffer_cur_set, METH_VARARGS },
	 { (char *)"XmlBuffer_cur_get", _wrap_XmlBuffer_cur_get, METH_VARARGS },
	 { (char *)"new_XmlBuffer", _wrap_new_XmlBuffer, METH_VARARGS },
	 { (char *)"XmlBuffer_skipWS", _wrap_XmlBuffer_skipWS, METH_VARARGS },
	 { (char *)"XmlBuffer_getChar", _wrap_XmlBuffer_getChar, METH_VARARGS },
	 { (char *)"XmlBuffer_getWord", _wrap_XmlBuffer_getWord, METH_VARARGS },
	 { (char *)"XmlBuffer_nextTag", _wrap_XmlBuffer_nextTag, METH_VARARGS },
	 { (char *)"XmlBuffer_nextEquals", _wrap_XmlBuffer_nextEquals, METH_VARARGS },
	 { (char *)"XmlBuffer_xmlHdr", _wrap_XmlBuffer_xmlHdr, METH_VARARGS },
	 { (char *)"XmlBuffer_tagEquals", _wrap_XmlBuffer_tagEquals, METH_VARARGS },
	 { (char *)"XmlBuffer_endTag", _wrap_XmlBuffer_endTag, METH_VARARGS },
	 { (char *)"XmlBuffer_attrsOk", _wrap_XmlBuffer_attrsOk, METH_VARARGS },
	 { (char *)"XmlBuffer_getValue", _wrap_XmlBuffer_getValue, METH_VARARGS },
	 { (char *)"XmlBuffer_getContent", _wrap_XmlBuffer_getContent, METH_VARARGS },
	 { (char *)"XmlBuffer_skipElement", _wrap_XmlBuffer_skipElement, METH_VARARGS },
	 { (char *)"XmlBuffer_testAttr", _wrap_XmlBuffer_testAttr, METH_VARARGS },
	 { (char *)"delete_XmlBuffer", _wrap_delete_XmlBuffer, METH_VARARGS },
	 { (char *)"XmlBuffer_swigregister", XmlBuffer_swigregister, METH_VARARGS },
	 { (char *)"new_NameSpaceVector", _wrap_new_NameSpaceVector, METH_VARARGS },
	 { (char *)"NameSpaceVector___len__", _wrap_NameSpaceVector___len__, METH_VARARGS },
	 { (char *)"NameSpaceVector_clear", _wrap_NameSpaceVector_clear, METH_VARARGS },
	 { (char *)"NameSpaceVector_append", _wrap_NameSpaceVector_append, METH_VARARGS },
	 { (char *)"NameSpaceVector___nonzero__", _wrap_NameSpaceVector___nonzero__, METH_VARARGS },
	 { (char *)"NameSpaceVector_pop", _wrap_NameSpaceVector_pop, METH_VARARGS },
	 { (char *)"NameSpaceVector___getitem__", _wrap_NameSpaceVector___getitem__, METH_VARARGS },
	 { (char *)"NameSpaceVector___getslice__", _wrap_NameSpaceVector___getslice__, METH_VARARGS },
	 { (char *)"NameSpaceVector___setitem__", _wrap_NameSpaceVector___setitem__, METH_VARARGS },
	 { (char *)"NameSpaceVector___setslice__", _wrap_NameSpaceVector___setslice__, METH_VARARGS },
	 { (char *)"NameSpaceVector___delitem__", _wrap_NameSpaceVector___delitem__, METH_VARARGS },
	 { (char *)"NameSpaceVector___delslice__", _wrap_NameSpaceVector___delslice__, METH_VARARGS },
	 { (char *)"delete_NameSpaceVector", _wrap_delete_NameSpaceVector, METH_VARARGS },
	 { (char *)"NameSpaceVector_swigregister", NameSpaceVector_swigregister, METH_VARARGS },
	 { (char *)"new_NameSpaceArray", _wrap_new_NameSpaceArray, METH_VARARGS },
	 { (char *)"NameSpaceArray_add", _wrap_NameSpaceArray_add, METH_VARARGS },
	 { (char *)"NameSpaceArray_toStringBuffer", _wrap_NameSpaceArray_toStringBuffer, METH_VARARGS },
	 { (char *)"NameSpaceArray___setitem__", _wrap_NameSpaceArray___setitem__, METH_VARARGS },
	 { (char *)"NameSpaceArray___getitem__", _wrap_NameSpaceArray___getitem__, METH_VARARGS },
	 { (char *)"NameSpaceArray___str__", _wrap_NameSpaceArray___str__, METH_VARARGS },
	 { (char *)"NameSpaceArray___iter__", _wrap_NameSpaceArray___iter__, METH_VARARGS },
	 { (char *)"delete_NameSpaceArray", _wrap_delete_NameSpaceArray, METH_VARARGS },
	 { (char *)"NameSpaceArray_swigregister", NameSpaceArray_swigregister, METH_VARARGS },
	 { (char *)"NameSpaceIterator_it_set", _wrap_NameSpaceIterator_it_set, METH_VARARGS },
	 { (char *)"NameSpaceIterator_it_get", _wrap_NameSpaceIterator_it_get, METH_VARARGS },
	 { (char *)"NameSpaceIterator_c_set", _wrap_NameSpaceIterator_c_set, METH_VARARGS },
	 { (char *)"NameSpaceIterator_c_get", _wrap_NameSpaceIterator_c_get, METH_VARARGS },
	 { (char *)"new_NameSpaceIterator", _wrap_new_NameSpaceIterator, METH_VARARGS },
	 { (char *)"NameSpaceIterator___iter__", _wrap_NameSpaceIterator___iter__, METH_VARARGS },
	 { (char *)"NameSpaceIterator_next", _wrap_NameSpaceIterator_next, METH_VARARGS },
	 { (char *)"delete_NameSpaceIterator", _wrap_delete_NameSpaceIterator, METH_VARARGS },
	 { (char *)"NameSpaceIterator_swigregister", NameSpaceIterator_swigregister, METH_VARARGS },
	 { (char *)"new_StringVector", _wrap_new_StringVector, METH_VARARGS },
	 { (char *)"StringVector___len__", _wrap_StringVector___len__, METH_VARARGS },
	 { (char *)"StringVector_clear", _wrap_StringVector_clear, METH_VARARGS },
	 { (char *)"StringVector_append", _wrap_StringVector_append, METH_VARARGS },
	 { (char *)"StringVector___nonzero__", _wrap_StringVector___nonzero__, METH_VARARGS },
	 { (char *)"StringVector_pop", _wrap_StringVector_pop, METH_VARARGS },
	 { (char *)"StringVector___getitem__", _wrap_StringVector___getitem__, METH_VARARGS },
	 { (char *)"StringVector___getslice__", _wrap_StringVector___getslice__, METH_VARARGS },
	 { (char *)"StringVector___setitem__", _wrap_StringVector___setitem__, METH_VARARGS },
	 { (char *)"StringVector___setslice__", _wrap_StringVector___setslice__, METH_VARARGS },
	 { (char *)"StringVector___delitem__", _wrap_StringVector___delitem__, METH_VARARGS },
	 { (char *)"StringVector___delslice__", _wrap_StringVector___delslice__, METH_VARARGS },
	 { (char *)"delete_StringVector", _wrap_delete_StringVector, METH_VARARGS },
	 { (char *)"StringVector_swigregister", StringVector_swigregister, METH_VARARGS },
	 { (char *)"StringArray_add", _wrap_StringArray_add, METH_VARARGS },
	 { (char *)"StringArray_toStringBuffer", _wrap_StringArray_toStringBuffer, METH_VARARGS },
	 { (char *)"new_StringArray", _wrap_new_StringArray, METH_VARARGS },
	 { (char *)"delete_StringArray", _wrap_delete_StringArray, METH_VARARGS },
	 { (char *)"StringArray_swigregister", StringArray_swigregister, METH_VARARGS },
	 { (char *)"new_PropertyVector", _wrap_new_PropertyVector, METH_VARARGS },
	 { (char *)"PropertyVector___len__", _wrap_PropertyVector___len__, METH_VARARGS },
	 { (char *)"PropertyVector_clear", _wrap_PropertyVector_clear, METH_VARARGS },
	 { (char *)"PropertyVector_append", _wrap_PropertyVector_append, METH_VARARGS },
	 { (char *)"PropertyVector___nonzero__", _wrap_PropertyVector___nonzero__, METH_VARARGS },
	 { (char *)"PropertyVector_pop", _wrap_PropertyVector_pop, METH_VARARGS },
	 { (char *)"PropertyVector___getitem__", _wrap_PropertyVector___getitem__, METH_VARARGS },
	 { (char *)"PropertyVector___getslice__", _wrap_PropertyVector___getslice__, METH_VARARGS },
	 { (char *)"PropertyVector___setitem__", _wrap_PropertyVector___setitem__, METH_VARARGS },
	 { (char *)"PropertyVector___setslice__", _wrap_PropertyVector___setslice__, METH_VARARGS },
	 { (char *)"PropertyVector___delitem__", _wrap_PropertyVector___delitem__, METH_VARARGS },
	 { (char *)"PropertyVector___delslice__", _wrap_PropertyVector___delslice__, METH_VARARGS },
	 { (char *)"delete_PropertyVector", _wrap_delete_PropertyVector, METH_VARARGS },
	 { (char *)"PropertyVector_swigregister", PropertyVector_swigregister, METH_VARARGS },
	 { (char *)"new_PropertyArray", _wrap_new_PropertyArray, METH_VARARGS },
	 { (char *)"PropertyArray_add", _wrap_PropertyArray_add, METH_VARARGS },
	 { (char *)"PropertyArray_toStringBuffer", _wrap_PropertyArray_toStringBuffer, METH_VARARGS },
	 { (char *)"PropertyArray___setitem__", _wrap_PropertyArray___setitem__, METH_VARARGS },
	 { (char *)"PropertyArray___str__", _wrap_PropertyArray___str__, METH_VARARGS },
	 { (char *)"PropertyArray___iter__", _wrap_PropertyArray___iter__, METH_VARARGS },
	 { (char *)"PropertyArray___getitem__", _wrap_PropertyArray___getitem__, METH_VARARGS },
	 { (char *)"PropertyArray___delitem__", _wrap_PropertyArray___delitem__, METH_VARARGS },
	 { (char *)"PropertyArray_keys", _wrap_PropertyArray_keys, METH_VARARGS },
	 { (char *)"delete_PropertyArray", _wrap_delete_PropertyArray, METH_VARARGS },
	 { (char *)"PropertyArray_swigregister", PropertyArray_swigregister, METH_VARARGS },
	 { (char *)"PropertyIterator_it_set", _wrap_PropertyIterator_it_set, METH_VARARGS },
	 { (char *)"PropertyIterator_it_get", _wrap_PropertyIterator_it_get, METH_VARARGS },
	 { (char *)"PropertyIterator_c_set", _wrap_PropertyIterator_c_set, METH_VARARGS },
	 { (char *)"PropertyIterator_c_get", _wrap_PropertyIterator_c_get, METH_VARARGS },
	 { (char *)"new_PropertyIterator", _wrap_new_PropertyIterator, METH_VARARGS },
	 { (char *)"PropertyIterator___iter__", _wrap_PropertyIterator___iter__, METH_VARARGS },
	 { (char *)"PropertyIterator_next", _wrap_PropertyIterator_next, METH_VARARGS },
	 { (char *)"delete_PropertyIterator", _wrap_delete_PropertyIterator, METH_VARARGS },
	 { (char *)"PropertyIterator_swigregister", PropertyIterator_swigregister, METH_VARARGS },
	 { (char *)"new_InstanceNameVector", _wrap_new_InstanceNameVector, METH_VARARGS },
	 { (char *)"InstanceNameVector___len__", _wrap_InstanceNameVector___len__, METH_VARARGS },
	 { (char *)"InstanceNameVector_clear", _wrap_InstanceNameVector_clear, METH_VARARGS },
	 { (char *)"InstanceNameVector_append", _wrap_InstanceNameVector_append, METH_VARARGS },
	 { (char *)"InstanceNameVector___nonzero__", _wrap_InstanceNameVector___nonzero__, METH_VARARGS },
	 { (char *)"InstanceNameVector_pop", _wrap_InstanceNameVector_pop, METH_VARARGS },
	 { (char *)"InstanceNameVector___getitem__", _wrap_InstanceNameVector___getitem__, METH_VARARGS },
	 { (char *)"InstanceNameVector___getslice__", _wrap_InstanceNameVector___getslice__, METH_VARARGS },
	 { (char *)"InstanceNameVector___setitem__", _wrap_InstanceNameVector___setitem__, METH_VARARGS },
	 { (char *)"InstanceNameVector___setslice__", _wrap_InstanceNameVector___setslice__, METH_VARARGS },
	 { (char *)"InstanceNameVector___delitem__", _wrap_InstanceNameVector___delitem__, METH_VARARGS },
	 { (char *)"InstanceNameVector___delslice__", _wrap_InstanceNameVector___delslice__, METH_VARARGS },
	 { (char *)"delete_InstanceNameVector", _wrap_delete_InstanceNameVector, METH_VARARGS },
	 { (char *)"InstanceNameVector_swigregister", InstanceNameVector_swigregister, METH_VARARGS },
	 { (char *)"new_InstanceNameArray", _wrap_new_InstanceNameArray, METH_VARARGS },
	 { (char *)"InstanceNameArray_add", _wrap_InstanceNameArray_add, METH_VARARGS },
	 { (char *)"InstanceNameArray_toStringBuffer", _wrap_InstanceNameArray_toStringBuffer, METH_VARARGS },
	 { (char *)"InstanceNameArray___setitem__", _wrap_InstanceNameArray___setitem__, METH_VARARGS },
	 { (char *)"InstanceNameArray___getitem__", _wrap_InstanceNameArray___getitem__, METH_VARARGS },
	 { (char *)"InstanceNameArray___str__", _wrap_InstanceNameArray___str__, METH_VARARGS },
	 { (char *)"InstanceNameArray___iter__", _wrap_InstanceNameArray___iter__, METH_VARARGS },
	 { (char *)"delete_InstanceNameArray", _wrap_delete_InstanceNameArray, METH_VARARGS },
	 { (char *)"InstanceNameArray_swigregister", InstanceNameArray_swigregister, METH_VARARGS },
	 { (char *)"InstanceNameIterator_it_set", _wrap_InstanceNameIterator_it_set, METH_VARARGS },
	 { (char *)"InstanceNameIterator_it_get", _wrap_InstanceNameIterator_it_get, METH_VARARGS },
	 { (char *)"InstanceNameIterator_c_set", _wrap_InstanceNameIterator_c_set, METH_VARARGS },
	 { (char *)"InstanceNameIterator_c_get", _wrap_InstanceNameIterator_c_get, METH_VARARGS },
	 { (char *)"new_InstanceNameIterator", _wrap_new_InstanceNameIterator, METH_VARARGS },
	 { (char *)"InstanceNameIterator___iter__", _wrap_InstanceNameIterator___iter__, METH_VARARGS },
	 { (char *)"InstanceNameIterator_next", _wrap_InstanceNameIterator_next, METH_VARARGS },
	 { (char *)"delete_InstanceNameIterator", _wrap_delete_InstanceNameIterator, METH_VARARGS },
	 { (char *)"InstanceNameIterator_swigregister", InstanceNameIterator_swigregister, METH_VARARGS },
	 { (char *)"new_InstanceVector", _wrap_new_InstanceVector, METH_VARARGS },
	 { (char *)"InstanceVector___len__", _wrap_InstanceVector___len__, METH_VARARGS },
	 { (char *)"InstanceVector_clear", _wrap_InstanceVector_clear, METH_VARARGS },
	 { (char *)"InstanceVector_append", _wrap_InstanceVector_append, METH_VARARGS },
	 { (char *)"InstanceVector___nonzero__", _wrap_InstanceVector___nonzero__, METH_VARARGS },
	 { (char *)"InstanceVector_pop", _wrap_InstanceVector_pop, METH_VARARGS },
	 { (char *)"InstanceVector___getitem__", _wrap_InstanceVector___getitem__, METH_VARARGS },
	 { (char *)"InstanceVector___getslice__", _wrap_InstanceVector___getslice__, METH_VARARGS },
	 { (char *)"InstanceVector___setitem__", _wrap_InstanceVector___setitem__, METH_VARARGS },
	 { (char *)"InstanceVector___setslice__", _wrap_InstanceVector___setslice__, METH_VARARGS },
	 { (char *)"InstanceVector___delitem__", _wrap_InstanceVector___delitem__, METH_VARARGS },
	 { (char *)"InstanceVector___delslice__", _wrap_InstanceVector___delslice__, METH_VARARGS },
	 { (char *)"delete_InstanceVector", _wrap_delete_InstanceVector, METH_VARARGS },
	 { (char *)"InstanceVector_swigregister", InstanceVector_swigregister, METH_VARARGS },
	 { (char *)"new_InstanceArray", _wrap_new_InstanceArray, METH_VARARGS },
	 { (char *)"InstanceArray_add", _wrap_InstanceArray_add, METH_VARARGS },
	 { (char *)"InstanceArray_toStringBuffer", _wrap_InstanceArray_toStringBuffer, METH_VARARGS },
	 { (char *)"InstanceArray___setitem__", _wrap_InstanceArray___setitem__, METH_VARARGS },
	 { (char *)"InstanceArray___getitem__", _wrap_InstanceArray___getitem__, METH_VARARGS },
	 { (char *)"InstanceArray___str__", _wrap_InstanceArray___str__, METH_VARARGS },
	 { (char *)"InstanceArray___iter__", _wrap_InstanceArray___iter__, METH_VARARGS },
	 { (char *)"delete_InstanceArray", _wrap_delete_InstanceArray, METH_VARARGS },
	 { (char *)"InstanceArray_swigregister", InstanceArray_swigregister, METH_VARARGS },
	 { (char *)"InstanceIterator_it_set", _wrap_InstanceIterator_it_set, METH_VARARGS },
	 { (char *)"InstanceIterator_it_get", _wrap_InstanceIterator_it_get, METH_VARARGS },
	 { (char *)"InstanceIterator_c_set", _wrap_InstanceIterator_c_set, METH_VARARGS },
	 { (char *)"InstanceIterator_c_get", _wrap_InstanceIterator_c_get, METH_VARARGS },
	 { (char *)"new_InstanceIterator", _wrap_new_InstanceIterator, METH_VARARGS },
	 { (char *)"InstanceIterator___iter__", _wrap_InstanceIterator___iter__, METH_VARARGS },
	 { (char *)"InstanceIterator_next", _wrap_InstanceIterator_next, METH_VARARGS },
	 { (char *)"delete_InstanceIterator", _wrap_delete_InstanceIterator, METH_VARARGS },
	 { (char *)"InstanceIterator_swigregister", InstanceIterator_swigregister, METH_VARARGS },
	 { (char *)"new_KeyBindingVector", _wrap_new_KeyBindingVector, METH_VARARGS },
	 { (char *)"KeyBindingVector___len__", _wrap_KeyBindingVector___len__, METH_VARARGS },
	 { (char *)"KeyBindingVector_clear", _wrap_KeyBindingVector_clear, METH_VARARGS },
	 { (char *)"KeyBindingVector_append", _wrap_KeyBindingVector_append, METH_VARARGS },
	 { (char *)"KeyBindingVector___nonzero__", _wrap_KeyBindingVector___nonzero__, METH_VARARGS },
	 { (char *)"KeyBindingVector_pop", _wrap_KeyBindingVector_pop, METH_VARARGS },
	 { (char *)"KeyBindingVector___getitem__", _wrap_KeyBindingVector___getitem__, METH_VARARGS },
	 { (char *)"KeyBindingVector___getslice__", _wrap_KeyBindingVector___getslice__, METH_VARARGS },
	 { (char *)"KeyBindingVector___setitem__", _wrap_KeyBindingVector___setitem__, METH_VARARGS },
	 { (char *)"KeyBindingVector___setslice__", _wrap_KeyBindingVector___setslice__, METH_VARARGS },
	 { (char *)"KeyBindingVector___delitem__", _wrap_KeyBindingVector___delitem__, METH_VARARGS },
	 { (char *)"KeyBindingVector___delslice__", _wrap_KeyBindingVector___delslice__, METH_VARARGS },
	 { (char *)"delete_KeyBindingVector", _wrap_delete_KeyBindingVector, METH_VARARGS },
	 { (char *)"KeyBindingVector_swigregister", KeyBindingVector_swigregister, METH_VARARGS },
	 { (char *)"new_KeyBindingArray", _wrap_new_KeyBindingArray, METH_VARARGS },
	 { (char *)"KeyBindingArray_add", _wrap_KeyBindingArray_add, METH_VARARGS },
	 { (char *)"KeyBindingArray_toStringBuffer", _wrap_KeyBindingArray_toStringBuffer, METH_VARARGS },
	 { (char *)"KeyBindingArray___setitem__", _wrap_KeyBindingArray___setitem__, METH_VARARGS },
	 { (char *)"KeyBindingArray___getitem__", _wrap_KeyBindingArray___getitem__, METH_VARARGS },
	 { (char *)"KeyBindingArray___str__", _wrap_KeyBindingArray___str__, METH_VARARGS },
	 { (char *)"KeyBindingArray___iter__", _wrap_KeyBindingArray___iter__, METH_VARARGS },
	 { (char *)"delete_KeyBindingArray", _wrap_delete_KeyBindingArray, METH_VARARGS },
	 { (char *)"KeyBindingArray_swigregister", KeyBindingArray_swigregister, METH_VARARGS },
	 { (char *)"KeyBindingIterator_it_set", _wrap_KeyBindingIterator_it_set, METH_VARARGS },
	 { (char *)"KeyBindingIterator_it_get", _wrap_KeyBindingIterator_it_get, METH_VARARGS },
	 { (char *)"KeyBindingIterator_c_set", _wrap_KeyBindingIterator_c_set, METH_VARARGS },
	 { (char *)"KeyBindingIterator_c_get", _wrap_KeyBindingIterator_c_get, METH_VARARGS },
	 { (char *)"new_KeyBindingIterator", _wrap_new_KeyBindingIterator, METH_VARARGS },
	 { (char *)"KeyBindingIterator___iter__", _wrap_KeyBindingIterator___iter__, METH_VARARGS },
	 { (char *)"KeyBindingIterator_next", _wrap_KeyBindingIterator_next, METH_VARARGS },
	 { (char *)"delete_KeyBindingIterator", _wrap_delete_KeyBindingIterator, METH_VARARGS },
	 { (char *)"KeyBindingIterator_swigregister", KeyBindingIterator_swigregister, METH_VARARGS },
	 { (char *)"new_ClassNameVector", _wrap_new_ClassNameVector, METH_VARARGS },
	 { (char *)"ClassNameVector___len__", _wrap_ClassNameVector___len__, METH_VARARGS },
	 { (char *)"ClassNameVector_clear", _wrap_ClassNameVector_clear, METH_VARARGS },
	 { (char *)"ClassNameVector_append", _wrap_ClassNameVector_append, METH_VARARGS },
	 { (char *)"ClassNameVector___nonzero__", _wrap_ClassNameVector___nonzero__, METH_VARARGS },
	 { (char *)"ClassNameVector_pop", _wrap_ClassNameVector_pop, METH_VARARGS },
	 { (char *)"ClassNameVector___getitem__", _wrap_ClassNameVector___getitem__, METH_VARARGS },
	 { (char *)"ClassNameVector___getslice__", _wrap_ClassNameVector___getslice__, METH_VARARGS },
	 { (char *)"ClassNameVector___setitem__", _wrap_ClassNameVector___setitem__, METH_VARARGS },
	 { (char *)"ClassNameVector___setslice__", _wrap_ClassNameVector___setslice__, METH_VARARGS },
	 { (char *)"ClassNameVector___delitem__", _wrap_ClassNameVector___delitem__, METH_VARARGS },
	 { (char *)"ClassNameVector___delslice__", _wrap_ClassNameVector___delslice__, METH_VARARGS },
	 { (char *)"delete_ClassNameVector", _wrap_delete_ClassNameVector, METH_VARARGS },
	 { (char *)"ClassNameVector_swigregister", ClassNameVector_swigregister, METH_VARARGS },
	 { (char *)"new_ClassNameArray", _wrap_new_ClassNameArray, METH_VARARGS },
	 { (char *)"ClassNameArray_add", _wrap_ClassNameArray_add, METH_VARARGS },
	 { (char *)"ClassNameArray_toStringBuffer", _wrap_ClassNameArray_toStringBuffer, METH_VARARGS },
	 { (char *)"ClassNameArray___setitem__", _wrap_ClassNameArray___setitem__, METH_VARARGS },
	 { (char *)"ClassNameArray___getitem__", _wrap_ClassNameArray___getitem__, METH_VARARGS },
	 { (char *)"ClassNameArray___str__", _wrap_ClassNameArray___str__, METH_VARARGS },
	 { (char *)"ClassNameArray___iter__", _wrap_ClassNameArray___iter__, METH_VARARGS },
	 { (char *)"delete_ClassNameArray", _wrap_delete_ClassNameArray, METH_VARARGS },
	 { (char *)"ClassNameArray_swigregister", ClassNameArray_swigregister, METH_VARARGS },
	 { (char *)"ClassNameIterator_it_set", _wrap_ClassNameIterator_it_set, METH_VARARGS },
	 { (char *)"ClassNameIterator_it_get", _wrap_ClassNameIterator_it_get, METH_VARARGS },
	 { (char *)"ClassNameIterator_c_set", _wrap_ClassNameIterator_c_set, METH_VARARGS },
	 { (char *)"ClassNameIterator_c_get", _wrap_ClassNameIterator_c_get, METH_VARARGS },
	 { (char *)"new_ClassNameIterator", _wrap_new_ClassNameIterator, METH_VARARGS },
	 { (char *)"ClassNameIterator___iter__", _wrap_ClassNameIterator___iter__, METH_VARARGS },
	 { (char *)"ClassNameIterator_next", _wrap_ClassNameIterator_next, METH_VARARGS },
	 { (char *)"delete_ClassNameIterator", _wrap_delete_ClassNameIterator, METH_VARARGS },
	 { (char *)"ClassNameIterator_swigregister", ClassNameIterator_swigregister, METH_VARARGS },
	 { (char *)"new_ClassVector", _wrap_new_ClassVector, METH_VARARGS },
	 { (char *)"ClassVector___len__", _wrap_ClassVector___len__, METH_VARARGS },
	 { (char *)"ClassVector_clear", _wrap_ClassVector_clear, METH_VARARGS },
	 { (char *)"ClassVector_append", _wrap_ClassVector_append, METH_VARARGS },
	 { (char *)"ClassVector___nonzero__", _wrap_ClassVector___nonzero__, METH_VARARGS },
	 { (char *)"ClassVector_pop", _wrap_ClassVector_pop, METH_VARARGS },
	 { (char *)"ClassVector___getitem__", _wrap_ClassVector___getitem__, METH_VARARGS },
	 { (char *)"ClassVector___getslice__", _wrap_ClassVector___getslice__, METH_VARARGS },
	 { (char *)"ClassVector___setitem__", _wrap_ClassVector___setitem__, METH_VARARGS },
	 { (char *)"ClassVector___setslice__", _wrap_ClassVector___setslice__, METH_VARARGS },
	 { (char *)"ClassVector___delitem__", _wrap_ClassVector___delitem__, METH_VARARGS },
	 { (char *)"ClassVector___delslice__", _wrap_ClassVector___delslice__, METH_VARARGS },
	 { (char *)"delete_ClassVector", _wrap_delete_ClassVector, METH_VARARGS },
	 { (char *)"ClassVector_swigregister", ClassVector_swigregister, METH_VARARGS },
	 { (char *)"new_ClassArray", _wrap_new_ClassArray, METH_VARARGS },
	 { (char *)"ClassArray_add", _wrap_ClassArray_add, METH_VARARGS },
	 { (char *)"ClassArray_toStringBuffer", _wrap_ClassArray_toStringBuffer, METH_VARARGS },
	 { (char *)"ClassArray___setitem__", _wrap_ClassArray___setitem__, METH_VARARGS },
	 { (char *)"ClassArray___getitem__", _wrap_ClassArray___getitem__, METH_VARARGS },
	 { (char *)"ClassArray___str__", _wrap_ClassArray___str__, METH_VARARGS },
	 { (char *)"ClassArray___iter__", _wrap_ClassArray___iter__, METH_VARARGS },
	 { (char *)"delete_ClassArray", _wrap_delete_ClassArray, METH_VARARGS },
	 { (char *)"ClassArray_swigregister", ClassArray_swigregister, METH_VARARGS },
	 { (char *)"ClassIterator_it_set", _wrap_ClassIterator_it_set, METH_VARARGS },
	 { (char *)"ClassIterator_it_get", _wrap_ClassIterator_it_get, METH_VARARGS },
	 { (char *)"ClassIterator_c_set", _wrap_ClassIterator_c_set, METH_VARARGS },
	 { (char *)"ClassIterator_c_get", _wrap_ClassIterator_c_get, METH_VARARGS },
	 { (char *)"new_ClassIterator", _wrap_new_ClassIterator, METH_VARARGS },
	 { (char *)"ClassIterator___iter__", _wrap_ClassIterator___iter__, METH_VARARGS },
	 { (char *)"ClassIterator_next", _wrap_ClassIterator_next, METH_VARARGS },
	 { (char *)"delete_ClassIterator", _wrap_delete_ClassIterator, METH_VARARGS },
	 { (char *)"ClassIterator_swigregister", ClassIterator_swigregister, METH_VARARGS },
	 { (char *)"new_ObjectWithPathVector", _wrap_new_ObjectWithPathVector, METH_VARARGS },
	 { (char *)"ObjectWithPathVector___len__", _wrap_ObjectWithPathVector___len__, METH_VARARGS },
	 { (char *)"ObjectWithPathVector_clear", _wrap_ObjectWithPathVector_clear, METH_VARARGS },
	 { (char *)"ObjectWithPathVector_append", _wrap_ObjectWithPathVector_append, METH_VARARGS },
	 { (char *)"ObjectWithPathVector___nonzero__", _wrap_ObjectWithPathVector___nonzero__, METH_VARARGS },
	 { (char *)"ObjectWithPathVector_pop", _wrap_ObjectWithPathVector_pop, METH_VARARGS },
	 { (char *)"ObjectWithPathVector___getitem__", _wrap_ObjectWithPathVector___getitem__, METH_VARARGS },
	 { (char *)"ObjectWithPathVector___getslice__", _wrap_ObjectWithPathVector___getslice__, METH_VARARGS },
	 { (char *)"ObjectWithPathVector___setitem__", _wrap_ObjectWithPathVector___setitem__, METH_VARARGS },
	 { (char *)"ObjectWithPathVector___setslice__", _wrap_ObjectWithPathVector___setslice__, METH_VARARGS },
	 { (char *)"ObjectWithPathVector___delitem__", _wrap_ObjectWithPathVector___delitem__, METH_VARARGS },
	 { (char *)"ObjectWithPathVector___delslice__", _wrap_ObjectWithPathVector___delslice__, METH_VARARGS },
	 { (char *)"delete_ObjectWithPathVector", _wrap_delete_ObjectWithPathVector, METH_VARARGS },
	 { (char *)"ObjectWithPathVector_swigregister", ObjectWithPathVector_swigregister, METH_VARARGS },
	 { (char *)"new_ObjectWithPathArray", _wrap_new_ObjectWithPathArray, METH_VARARGS },
	 { (char *)"ObjectWithPathArray_add", _wrap_ObjectWithPathArray_add, METH_VARARGS },
	 { (char *)"ObjectWithPathArray_toStringBuffer", _wrap_ObjectWithPathArray_toStringBuffer, METH_VARARGS },
	 { (char *)"ObjectWithPathArray___setitem__", _wrap_ObjectWithPathArray___setitem__, METH_VARARGS },
	 { (char *)"ObjectWithPathArray___getitem__", _wrap_ObjectWithPathArray___getitem__, METH_VARARGS },
	 { (char *)"ObjectWithPathArray___str__", _wrap_ObjectWithPathArray___str__, METH_VARARGS },
	 { (char *)"ObjectWithPathArray___iter__", _wrap_ObjectWithPathArray___iter__, METH_VARARGS },
	 { (char *)"delete_ObjectWithPathArray", _wrap_delete_ObjectWithPathArray, METH_VARARGS },
	 { (char *)"ObjectWithPathArray_swigregister", ObjectWithPathArray_swigregister, METH_VARARGS },
	 { (char *)"ObjectWithPathIterator_it_set", _wrap_ObjectWithPathIterator_it_set, METH_VARARGS },
	 { (char *)"ObjectWithPathIterator_it_get", _wrap_ObjectWithPathIterator_it_get, METH_VARARGS },
	 { (char *)"ObjectWithPathIterator_c_set", _wrap_ObjectWithPathIterator_c_set, METH_VARARGS },
	 { (char *)"ObjectWithPathIterator_c_get", _wrap_ObjectWithPathIterator_c_get, METH_VARARGS },
	 { (char *)"new_ObjectWithPathIterator", _wrap_new_ObjectWithPathIterator, METH_VARARGS },
	 { (char *)"ObjectWithPathIterator___iter__", _wrap_ObjectWithPathIterator___iter__, METH_VARARGS },
	 { (char *)"ObjectWithPathIterator_next", _wrap_ObjectWithPathIterator_next, METH_VARARGS },
	 { (char *)"delete_ObjectWithPathIterator", _wrap_delete_ObjectWithPathIterator, METH_VARARGS },
	 { (char *)"ObjectWithPathIterator_swigregister", ObjectWithPathIterator_swigregister, METH_VARARGS },
	 { (char *)"new_NamedInstanceVector", _wrap_new_NamedInstanceVector, METH_VARARGS },
	 { (char *)"NamedInstanceVector___len__", _wrap_NamedInstanceVector___len__, METH_VARARGS },
	 { (char *)"NamedInstanceVector_clear", _wrap_NamedInstanceVector_clear, METH_VARARGS },
	 { (char *)"NamedInstanceVector_append", _wrap_NamedInstanceVector_append, METH_VARARGS },
	 { (char *)"NamedInstanceVector___nonzero__", _wrap_NamedInstanceVector___nonzero__, METH_VARARGS },
	 { (char *)"NamedInstanceVector_pop", _wrap_NamedInstanceVector_pop, METH_VARARGS },
	 { (char *)"NamedInstanceVector___getitem__", _wrap_NamedInstanceVector___getitem__, METH_VARARGS },
	 { (char *)"NamedInstanceVector___getslice__", _wrap_NamedInstanceVector___getslice__, METH_VARARGS },
	 { (char *)"NamedInstanceVector___setitem__", _wrap_NamedInstanceVector___setitem__, METH_VARARGS },
	 { (char *)"NamedInstanceVector___setslice__", _wrap_NamedInstanceVector___setslice__, METH_VARARGS },
	 { (char *)"NamedInstanceVector___delitem__", _wrap_NamedInstanceVector___delitem__, METH_VARARGS },
	 { (char *)"NamedInstanceVector___delslice__", _wrap_NamedInstanceVector___delslice__, METH_VARARGS },
	 { (char *)"delete_NamedInstanceVector", _wrap_delete_NamedInstanceVector, METH_VARARGS },
	 { (char *)"NamedInstanceVector_swigregister", NamedInstanceVector_swigregister, METH_VARARGS },
	 { (char *)"new_NamedInstanceArray", _wrap_new_NamedInstanceArray, METH_VARARGS },
	 { (char *)"NamedInstanceArray_add", _wrap_NamedInstanceArray_add, METH_VARARGS },
	 { (char *)"NamedInstanceArray_toStringBuffer", _wrap_NamedInstanceArray_toStringBuffer, METH_VARARGS },
	 { (char *)"NamedInstanceArray___setitem__", _wrap_NamedInstanceArray___setitem__, METH_VARARGS },
	 { (char *)"NamedInstanceArray___getitem__", _wrap_NamedInstanceArray___getitem__, METH_VARARGS },
	 { (char *)"NamedInstanceArray___str__", _wrap_NamedInstanceArray___str__, METH_VARARGS },
	 { (char *)"NamedInstanceArray___iter__", _wrap_NamedInstanceArray___iter__, METH_VARARGS },
	 { (char *)"delete_NamedInstanceArray", _wrap_delete_NamedInstanceArray, METH_VARARGS },
	 { (char *)"NamedInstanceArray_swigregister", NamedInstanceArray_swigregister, METH_VARARGS },
	 { (char *)"NamedInstanceIterator_it_set", _wrap_NamedInstanceIterator_it_set, METH_VARARGS },
	 { (char *)"NamedInstanceIterator_it_get", _wrap_NamedInstanceIterator_it_get, METH_VARARGS },
	 { (char *)"NamedInstanceIterator_c_set", _wrap_NamedInstanceIterator_c_set, METH_VARARGS },
	 { (char *)"NamedInstanceIterator_c_get", _wrap_NamedInstanceIterator_c_get, METH_VARARGS },
	 { (char *)"new_NamedInstanceIterator", _wrap_new_NamedInstanceIterator, METH_VARARGS },
	 { (char *)"NamedInstanceIterator___iter__", _wrap_NamedInstanceIterator___iter__, METH_VARARGS },
	 { (char *)"NamedInstanceIterator_next", _wrap_NamedInstanceIterator_next, METH_VARARGS },
	 { (char *)"delete_NamedInstanceIterator", _wrap_delete_NamedInstanceIterator, METH_VARARGS },
	 { (char *)"NamedInstanceIterator_swigregister", NamedInstanceIterator_swigregister, METH_VARARGS },
	 { (char *)"DoesNotExist_desc_set", _wrap_DoesNotExist_desc_set, METH_VARARGS },
	 { (char *)"DoesNotExist_desc_get", _wrap_DoesNotExist_desc_get, METH_VARARGS },
	 { (char *)"new_DoesNotExist", _wrap_new_DoesNotExist, METH_VARARGS },
	 { (char *)"delete_DoesNotExist", _wrap_delete_DoesNotExist, METH_VARARGS },
	 { (char *)"DoesNotExist_swigregister", DoesNotExist_swigregister, METH_VARARGS },
	 { (char *)"new_stringOption", _wrap_new_stringOption, METH_VARARGS },
	 { (char *)"stringOption_exists", _wrap_stringOption_exists, METH_VARARGS },
	 { (char *)"stringOption_val", _wrap_stringOption_val, METH_VARARGS },
	 { (char *)"delete_stringOption", _wrap_delete_stringOption, METH_VARARGS },
	 { (char *)"stringOption_swigregister", stringOption_swigregister, METH_VARARGS },
	 { (char *)"new_MethodXml", _wrap_new_MethodXml, METH_VARARGS },
	 { (char *)"delete_MethodXml", _wrap_delete_MethodXml, METH_VARARGS },
	 { (char *)"MethodXml_swigregister", MethodXml_swigregister, METH_VARARGS },
	 { (char *)"QualifierXml_str_set", _wrap_QualifierXml_str_set, METH_VARARGS },
	 { (char *)"QualifierXml_str_get", _wrap_QualifierXml_str_get, METH_VARARGS },
	 { (char *)"QualifierXml_key_set", _wrap_QualifierXml_key_set, METH_VARARGS },
	 { (char *)"QualifierXml_key_get", _wrap_QualifierXml_key_get, METH_VARARGS },
	 { (char *)"new_QualifierXml", _wrap_new_QualifierXml, METH_VARARGS },
	 { (char *)"delete_QualifierXml", _wrap_delete_QualifierXml, METH_VARARGS },
	 { (char *)"QualifierXml_swigregister", QualifierXml_swigregister, METH_VARARGS },
	 { (char *)"AValue_attr_set", _wrap_AValue_attr_set, METH_VARARGS },
	 { (char *)"AValue_attr_get", _wrap_AValue_attr_get, METH_VARARGS },
	 { (char *)"AValue_val_set", _wrap_AValue_val_set, METH_VARARGS },
	 { (char *)"AValue_val_get", _wrap_AValue_val_get, METH_VARARGS },
	 { (char *)"AValue_vals_set", _wrap_AValue_vals_set, METH_VARARGS },
	 { (char *)"AValue_vals_get", _wrap_AValue_vals_get, METH_VARARGS },
	 { (char *)"new_AValue", _wrap_new_AValue, METH_VARARGS },
	 { (char *)"AValue_add", _wrap_AValue_add, METH_VARARGS },
	 { (char *)"delete_AValue", _wrap_delete_AValue, METH_VARARGS },
	 { (char *)"AValue_swigregister", AValue_swigregister, METH_VARARGS },
	 { (char *)"new_AVPs", _wrap_new_AVPs, METH_VARARGS },
	 { (char *)"AVPs_makeAVPs", _wrap_AVPs_makeAVPs, METH_VARARGS },
	 { (char *)"AVPs_get", _wrap_AVPs_get, METH_VARARGS },
	 { (char *)"AVPs_check", _wrap_AVPs_check, METH_VARARGS },
	 { (char *)"AVPs_notGotten", _wrap_AVPs_notGotten, METH_VARARGS },
	 { (char *)"delete_AVPs", _wrap_delete_AVPs, METH_VARARGS },
	 { (char *)"AVPs_swigregister", AVPs_swigregister, METH_VARARGS },
	 { (char *)"new_AList", _wrap_new_AList, METH_VARARGS },
	 { (char *)"delete_AList", _wrap_delete_AList, METH_VARARGS },
	 { (char *)"AList_attrv_set", _wrap_AList_attrv_set, METH_VARARGS },
	 { (char *)"AList_attrv_get", _wrap_AList_attrv_get, METH_VARARGS },
	 { (char *)"AList_attrl_set", _wrap_AList_attrl_set, METH_VARARGS },
	 { (char *)"AList_attrl_get", _wrap_AList_attrl_get, METH_VARARGS },
	 { (char *)"AList_attrs_set", _wrap_AList_attrs_set, METH_VARARGS },
	 { (char *)"AList_attrs_get", _wrap_AList_attrs_get, METH_VARARGS },
	 { (char *)"AList_swigregister", AList_swigregister, METH_VARARGS },
	 { (char *)"XmlException_getMsg", _wrap_XmlException_getMsg, METH_VARARGS },
	 { (char *)"new_XmlException", _wrap_new_XmlException, METH_VARARGS },
	 { (char *)"delete_XmlException", _wrap_delete_XmlException, METH_VARARGS },
	 { (char *)"XmlException_swigregister", XmlException_swigregister, METH_VARARGS },
	 { (char *)"new_URLException", _wrap_new_URLException, METH_VARARGS },
	 { (char *)"delete_URLException", _wrap_delete_URLException, METH_VARARGS },
	 { (char *)"URLException_swigregister", URLException_swigregister, METH_VARARGS },
	 { (char *)"new_ParseException", _wrap_new_ParseException, METH_VARARGS },
	 { (char *)"delete_ParseException", _wrap_delete_ParseException, METH_VARARGS },
	 { (char *)"ParseException_swigregister", ParseException_swigregister, METH_VARARGS },
	 { (char *)"new_HttpException", _wrap_new_HttpException, METH_VARARGS },
	 { (char *)"delete_HttpException", _wrap_delete_HttpException, METH_VARARGS },
	 { (char *)"HttpException_swigregister", HttpException_swigregister, METH_VARARGS },
	 { (char *)"new_CmdException", _wrap_new_CmdException, METH_VARARGS },
	 { (char *)"delete_CmdException", _wrap_delete_CmdException, METH_VARARGS },
	 { (char *)"CmdException_swigregister", CmdException_swigregister, METH_VARARGS },
	 { (char *)"ErrorXml_desc_set", _wrap_ErrorXml_desc_set, METH_VARARGS },
	 { (char *)"ErrorXml_desc_get", _wrap_ErrorXml_desc_get, METH_VARARGS },
	 { (char *)"ErrorXml_code_set", _wrap_ErrorXml_code_set, METH_VARARGS },
	 { (char *)"ErrorXml_code_get", _wrap_ErrorXml_code_get, METH_VARARGS },
	 { (char *)"new_ErrorXml", _wrap_new_ErrorXml, METH_VARARGS },
	 { (char *)"delete_ErrorXml", _wrap_delete_ErrorXml, METH_VARARGS },
	 { (char *)"ErrorXml_swigregister", ErrorXml_swigregister, METH_VARARGS },
	 { (char *)"KeyValueXml_valType_set", _wrap_KeyValueXml_valType_set, METH_VARARGS },
	 { (char *)"KeyValueXml_valType_get", _wrap_KeyValueXml_valType_get, METH_VARARGS },
	 { (char *)"KeyValueXml_val_set", _wrap_KeyValueXml_val_set, METH_VARARGS },
	 { (char *)"KeyValueXml_val_get", _wrap_KeyValueXml_val_get, METH_VARARGS },
	 { (char *)"new_KeyValueXml", _wrap_new_KeyValueXml, METH_VARARGS },
	 { (char *)"KeyValueXml_toStringBuffer", _wrap_KeyValueXml_toStringBuffer, METH_VARARGS },
	 { (char *)"KeyValueXml___str__", _wrap_KeyValueXml___str__, METH_VARARGS },
	 { (char *)"delete_KeyValueXml", _wrap_delete_KeyValueXml, METH_VARARGS },
	 { (char *)"KeyValueXml_swigregister", KeyValueXml_swigregister, METH_VARARGS },
	 { (char *)"NameSpaceXml_name_set", _wrap_NameSpaceXml_name_set, METH_VARARGS },
	 { (char *)"NameSpaceXml_name_get", _wrap_NameSpaceXml_name_get, METH_VARARGS },
	 { (char *)"new_NameSpaceXml", _wrap_new_NameSpaceXml, METH_VARARGS },
	 { (char *)"NameSpaceXml_toStringBuffer", _wrap_NameSpaceXml_toStringBuffer, METH_VARARGS },
	 { (char *)"delete_NameSpaceXml", _wrap_delete_NameSpaceXml, METH_VARARGS },
	 { (char *)"NameSpaceXml_swigregister", NameSpaceXml_swigregister, METH_VARARGS },
	 { (char *)"HostXml_name_set", _wrap_HostXml_name_set, METH_VARARGS },
	 { (char *)"HostXml_name_get", _wrap_HostXml_name_get, METH_VARARGS },
	 { (char *)"new_HostXml", _wrap_new_HostXml, METH_VARARGS },
	 { (char *)"delete_HostXml", _wrap_delete_HostXml, METH_VARARGS },
	 { (char *)"HostXml_swigregister", HostXml_swigregister, METH_VARARGS },
	 { (char *)"new_LocalNameSpacePathXml", _wrap_new_LocalNameSpacePathXml, METH_VARARGS },
	 { (char *)"delete_LocalNameSpacePathXml", _wrap_delete_LocalNameSpacePathXml, METH_VARARGS },
	 { (char *)"LocalNameSpacePathXml_swigregister", LocalNameSpacePathXml_swigregister, METH_VARARGS },
	 { (char *)"NameSpacePathXml_host_set", _wrap_NameSpacePathXml_host_set, METH_VARARGS },
	 { (char *)"NameSpacePathXml_host_get", _wrap_NameSpacePathXml_host_get, METH_VARARGS },
	 { (char *)"NameSpacePathXml_lns_set", _wrap_NameSpacePathXml_lns_set, METH_VARARGS },
	 { (char *)"NameSpacePathXml_lns_get", _wrap_NameSpacePathXml_lns_get, METH_VARARGS },
	 { (char *)"new_NameSpacePathXml", _wrap_new_NameSpacePathXml, METH_VARARGS },
	 { (char *)"delete_NameSpacePathXml", _wrap_delete_NameSpacePathXml, METH_VARARGS },
	 { (char *)"NameSpacePathXml_swigregister", NameSpacePathXml_swigregister, METH_VARARGS },
	 { (char *)"RetValXml_type_set", _wrap_RetValXml_type_set, METH_VARARGS },
	 { (char *)"RetValXml_type_get", _wrap_RetValXml_type_get, METH_VARARGS },
	 { (char *)"delete_RetValXml", _wrap_delete_RetValXml, METH_VARARGS },
	 { (char *)"RetValXml_clone", _wrap_RetValXml_clone, METH_VARARGS },
	 { (char *)"RetValXml_getType", _wrap_RetValXml_getType, METH_VARARGS },
	 { (char *)"RetValXml_toStringBuffer", _wrap_RetValXml_toStringBuffer, METH_VARARGS },
	 { (char *)"RetValXml___str__", _wrap_RetValXml___str__, METH_VARARGS },
	 { (char *)"RetValXml___long__", _wrap_RetValXml___long__, METH_VARARGS },
	 { (char *)"RetValXml_swigregister", RetValXml_swigregister, METH_VARARGS },
	 { (char *)"delete_ValueXml", _wrap_delete_ValueXml, METH_VARARGS },
	 { (char *)"ValueXml_swigregister", ValueXml_swigregister, METH_VARARGS },
	 { (char *)"KeyBindingXml_name_set", _wrap_KeyBindingXml_name_set, METH_VARARGS },
	 { (char *)"KeyBindingXml_name_get", _wrap_KeyBindingXml_name_get, METH_VARARGS },
	 { (char *)"new_KeyBindingXml", _wrap_new_KeyBindingXml, METH_VARARGS },
	 { (char *)"KeyBindingXml_toStringBuffer", _wrap_KeyBindingXml_toStringBuffer, METH_VARARGS },
	 { (char *)"KeyBindingXml___str__", _wrap_KeyBindingXml___str__, METH_VARARGS },
	 { (char *)"delete_KeyBindingXml", _wrap_delete_KeyBindingXml, METH_VARARGS },
	 { (char *)"KeyBindingXml_swigregister", KeyBindingXml_swigregister, METH_VARARGS },
	 { (char *)"InstanceNameXml_keys_set", _wrap_InstanceNameXml_keys_set, METH_VARARGS },
	 { (char *)"InstanceNameXml_keys_get", _wrap_InstanceNameXml_keys_get, METH_VARARGS },
	 { (char *)"InstanceNameXml_toStringBuffer", _wrap_InstanceNameXml_toStringBuffer, METH_VARARGS },
	 { (char *)"delete_InstanceNameXml", _wrap_delete_InstanceNameXml, METH_VARARGS },
	 { (char *)"InstanceNameXml_swigregister", InstanceNameXml_swigregister, METH_VARARGS },
	 { (char *)"delete_InstanceNamesXml", _wrap_delete_InstanceNamesXml, METH_VARARGS },
	 { (char *)"InstanceNamesXml_swigregister", InstanceNamesXml_swigregister, METH_VARARGS },
	 { (char *)"PropertyXml_name_set", _wrap_PropertyXml_name_set, METH_VARARGS },
	 { (char *)"PropertyXml_name_get", _wrap_PropertyXml_name_get, METH_VARARGS },
	 { (char *)"PropertyXml_type_set", _wrap_PropertyXml_type_set, METH_VARARGS },
	 { (char *)"PropertyXml_type_get", _wrap_PropertyXml_type_get, METH_VARARGS },
	 { (char *)"PropertyXml_origin_set", _wrap_PropertyXml_origin_set, METH_VARARGS },
	 { (char *)"PropertyXml_origin_get", _wrap_PropertyXml_origin_get, METH_VARARGS },
	 { (char *)"PropertyXml_propagated_set", _wrap_PropertyXml_propagated_set, METH_VARARGS },
	 { (char *)"PropertyXml_propagated_get", _wrap_PropertyXml_propagated_get, METH_VARARGS },
	 { (char *)"PropertyXml_refCls_set", _wrap_PropertyXml_refCls_set, METH_VARARGS },
	 { (char *)"PropertyXml_refCls_get", _wrap_PropertyXml_refCls_get, METH_VARARGS },
	 { (char *)"PropertyXml_arraySize_set", _wrap_PropertyXml_arraySize_set, METH_VARARGS },
	 { (char *)"PropertyXml_arraySize_get", _wrap_PropertyXml_arraySize_get, METH_VARARGS },
	 { (char *)"PropertyXml_pType_set", _wrap_PropertyXml_pType_set, METH_VARARGS },
	 { (char *)"PropertyXml_pType_get", _wrap_PropertyXml_pType_get, METH_VARARGS },
	 { (char *)"PropertyXml_str_set", _wrap_PropertyXml_str_set, METH_VARARGS },
	 { (char *)"PropertyXml_str_get", _wrap_PropertyXml_str_get, METH_VARARGS },
	 { (char *)"PropertyXml_qualifiers_set", _wrap_PropertyXml_qualifiers_set, METH_VARARGS },
	 { (char *)"PropertyXml_qualifiers_get", _wrap_PropertyXml_qualifiers_get, METH_VARARGS },
	 { (char *)"PropertyXml_value_set", _wrap_PropertyXml_value_set, METH_VARARGS },
	 { (char *)"PropertyXml_value_get", _wrap_PropertyXml_value_get, METH_VARARGS },
	 { (char *)"PropertyXml_key_set", _wrap_PropertyXml_key_set, METH_VARARGS },
	 { (char *)"PropertyXml_key_get", _wrap_PropertyXml_key_get, METH_VARARGS },
	 { (char *)"new_PropertyXml", _wrap_new_PropertyXml, METH_VARARGS },
	 { (char *)"PropertyXml_addQualifier", _wrap_PropertyXml_addQualifier, METH_VARARGS },
	 { (char *)"PropertyXml_toStringBuffer", _wrap_PropertyXml_toStringBuffer, METH_VARARGS },
	 { (char *)"PropertyXml_toXmlBuffer", _wrap_PropertyXml_toXmlBuffer, METH_VARARGS },
	 { (char *)"PropertyXml___str__", _wrap_PropertyXml___str__, METH_VARARGS },
	 { (char *)"delete_PropertyXml", _wrap_delete_PropertyXml, METH_VARARGS },
	 { (char *)"PropertyXml_swigregister", PropertyXml_swigregister, METH_VARARGS },
	 { (char *)"ClassXml_clsName_set", _wrap_ClassXml_clsName_set, METH_VARARGS },
	 { (char *)"ClassXml_clsName_get", _wrap_ClassXml_clsName_get, METH_VARARGS },
	 { (char *)"ClassXml_superClass_set", _wrap_ClassXml_superClass_set, METH_VARARGS },
	 { (char *)"ClassXml_superClass_get", _wrap_ClassXml_superClass_get, METH_VARARGS },
	 { (char *)"ClassXml_getProperties", _wrap_ClassXml_getProperties, METH_VARARGS },
	 { (char *)"ClassXml_getQualifiers", _wrap_ClassXml_getQualifiers, METH_VARARGS },
	 { (char *)"ClassXml_getKeys", _wrap_ClassXml_getKeys, METH_VARARGS },
	 { (char *)"ClassXml_addQualifier", _wrap_ClassXml_addQualifier, METH_VARARGS },
	 { (char *)"ClassXml_addProperty", _wrap_ClassXml_addProperty, METH_VARARGS },
	 { (char *)"ClassXml_addMethod", _wrap_ClassXml_addMethod, METH_VARARGS },
	 { (char *)"ClassXml_toStringBuffer", _wrap_ClassXml_toStringBuffer, METH_VARARGS },
	 { (char *)"ClassXml_keysOk", _wrap_ClassXml_keysOk, METH_VARARGS },
	 { (char *)"delete_ClassXml", _wrap_delete_ClassXml, METH_VARARGS },
	 { (char *)"ClassXml_swigregister", ClassXml_swigregister, METH_VARARGS },
	 { (char *)"delete_ClassesXml", _wrap_delete_ClassesXml, METH_VARARGS },
	 { (char *)"ClassesXml_swigregister", ClassesXml_swigregister, METH_VARARGS },
	 { (char *)"InstanceXml_propagateKeyFlags", _wrap_InstanceXml_propagateKeyFlags, METH_VARARGS },
	 { (char *)"InstanceXml_getProperties", _wrap_InstanceXml_getProperties, METH_VARARGS },
	 { (char *)"InstanceXml_getQualifiers", _wrap_InstanceXml_getQualifiers, METH_VARARGS },
	 { (char *)"InstanceXml_addQualifier", _wrap_InstanceXml_addQualifier, METH_VARARGS },
	 { (char *)"InstanceXml_addProperty", _wrap_InstanceXml_addProperty, METH_VARARGS },
	 { (char *)"InstanceXml_toStringBuffer", _wrap_InstanceXml_toStringBuffer, METH_VARARGS },
	 { (char *)"delete_InstanceXml", _wrap_delete_InstanceXml, METH_VARARGS },
	 { (char *)"InstanceXml_swigregister", InstanceXml_swigregister, METH_VARARGS },
	 { (char *)"NamedInstanceXml_instname_set", _wrap_NamedInstanceXml_instname_set, METH_VARARGS },
	 { (char *)"NamedInstanceXml_instname_get", _wrap_NamedInstanceXml_instname_get, METH_VARARGS },
	 { (char *)"NamedInstanceXml_inst_set", _wrap_NamedInstanceXml_inst_set, METH_VARARGS },
	 { (char *)"NamedInstanceXml_inst_get", _wrap_NamedInstanceXml_inst_get, METH_VARARGS },
	 { (char *)"delete_NamedInstanceXml", _wrap_delete_NamedInstanceXml, METH_VARARGS },
	 { (char *)"NamedInstanceXml_swigregister", NamedInstanceXml_swigregister, METH_VARARGS },
	 { (char *)"delete_InstancesXml", _wrap_delete_InstancesXml, METH_VARARGS },
	 { (char *)"InstancesXml_swigregister", InstancesXml_swigregister, METH_VARARGS },
	 { (char *)"ObjectWithPathXml_ip_set", _wrap_ObjectWithPathXml_ip_set, METH_VARARGS },
	 { (char *)"ObjectWithPathXml_ip_get", _wrap_ObjectWithPathXml_ip_get, METH_VARARGS },
	 { (char *)"ObjectWithPathXml_inst_set", _wrap_ObjectWithPathXml_inst_set, METH_VARARGS },
	 { (char *)"ObjectWithPathXml_inst_get", _wrap_ObjectWithPathXml_inst_get, METH_VARARGS },
	 { (char *)"delete_ObjectWithPathXml", _wrap_delete_ObjectWithPathXml, METH_VARARGS },
	 { (char *)"ObjectWithPathXml_swigregister", ObjectWithPathXml_swigregister, METH_VARARGS },
	 { (char *)"ObjectsWithPathXml_ia_set", _wrap_ObjectsWithPathXml_ia_set, METH_VARARGS },
	 { (char *)"ObjectsWithPathXml_ia_get", _wrap_ObjectsWithPathXml_ia_get, METH_VARARGS },
	 { (char *)"ObjectsWithPathXml_ipa_set", _wrap_ObjectsWithPathXml_ipa_set, METH_VARARGS },
	 { (char *)"ObjectsWithPathXml_ipa_get", _wrap_ObjectsWithPathXml_ipa_get, METH_VARARGS },
	 { (char *)"ObjectsWithPathXml_add", _wrap_ObjectsWithPathXml_add, METH_VARARGS },
	 { (char *)"ObjectsWithPathXml_getName", _wrap_ObjectsWithPathXml_getName, METH_VARARGS },
	 { (char *)"ObjectsWithPathXml_getInst", _wrap_ObjectsWithPathXml_getInst, METH_VARARGS },
	 { (char *)"ObjectsWithPathXml_size", _wrap_ObjectsWithPathXml_size, METH_VARARGS },
	 { (char *)"delete_ObjectsWithPathXml", _wrap_delete_ObjectsWithPathXml, METH_VARARGS },
	 { (char *)"ObjectsWithPathXml_swigregister", ObjectsWithPathXml_swigregister, METH_VARARGS },
	 { (char *)"NamedInstancesXml_ia_set", _wrap_NamedInstancesXml_ia_set, METH_VARARGS },
	 { (char *)"NamedInstancesXml_ia_get", _wrap_NamedInstancesXml_ia_get, METH_VARARGS },
	 { (char *)"NamedInstancesXml_ina_set", _wrap_NamedInstancesXml_ina_set, METH_VARARGS },
	 { (char *)"NamedInstancesXml_ina_get", _wrap_NamedInstancesXml_ina_get, METH_VARARGS },
	 { (char *)"NamedInstancesXml_add", _wrap_NamedInstancesXml_add, METH_VARARGS },
	 { (char *)"NamedInstancesXml_getName", _wrap_NamedInstancesXml_getName, METH_VARARGS },
	 { (char *)"NamedInstancesXml_getInst", _wrap_NamedInstancesXml_getInst, METH_VARARGS },
	 { (char *)"NamedInstancesXml___len__", _wrap_NamedInstancesXml___len__, METH_VARARGS },
	 { (char *)"delete_NamedInstancesXml", _wrap_delete_NamedInstancesXml, METH_VARARGS },
	 { (char *)"NamedInstancesXml_swigregister", NamedInstancesXml_swigregister, METH_VARARGS },
	 { (char *)"ClassNameXml_toStringBuffer", _wrap_ClassNameXml_toStringBuffer, METH_VARARGS },
	 { (char *)"delete_ClassNameXml", _wrap_delete_ClassNameXml, METH_VARARGS },
	 { (char *)"ClassNameXml_swigregister", ClassNameXml_swigregister, METH_VARARGS },
	 { (char *)"delete_ClassNamesXml", _wrap_delete_ClassNamesXml, METH_VARARGS },
	 { (char *)"ClassNamesXml_swigregister", ClassNamesXml_swigregister, METH_VARARGS },
	 { (char *)"new_IReturnvalueXml", _wrap_new_IReturnvalueXml, METH_VARARGS },
	 { (char *)"IReturnvalueXml_getReturnData", _wrap_IReturnvalueXml_getReturnData, METH_VARARGS },
	 { (char *)"delete_IReturnvalueXml", _wrap_delete_IReturnvalueXml, METH_VARARGS },
	 { (char *)"IReturnvalueXml_swigregister", IReturnvalueXml_swigregister, METH_VARARGS },
	 { (char *)"new_IMethodresponseXml", _wrap_new_IMethodresponseXml, METH_VARARGS },
	 { (char *)"IMethodresponseXml_getReturnData", _wrap_IMethodresponseXml_getReturnData, METH_VARARGS },
	 { (char *)"delete_IMethodresponseXml", _wrap_delete_IMethodresponseXml, METH_VARARGS },
	 { (char *)"IMethodresponseXml_swigregister", IMethodresponseXml_swigregister, METH_VARARGS },
	 { (char *)"new_SimplerspXml", _wrap_new_SimplerspXml, METH_VARARGS },
	 { (char *)"SimplerspXml_getReturnData", _wrap_SimplerspXml_getReturnData, METH_VARARGS },
	 { (char *)"delete_SimplerspXml", _wrap_delete_SimplerspXml, METH_VARARGS },
	 { (char *)"SimplerspXml_swigregister", SimplerspXml_swigregister, METH_VARARGS },
	 { (char *)"new_MessageXml", _wrap_new_MessageXml, METH_VARARGS },
	 { (char *)"MessageXml_getResponse", _wrap_MessageXml_getResponse, METH_VARARGS },
	 { (char *)"delete_MessageXml", _wrap_delete_MessageXml, METH_VARARGS },
	 { (char *)"MessageXml_swigregister", MessageXml_swigregister, METH_VARARGS },
	 { (char *)"new_CimXml", _wrap_new_CimXml, METH_VARARGS },
	 { (char *)"CimXml_getResponse", _wrap_CimXml_getResponse, METH_VARARGS },
	 { (char *)"delete_CimXml", _wrap_delete_CimXml, METH_VARARGS },
	 { (char *)"CimXml_swigregister", CimXml_swigregister, METH_VARARGS },
	 { (char *)"URL_host_set", _wrap_URL_host_set, METH_VARARGS },
	 { (char *)"URL_host_get", _wrap_URL_host_get, METH_VARARGS },
	 { (char *)"URL_port_set", _wrap_URL_port_set, METH_VARARGS },
	 { (char *)"URL_port_get", _wrap_URL_port_get, METH_VARARGS },
	 { (char *)"URL_cName_set", _wrap_URL_cName_set, METH_VARARGS },
	 { (char *)"URL_cName_get", _wrap_URL_cName_get, METH_VARARGS },
	 { (char *)"URL_user_set", _wrap_URL_user_set, METH_VARARGS },
	 { (char *)"URL_user_get", _wrap_URL_user_get, METH_VARARGS },
	 { (char *)"URL_password_set", _wrap_URL_password_set, METH_VARARGS },
	 { (char *)"URL_password_get", _wrap_URL_password_get, METH_VARARGS },
	 { (char *)"URL_ns_set", _wrap_URL_ns_set, METH_VARARGS },
	 { (char *)"URL_ns_get", _wrap_URL_ns_get, METH_VARARGS },
	 { (char *)"URL_keys_set", _wrap_URL_keys_set, METH_VARARGS },
	 { (char *)"URL_keys_get", _wrap_URL_keys_get, METH_VARARGS },
	 { (char *)"new_URL", _wrap_new_URL, METH_VARARGS },
	 { (char *)"URL_resolveIndirection", _wrap_URL_resolveIndirection, METH_VARARGS },
	 { (char *)"URL_refLookAhead", _wrap_URL_refLookAhead, METH_VARARGS },
	 { (char *)"URL_toStringBuffer", _wrap_URL_toStringBuffer, METH_VARARGS },
	 { (char *)"URL___str__", _wrap_URL___str__, METH_VARARGS },
	 { (char *)"delete_URL", _wrap_delete_URL, METH_VARARGS },
	 { (char *)"URL_swigregister", URL_swigregister, METH_VARARGS },
	 { (char *)"delete_Cimom", _wrap_delete_Cimom, METH_VARARGS },
	 { (char *)"Cimom_getClass", _wrap_Cimom_getClass, METH_VARARGS },
	 { (char *)"Cimom_getClass2str", _wrap_Cimom_getClass2str, METH_VARARGS },
	 { (char *)"Cimom_testInst", _wrap_Cimom_testInst, METH_VARARGS },
	 { (char *)"Cimom_getInstance", _wrap_Cimom_getInstance, METH_VARARGS },
	 { (char *)"Cimom_enumInstances", _wrap_Cimom_enumInstances, METH_VARARGS },
	 { (char *)"Cimom_enumInstances2str", _wrap_Cimom_enumInstances2str, METH_VARARGS },
	 { (char *)"Cimom_createInstance", _wrap_Cimom_createInstance, METH_VARARGS },
	 { (char *)"Cimom_enumInstanceNames", _wrap_Cimom_enumInstanceNames, METH_VARARGS },
	 { (char *)"Cimom_enumClasses", _wrap_Cimom_enumClasses, METH_VARARGS },
	 { (char *)"Cimom_enumClassNames", _wrap_Cimom_enumClassNames, METH_VARARGS },
	 { (char *)"Cimom_modifyInstance", _wrap_Cimom_modifyInstance, METH_VARARGS },
	 { (char *)"Cimom_associatorNames", _wrap_Cimom_associatorNames, METH_VARARGS },
	 { (char *)"Cimom_associators", _wrap_Cimom_associators, METH_VARARGS },
	 { (char *)"Cimom_associators2str", _wrap_Cimom_associators2str, METH_VARARGS },
	 { (char *)"Cimom_referenceNames", _wrap_Cimom_referenceNames, METH_VARARGS },
	 { (char *)"Cimom_references", _wrap_Cimom_references, METH_VARARGS },
	 { (char *)"Cimom_references2str", _wrap_Cimom_references2str, METH_VARARGS },
	 { (char *)"Cimom_getProperty", _wrap_Cimom_getProperty, METH_VARARGS },
	 { (char *)"Cimom_setProperty", _wrap_Cimom_setProperty, METH_VARARGS },
	 { (char *)"Cimom_deleteClass", _wrap_Cimom_deleteClass, METH_VARARGS },
	 { (char *)"Cimom_deleteInstance", _wrap_Cimom_deleteInstance, METH_VARARGS },
	 { (char *)"Cimom_unescapeXml", _wrap_Cimom_unescapeXml, METH_VARARGS },
	 { (char *)"Cimom_swigregister", Cimom_swigregister, METH_VARARGS },
	 { (char *)"new_CimomGhttp", _wrap_new_CimomGhttp, METH_VARARGS },
	 { (char *)"delete_CimomGhttp", _wrap_delete_CimomGhttp, METH_VARARGS },
	 { (char *)"CimomGhttp_swigregister", CimomGhttp_swigregister, METH_VARARGS },
	 { NULL, NULL }
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static void *_p_ArrayXmlTKeyBindingXml_tTo_p_std__vectorTKeyBindingXml_t(void *x) {
    return (void *)((std::vector<KeyBindingXml > *)  ((ArrayXml<KeyBindingXml > *) x));
}
static void *_p_StringArrayTo_p_std__vectorTstring_t(void *x) {
    return (void *)((std::vector<string > *)  ((StringArray *) x));
}
static void *_p_ArrayXmlTNamedInstanceXml_tTo_p_std__vectorTNamedInstanceXml_t(void *x) {
    return (void *)((std::vector<NamedInstanceXml > *)  ((ArrayXml<NamedInstanceXml > *) x));
}
static void *_p_ArrayXmlTClassNameXml_tTo_p_std__vectorTClassNameXml_t(void *x) {
    return (void *)((std::vector<ClassNameXml > *)  ((ArrayXml<ClassNameXml > *) x));
}
static void *_p_ClassNamesXmlTo_p_std__vectorTClassNameXml_t(void *x) {
    return (void *)((std::vector<ClassNameXml > *) (ArrayXml<ClassNameXml > *) ((ClassNamesXml *) x));
}
static void *_p_InstancesXmlTo_p_std__vectorTInstanceXml_t(void *x) {
    return (void *)((std::vector<InstanceXml > *) (ArrayXml<InstanceXml > *) ((InstancesXml *) x));
}
static void *_p_ArrayXmlTInstanceXml_tTo_p_std__vectorTInstanceXml_t(void *x) {
    return (void *)((std::vector<InstanceXml > *)  ((ArrayXml<InstanceXml > *) x));
}
static void *_p_ArrayXmlTInstanceNameXml_tTo_p_std__vectorTInstanceNameXml_t(void *x) {
    return (void *)((std::vector<InstanceNameXml > *)  ((ArrayXml<InstanceNameXml > *) x));
}
static void *_p_InstanceNamesXmlTo_p_std__vectorTInstanceNameXml_t(void *x) {
    return (void *)((std::vector<InstanceNameXml > *) (ArrayXml<InstanceNameXml > *) ((InstanceNamesXml *) x));
}
static void *_p_InstanceNamesXmlTo_p_ArrayXmlTInstanceNameXml_t(void *x) {
    return (void *)((ArrayXml<InstanceNameXml > *)  ((InstanceNamesXml *) x));
}
static void *_p_LocalNameSpacePathXmlTo_p_ArrayXmlTNameSpaceXml_t(void *x) {
    return (void *)((ArrayXml<NameSpaceXml > *)  ((LocalNameSpacePathXml *) x));
}
static void *_p_ArrayXmlTNameSpaceXml_tTo_p_std__vectorTNameSpaceXml_t(void *x) {
    return (void *)((std::vector<NameSpaceXml > *)  ((ArrayXml<NameSpaceXml > *) x));
}
static void *_p_LocalNameSpacePathXmlTo_p_std__vectorTNameSpaceXml_t(void *x) {
    return (void *)((std::vector<NameSpaceXml > *) (ArrayXml<NameSpaceXml > *) ((LocalNameSpacePathXml *) x));
}
static void *_p_InstancesXmlTo_p_ArrayXmlTInstanceXml_t(void *x) {
    return (void *)((ArrayXml<InstanceXml > *)  ((InstancesXml *) x));
}
static void *_p_ClassNamesXmlTo_p_ArrayXmlTClassNameXml_t(void *x) {
    return (void *)((ArrayXml<ClassNameXml > *)  ((ClassNamesXml *) x));
}
static void *_p_ArrayXmlTClassXml_tTo_p_std__vectorTClassXml_t(void *x) {
    return (void *)((std::vector<ClassXml > *)  ((ArrayXml<ClassXml > *) x));
}
static void *_p_ClassesXmlTo_p_std__vectorTClassXml_t(void *x) {
    return (void *)((std::vector<ClassXml > *) (ArrayXml<ClassXml > *) ((ClassesXml *) x));
}
static void *_p_ClassesXmlTo_p_ArrayXmlTClassXml_t(void *x) {
    return (void *)((ArrayXml<ClassXml > *)  ((ClassesXml *) x));
}
static void *_p_InstanceNameXmlTo_p_RetValXml(void *x) {
    return (void *)((RetValXml *)  ((InstanceNameXml *) x));
}
static void *_p_InstancesXmlTo_p_RetValXml(void *x) {
    return (void *)((RetValXml *)  ((InstancesXml *) x));
}
static void *_p_NamedInstancesXmlTo_p_RetValXml(void *x) {
    return (void *)((RetValXml *)  ((NamedInstancesXml *) x));
}
static void *_p_ClassNameXmlTo_p_RetValXml(void *x) {
    return (void *)((RetValXml *)  ((ClassNameXml *) x));
}
static void *_p_ClassXmlTo_p_RetValXml(void *x) {
    return (void *)((RetValXml *)  ((ClassXml *) x));
}
static void *_p_ClassesXmlTo_p_RetValXml(void *x) {
    return (void *)((RetValXml *)  ((ClassesXml *) x));
}
static void *_p_ObjectWithPathXmlTo_p_RetValXml(void *x) {
    return (void *)((RetValXml *)  ((ObjectWithPathXml *) x));
}
static void *_p_ObjectsWithPathXmlTo_p_RetValXml(void *x) {
    return (void *)((RetValXml *)  ((ObjectsWithPathXml *) x));
}
static void *_p_ValueXmlTo_p_RetValXml(void *x) {
    return (void *)((RetValXml *)  ((ValueXml *) x));
}
static void *_p_InstanceNamesXmlTo_p_RetValXml(void *x) {
    return (void *)((RetValXml *)  ((InstanceNamesXml *) x));
}
static void *_p_ClassNamesXmlTo_p_RetValXml(void *x) {
    return (void *)((RetValXml *)  ((ClassNamesXml *) x));
}
static void *_p_InstanceXmlTo_p_RetValXml(void *x) {
    return (void *)((RetValXml *)  ((InstanceXml *) x));
}
static void *_p_NamedInstanceXmlTo_p_RetValXml(void *x) {
    return (void *)((RetValXml *)  ((NamedInstanceXml *) x));
}
static void *_p_URLExceptionTo_p_XmlException(void *x) {
    return (void *)((XmlException *)  ((URLException *) x));
}
static void *_p_ParseExceptionTo_p_XmlException(void *x) {
    return (void *)((XmlException *)  ((ParseException *) x));
}
static void *_p_HttpExceptionTo_p_XmlException(void *x) {
    return (void *)((XmlException *)  ((HttpException *) x));
}
static void *_p_CmdExceptionTo_p_XmlException(void *x) {
    return (void *)((XmlException *)  ((CmdException *) x));
}
static void *_p_ErrorXmlTo_p_XmlException(void *x) {
    return (void *)((XmlException *)  ((ErrorXml *) x));
}
static void *_p_ArrayXmlTPropertyXml_tTo_p_std__vectorTPropertyXml_t(void *x) {
    return (void *)((std::vector<PropertyXml > *)  ((ArrayXml<PropertyXml > *) x));
}
static void *_p_ArrayXmlTObjectWithPathXml_tTo_p_std__vectorTObjectWithPathXml_t(void *x) {
    return (void *)((std::vector<ObjectWithPathXml > *)  ((ArrayXml<ObjectWithPathXml > *) x));
}
static void *_p_CimomGhttpTo_p_Cimom(void *x) {
    return (void *)((Cimom *)  ((CimomGhttp *) x));
}
static swig_type_info _swigt__p_KeyBindingXml[] = {{"_p_KeyBindingXml", 0, "KeyBindingXml *", 0},{"_p_KeyBindingXml"},{0}};
static swig_type_info _swigt__p_DoesNotExist[] = {{"_p_DoesNotExist", 0, "DoesNotExist *", 0},{"_p_DoesNotExist"},{0}};
static swig_type_info _swigt__p_NameSpaceXml[] = {{"_p_NameSpaceXml", 0, "NameSpaceXml *", 0},{"_p_NameSpaceXml"},{0}};
static swig_type_info _swigt__p_CimomGhttp[] = {{"_p_CimomGhttp", 0, "CimomGhttp *", 0},{"_p_CimomGhttp"},{0}};
static swig_type_info _swigt__p_AList[] = {{"_p_AList", 0, "AList *", 0},{"_p_AList"},{0}};
static swig_type_info _swigt__p_MethodXml[] = {{"_p_MethodXml", 0, "MethodXml *", 0},{"_p_MethodXml"},{0}};
static swig_type_info _swigt__p_XmlBuffer[] = {{"_p_XmlBuffer", 0, "XmlBuffer *", 0},{"_p_XmlBuffer"},{0}};
static swig_type_info _swigt__p_PropertyArray[] = {{"_p_PropertyArray", 0, "PropertyArray *", 0},{"_p_PropertyArray"},{"_p_ArrayXmlTPropertyXml_t"},{0}};
static swig_type_info _swigt__p_ClassNameXml[] = {{"_p_ClassNameXml", 0, "ClassNameXml *", 0},{"_p_ClassNameXml"},{0}};
static swig_type_info _swigt__p_InstanceNameXml[] = {{"_p_InstanceNameXml", 0, "InstanceNameXml *", 0},{"_p_InstanceNameXml"},{0}};
static swig_type_info _swigt__p_RetValXml[] = {{"_p_RetValXml", 0, "RetValXml *", 0},{"_p_InstanceNameXml", _p_InstanceNameXmlTo_p_RetValXml},{"_p_ClassNameXml", _p_ClassNameXmlTo_p_RetValXml},{"_p_ValueXml", _p_ValueXmlTo_p_RetValXml},{"_p_ClassXml", _p_ClassXmlTo_p_RetValXml},{"_p_InstancesXml", _p_InstancesXmlTo_p_RetValXml},{"_p_NamedInstancesXml", _p_NamedInstancesXmlTo_p_RetValXml},{"_p_RetValXml"},{"_p_ObjectWithPathXml", _p_ObjectWithPathXmlTo_p_RetValXml},{"_p_ObjectsWithPathXml", _p_ObjectsWithPathXmlTo_p_RetValXml},{"_p_ClassesXml", _p_ClassesXmlTo_p_RetValXml},{"_p_InstanceXml", _p_InstanceXmlTo_p_RetValXml},{"_p_NamedInstanceXml", _p_NamedInstanceXmlTo_p_RetValXml},{"_p_InstanceNamesXml", _p_InstanceNamesXmlTo_p_RetValXml},{"_p_ClassNamesXml", _p_ClassNamesXmlTo_p_RetValXml},{0}};
static swig_type_info _swigt__p_InstancePathArray[] = {{"_p_InstancePathArray", 0, "InstancePathArray *", 0},{"_p_InstancePathArray"},{0}};
static swig_type_info _swigt__p_ClassesXml[] = {{"_p_ClassesXml", 0, "ClassesXml *", 0},{"_p_ClassesXml"},{0}};
static swig_type_info _swigt__p_std__vectorTPropertyXml_t[] = {{"_p_std__vectorTPropertyXml_t", 0, "std::vector<PropertyXml > *", 0},{"_p_PropertyArray", _p_ArrayXmlTPropertyXml_tTo_p_std__vectorTPropertyXml_t},{"_p_std__vectorTPropertyXml_t"},{"_p_ArrayXmlTPropertyXml_t", _p_ArrayXmlTPropertyXml_tTo_p_std__vectorTPropertyXml_t},{0}};
static swig_type_info _swigt__p_ArrayXmlTPropertyXml_t[] = {{"_p_ArrayXmlTPropertyXml_t", 0, "ArrayXml<PropertyXml > *", 0},{"_p_PropertyArray"},{"_p_ArrayXmlTPropertyXml_t"},{0}};
static swig_type_info _swigt__p_ArrayIteratorTPropertyXml_t[] = {{"_p_ArrayIteratorTPropertyXml_t", 0, "ArrayIterator<PropertyXml > *", 0},{"_p_ArrayIteratorTPropertyXml_t"},{0}};
static swig_type_info _swigt__p_ArrayIteratorTObjectWithPathXml_t[] = {{"_p_ArrayIteratorTObjectWithPathXml_t", 0, "ArrayIterator<ObjectWithPathXml > *", 0},{"_p_ArrayIteratorTObjectWithPathXml_t"},{0}};
static swig_type_info _swigt__p_ArrayXmlTObjectWithPathXml_t[] = {{"_p_ArrayXmlTObjectWithPathXml_t", 0, "ArrayXml<ObjectWithPathXml > *", 0},{"_p_ArrayXmlTObjectWithPathXml_t"},{0}};
static swig_type_info _swigt__p_std__vectorTObjectWithPathXml_t[] = {{"_p_std__vectorTObjectWithPathXml_t", 0, "std::vector<ObjectWithPathXml > *", 0},{"_p_std__vectorTObjectWithPathXml_t"},{"_p_ArrayXmlTObjectWithPathXml_t", _p_ArrayXmlTObjectWithPathXml_tTo_p_std__vectorTObjectWithPathXml_t},{0}};
static swig_type_info _swigt__p_Cimom[] = {{"_p_Cimom", 0, "Cimom *", 0},{"_p_Cimom"},{"_p_CimomGhttp", _p_CimomGhttpTo_p_Cimom},{0}};
static swig_type_info _swigt__p_URL[] = {{"_p_URL", 0, "URL *", 0},{"_p_URL"},{0}};
static swig_type_info _swigt__p_CimXml[] = {{"_p_CimXml", 0, "CimXml *", 0},{"_p_CimXml"},{0}};
static swig_type_info _swigt__p_ObjectsWithPathXml[] = {{"_p_ObjectsWithPathXml", 0, "ObjectsWithPathXml *", 0},{"_p_ObjectsWithPathXml"},{0}};
static swig_type_info _swigt__p_InstancePathXml[] = {{"_p_InstancePathXml", 0, "InstancePathXml *", 0},{"_p_InstancePathXml"},{0}};
static swig_type_info _swigt__p_NameSpacePathXml[] = {{"_p_NameSpacePathXml", 0, "NameSpacePathXml *", 0},{"_p_NameSpacePathXml"},{0}};
static swig_type_info _swigt__p_LocalNameSpacePathXml[] = {{"_p_LocalNameSpacePathXml", 0, "LocalNameSpacePathXml *", 0},{"_p_LocalNameSpacePathXml"},{0}};
static swig_type_info _swigt__p_ObjectWithPathXml[] = {{"_p_ObjectWithPathXml", 0, "ObjectWithPathXml *", 0},{"_p_ObjectWithPathXml"},{0}};
static swig_type_info _swigt__p_InstanceNamesXml[] = {{"_p_InstanceNamesXml", 0, "InstanceNamesXml *", 0},{"_p_InstanceNamesXml"},{0}};
static swig_type_info _swigt__p_ClassNamesXml[] = {{"_p_ClassNamesXml", 0, "ClassNamesXml *", 0},{"_p_ClassNamesXml"},{0}};
static swig_type_info _swigt__p_XmlAttr[] = {{"_p_XmlAttr", 0, "XmlAttr *", 0},{"_p_XmlAttr"},{0}};
static swig_type_info _swigt__p_CmdException[] = {{"_p_CmdException", 0, "CmdException *", 0},{"_p_CmdException"},{0}};
static swig_type_info _swigt__p_HttpException[] = {{"_p_HttpException", 0, "HttpException *", 0},{"_p_HttpException"},{0}};
static swig_type_info _swigt__p_ParseException[] = {{"_p_ParseException", 0, "ParseException *", 0},{"_p_ParseException"},{0}};
static swig_type_info _swigt__p_URLException[] = {{"_p_URLException", 0, "URLException *", 0},{"_p_URLException"},{0}};
static swig_type_info _swigt__p_XmlException[] = {{"_p_XmlException", 0, "XmlException *", 0},{"_p_XmlException"},{"_p_URLException", _p_URLExceptionTo_p_XmlException},{"_p_ParseException", _p_ParseExceptionTo_p_XmlException},{"_p_HttpException", _p_HttpExceptionTo_p_XmlException},{"_p_CmdException", _p_CmdExceptionTo_p_XmlException},{"_p_ErrorXml", _p_ErrorXmlTo_p_XmlException},{0}};
static swig_type_info _swigt__p_KeyValueXml[] = {{"_p_KeyValueXml", 0, "KeyValueXml *", 0},{"_p_KeyValueXml"},{0}};
static swig_type_info _swigt__p_ValueXml[] = {{"_p_ValueXml", 0, "ValueXml *", 0},{"_p_ValueXml"},{0}};
static swig_type_info _swigt__p_IReturnvalueXml[] = {{"_p_IReturnvalueXml", 0, "IReturnvalueXml *", 0},{"_p_IReturnvalueXml"},{0}};
static swig_type_info _swigt__p_InstancesXml[] = {{"_p_InstancesXml", 0, "InstancesXml *", 0},{"_p_InstancesXml"},{0}};
static swig_type_info _swigt__p_NamedInstancesXml[] = {{"_p_NamedInstancesXml", 0, "NamedInstancesXml *", 0},{"_p_NamedInstancesXml"},{0}};
static swig_type_info _swigt__p_KeyBindingArray[] = {{"_p_KeyBindingArray", 0, "KeyBindingArray &", 0},{"_p_ArrayXmlTKeyBindingXml_t"},{"_p_KeyBindingArray"},{0}};
static swig_type_info _swigt__p_StringArray[] = {{"_p_StringArray", 0, "StringArray *", 0},{"_p_StringArray"},{0}};
static swig_type_info _swigt__p_ErrorXml[] = {{"_p_ErrorXml", 0, "ErrorXml *", 0},{"_p_ErrorXml"},{0}};
static swig_type_info _swigt__p_IMethodresponseXml[] = {{"_p_IMethodresponseXml", 0, "IMethodresponseXml *", 0},{"_p_IMethodresponseXml"},{0}};
static swig_type_info _swigt__p_InstanceArray[] = {{"_p_InstanceArray", 0, "InstanceArray *", 0},{"_p_ArrayXmlTInstanceXml_t"},{"_p_InstancesXml", _p_InstancesXmlTo_p_ArrayXmlTInstanceXml_t},{"_p_InstanceArray"},{0}};
static swig_type_info _swigt__p_ArrayIteratorTKeyBindingXml_t[] = {{"_p_ArrayIteratorTKeyBindingXml_t", 0, "ArrayIterator<KeyBindingXml > *", 0},{"_p_ArrayIteratorTKeyBindingXml_t"},{0}};
static swig_type_info _swigt__p_ArrayXmlTKeyBindingXml_t[] = {{"_p_ArrayXmlTKeyBindingXml_t", 0, "ArrayXml<KeyBindingXml > *", 0},{"_p_ArrayXmlTKeyBindingXml_t"},{"_p_KeyBindingArray"},{0}};
static swig_type_info _swigt__p_std__vectorTKeyBindingXml_t[] = {{"_p_std__vectorTKeyBindingXml_t", 0, "std::vector<KeyBindingXml > *", 0},{"_p_std__vectorTKeyBindingXml_t"},{"_p_ArrayXmlTKeyBindingXml_t", _p_ArrayXmlTKeyBindingXml_tTo_p_std__vectorTKeyBindingXml_t},{"_p_KeyBindingArray", _p_ArrayXmlTKeyBindingXml_tTo_p_std__vectorTKeyBindingXml_t},{0}};
static swig_type_info _swigt__p_InstanceNameArray[] = {{"_p_InstanceNameArray", 0, "InstanceNameArray *", 0},{"_p_ArrayXmlTInstanceNameXml_t"},{"_p_InstanceNameArray"},{"_p_InstanceNamesXml", _p_InstanceNamesXmlTo_p_ArrayXmlTInstanceNameXml_t},{0}};
static swig_type_info _swigt__p_OptionTstring_t[] = {{"_p_OptionTstring_t", 0, "Option<string > *", 0},{"_p_OptionTstring_t"},{0}};
static swig_type_info _swigt__p_std__vectorTstring_t[] = {{"_p_std__vectorTstring_t", 0, "std::vector<string > *", 0},{"_p_std__vectorTstring_t"},{"_p_StringArray", _p_StringArrayTo_p_std__vectorTstring_t},{0}};
static swig_type_info _swigt__p_QualifierXml[] = {{"_p_QualifierXml", 0, "QualifierXml *", 0},{"_p_QualifierXml"},{0}};
static swig_type_info _swigt__p_p_char[] = {{"_p_p_char", 0, "char **", 0},{"_p_p_char"},{0}};
static swig_type_info _swigt__p_OptionTValueXml_t[] = {{"_p_OptionTValueXml_t", 0, "Option<ValueXml > *", 0},{"_p_OptionTValueXml_t"},{0}};
static swig_type_info _swigt__p_ArrayIteratorTNamedInstanceXml_t[] = {{"_p_ArrayIteratorTNamedInstanceXml_t", 0, "ArrayIterator<NamedInstanceXml > *", 0},{"_p_ArrayIteratorTNamedInstanceXml_t"},{0}};
static swig_type_info _swigt__p_ArrayXmlTNamedInstanceXml_t[] = {{"_p_ArrayXmlTNamedInstanceXml_t", 0, "ArrayXml<NamedInstanceXml > *", 0},{"_p_ArrayXmlTNamedInstanceXml_t"},{0}};
static swig_type_info _swigt__p_ArrayIteratorTClassNameXml_t[] = {{"_p_ArrayIteratorTClassNameXml_t", 0, "ArrayIterator<ClassNameXml > *", 0},{"_p_ArrayIteratorTClassNameXml_t"},{0}};
static swig_type_info _swigt__p_ArrayXmlTInstanceNameXml_t[] = {{"_p_ArrayXmlTInstanceNameXml_t", 0, "ArrayXml<InstanceNameXml > *", 0},{"_p_ArrayXmlTInstanceNameXml_t"},{"_p_InstanceNameArray"},{"_p_InstanceNamesXml", _p_InstanceNamesXmlTo_p_ArrayXmlTInstanceNameXml_t},{0}};
static swig_type_info _swigt__p_ArrayXmlTNameSpaceXml_t[] = {{"_p_ArrayXmlTNameSpaceXml_t", 0, "ArrayXml<NameSpaceXml > *", 0},{"_p_ArrayXmlTNameSpaceXml_t"},{"_p_LocalNameSpacePathXml", _p_LocalNameSpacePathXmlTo_p_ArrayXmlTNameSpaceXml_t},{0}};
static swig_type_info _swigt__p_std__vectorTNamedInstanceXml_t[] = {{"_p_std__vectorTNamedInstanceXml_t", 0, "std::vector<NamedInstanceXml > *", 0},{"_p_std__vectorTNamedInstanceXml_t"},{"_p_ArrayXmlTNamedInstanceXml_t", _p_ArrayXmlTNamedInstanceXml_tTo_p_std__vectorTNamedInstanceXml_t},{0}};
static swig_type_info _swigt__p_std__vectorTClassNameXml_t[] = {{"_p_std__vectorTClassNameXml_t", 0, "std::vector<ClassNameXml > *", 0},{"_p_std__vectorTClassNameXml_t"},{"_p_ArrayXmlTClassNameXml_t", _p_ArrayXmlTClassNameXml_tTo_p_std__vectorTClassNameXml_t},{"_p_ClassNamesXml", _p_ClassNamesXmlTo_p_std__vectorTClassNameXml_t},{0}};
static swig_type_info _swigt__p_std__vectorTInstanceXml_t[] = {{"_p_std__vectorTInstanceXml_t", 0, "std::vector<InstanceXml > *", 0},{"_p_std__vectorTInstanceXml_t"},{"_p_InstancesXml", _p_InstancesXmlTo_p_std__vectorTInstanceXml_t},{"_p_ArrayXmlTInstanceXml_t", _p_ArrayXmlTInstanceXml_tTo_p_std__vectorTInstanceXml_t},{"_p_InstanceArray"},{0}};
static swig_type_info _swigt__p_std__vectorTInstanceNameXml_t[] = {{"_p_std__vectorTInstanceNameXml_t", 0, "std::vector<InstanceNameXml > *", 0},{"_p_std__vectorTInstanceNameXml_t"},{"_p_ArrayXmlTInstanceNameXml_t", _p_ArrayXmlTInstanceNameXml_tTo_p_std__vectorTInstanceNameXml_t},{"_p_InstanceNameArray"},{"_p_InstanceNamesXml", _p_InstanceNamesXmlTo_p_std__vectorTInstanceNameXml_t},{0}};
static swig_type_info _swigt__p_std__vectorTNameSpaceXml_t[] = {{"_p_std__vectorTNameSpaceXml_t", 0, "std::vector<NameSpaceXml > *", 0},{"_p_std__vectorTNameSpaceXml_t"},{"_p_ArrayXmlTNameSpaceXml_t", _p_ArrayXmlTNameSpaceXml_tTo_p_std__vectorTNameSpaceXml_t},{"_p_LocalNameSpacePathXml", _p_LocalNameSpacePathXmlTo_p_std__vectorTNameSpaceXml_t},{0}};
static swig_type_info _swigt__p_ArrayXmlTInstanceXml_t[] = {{"_p_ArrayXmlTInstanceXml_t", 0, "ArrayXml<InstanceXml > *", 0},{"_p_ArrayXmlTInstanceXml_t"},{"_p_InstancesXml", _p_InstancesXmlTo_p_ArrayXmlTInstanceXml_t},{"_p_InstanceArray"},{0}};
static swig_type_info _swigt__p_ArrayXmlTClassNameXml_t[] = {{"_p_ArrayXmlTClassNameXml_t", 0, "ArrayXml<ClassNameXml > *", 0},{"_p_ArrayXmlTClassNameXml_t"},{"_p_ClassNamesXml", _p_ClassNamesXmlTo_p_ArrayXmlTClassNameXml_t},{0}};
static swig_type_info _swigt__p_ArrayIteratorTNameSpaceXml_t[] = {{"_p_ArrayIteratorTNameSpaceXml_t", 0, "ArrayIterator<NameSpaceXml > *", 0},{"_p_ArrayIteratorTNameSpaceXml_t"},{0}};
static swig_type_info _swigt__p_ArrayIteratorTInstanceNameXml_t[] = {{"_p_ArrayIteratorTInstanceNameXml_t", 0, "ArrayIterator<InstanceNameXml > *", 0},{"_p_ArrayIteratorTInstanceNameXml_t"},{0}};
static swig_type_info _swigt__p_ArrayIteratorTInstanceXml_t[] = {{"_p_ArrayIteratorTInstanceXml_t", 0, "ArrayIterator<InstanceXml > *", 0},{"_p_ArrayIteratorTInstanceXml_t"},{0}};
static swig_type_info _swigt__p_HostXml[] = {{"_p_HostXml", 0, "HostXml *", 0},{"_p_HostXml"},{0}};
static swig_type_info _swigt__p_ArrayIteratorTClassXml_t[] = {{"_p_ArrayIteratorTClassXml_t", 0, "ArrayIterator<ClassXml > *", 0},{"_p_ArrayIteratorTClassXml_t"},{0}};
static swig_type_info _swigt__p_std__vectorTClassXml_t[] = {{"_p_std__vectorTClassXml_t", 0, "std::vector<ClassXml > *", 0},{"_p_std__vectorTClassXml_t"},{"_p_ArrayXmlTClassXml_t", _p_ArrayXmlTClassXml_tTo_p_std__vectorTClassXml_t},{"_p_ClassesXml", _p_ClassesXmlTo_p_std__vectorTClassXml_t},{0}};
static swig_type_info _swigt__p_ArrayXmlTClassXml_t[] = {{"_p_ArrayXmlTClassXml_t", 0, "ArrayXml<ClassXml > *", 0},{"_p_ArrayXmlTClassXml_t"},{"_p_ClassesXml", _p_ClassesXmlTo_p_ArrayXmlTClassXml_t},{0}};
static swig_type_info _swigt__p_NamedInstanceXml[] = {{"_p_NamedInstanceXml", 0, "NamedInstanceXml *", 0},{"_p_NamedInstanceXml"},{0}};
static swig_type_info _swigt__p_InstanceXml[] = {{"_p_InstanceXml", 0, "InstanceXml *", 0},{"_p_InstanceXml"},{0}};
static swig_type_info _swigt__p_AVPs[] = {{"_p_AVPs", 0, "AVPs *", 0},{"_p_AVPs"},{0}};
static swig_type_info _swigt__p_AValue[] = {{"_p_AValue", 0, "AValue *", 0},{"_p_AValue"},{0}};
static swig_type_info _swigt__p_SimplerspXml[] = {{"_p_SimplerspXml", 0, "SimplerspXml *", 0},{"_p_SimplerspXml"},{0}};
static swig_type_info _swigt__p_string[] = {{"_p_string", 0, "string *", 0},{"_p_string"},{0}};
static swig_type_info _swigt__p_MessageXml[] = {{"_p_MessageXml", 0, "MessageXml *", 0},{"_p_MessageXml"},{0}};
static swig_type_info _swigt__p_ClassXml[] = {{"_p_ClassXml", 0, "ClassXml *", 0},{"_p_ClassXml"},{0}};
static swig_type_info _swigt__p_PropertyXml[] = {{"_p_PropertyXml", 0, "PropertyXml *", 0},{"_p_PropertyXml"},{0}};
static swig_type_info _swigt__p_XmlElement[] = {{"_p_XmlElement", 0, "XmlElement *", 0},{"_p_XmlElement"},{0}};
static swig_type_info _swigt__p_QualifierArray[] = {{"_p_QualifierArray", 0, "QualifierArray *", 0},{"_p_QualifierArray"},{0}};

static swig_type_info *swig_types_initial[] = {
_swigt__p_KeyBindingXml, 
_swigt__p_DoesNotExist, 
_swigt__p_NameSpaceXml, 
_swigt__p_CimomGhttp, 
_swigt__p_AList, 
_swigt__p_MethodXml, 
_swigt__p_XmlBuffer, 
_swigt__p_PropertyArray, 
_swigt__p_ClassNameXml, 
_swigt__p_InstanceNameXml, 
_swigt__p_RetValXml, 
_swigt__p_InstancePathArray, 
_swigt__p_ClassesXml, 
_swigt__p_std__vectorTPropertyXml_t, 
_swigt__p_ArrayXmlTPropertyXml_t, 
_swigt__p_ArrayIteratorTPropertyXml_t, 
_swigt__p_ArrayIteratorTObjectWithPathXml_t, 
_swigt__p_ArrayXmlTObjectWithPathXml_t, 
_swigt__p_std__vectorTObjectWithPathXml_t, 
_swigt__p_Cimom, 
_swigt__p_URL, 
_swigt__p_CimXml, 
_swigt__p_ObjectsWithPathXml, 
_swigt__p_InstancePathXml, 
_swigt__p_NameSpacePathXml, 
_swigt__p_LocalNameSpacePathXml, 
_swigt__p_ObjectWithPathXml, 
_swigt__p_InstanceNamesXml, 
_swigt__p_ClassNamesXml, 
_swigt__p_XmlAttr, 
_swigt__p_CmdException, 
_swigt__p_HttpException, 
_swigt__p_ParseException, 
_swigt__p_URLException, 
_swigt__p_XmlException, 
_swigt__p_KeyValueXml, 
_swigt__p_ValueXml, 
_swigt__p_IReturnvalueXml, 
_swigt__p_InstancesXml, 
_swigt__p_NamedInstancesXml, 
_swigt__p_KeyBindingArray, 
_swigt__p_StringArray, 
_swigt__p_ErrorXml, 
_swigt__p_IMethodresponseXml, 
_swigt__p_InstanceArray, 
_swigt__p_ArrayIteratorTKeyBindingXml_t, 
_swigt__p_ArrayXmlTKeyBindingXml_t, 
_swigt__p_std__vectorTKeyBindingXml_t, 
_swigt__p_InstanceNameArray, 
_swigt__p_OptionTstring_t, 
_swigt__p_std__vectorTstring_t, 
_swigt__p_QualifierXml, 
_swigt__p_p_char, 
_swigt__p_OptionTValueXml_t, 
_swigt__p_ArrayIteratorTNamedInstanceXml_t, 
_swigt__p_ArrayXmlTNamedInstanceXml_t, 
_swigt__p_ArrayIteratorTClassNameXml_t, 
_swigt__p_ArrayXmlTInstanceNameXml_t, 
_swigt__p_ArrayXmlTNameSpaceXml_t, 
_swigt__p_std__vectorTNamedInstanceXml_t, 
_swigt__p_std__vectorTClassNameXml_t, 
_swigt__p_std__vectorTInstanceXml_t, 
_swigt__p_std__vectorTInstanceNameXml_t, 
_swigt__p_std__vectorTNameSpaceXml_t, 
_swigt__p_ArrayXmlTInstanceXml_t, 
_swigt__p_ArrayXmlTClassNameXml_t, 
_swigt__p_ArrayIteratorTNameSpaceXml_t, 
_swigt__p_ArrayIteratorTInstanceNameXml_t, 
_swigt__p_ArrayIteratorTInstanceXml_t, 
_swigt__p_HostXml, 
_swigt__p_ArrayIteratorTClassXml_t, 
_swigt__p_std__vectorTClassXml_t, 
_swigt__p_ArrayXmlTClassXml_t, 
_swigt__p_NamedInstanceXml, 
_swigt__p_InstanceXml, 
_swigt__p_AVPs, 
_swigt__p_AValue, 
_swigt__p_SimplerspXml, 
_swigt__p_string, 
_swigt__p_MessageXml, 
_swigt__p_ClassXml, 
_swigt__p_PropertyXml, 
_swigt__p_XmlElement, 
_swigt__p_QualifierArray, 
0
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

static swig_const_info swig_const_table[] = {
{ SWIG_PY_INT,     (char *)"TypeNull", (long) 0, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"TypeInstance", (long) 1, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"TypeInstances", (long) 2, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"TypeClass", (long) 3, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"TypeInstanceName", (long) 4, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"TypeInstanceNames", (long) 5, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"TypeClassName", (long) 6, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"TypeClassNames", (long) 7, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"TypeClasses", (long) 8, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"TypeNamedInstance", (long) 9, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"TypeNamedInstances", (long) 10, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"TypeObjectWithPath", (long) 11, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"TypeObjectsWithPath", (long) 12, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"TypeRValue", (long) 13, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"TypeProperty", (long) 1, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"TypePropertyRef", (long) 2, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"TypePropertyArray", (long) 3, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"GetInstance", (long) 1, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"CreateInstance", (long) 2, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"ModifyInstance", (long) 3, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"DeleteInstance", (long) 4, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"EnumInstanceNames", (long) 5, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"EnumInstances", (long) 6, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"GetClass", (long) 7, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"EnumClasses", (long) 8, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"EnumClassNames", (long) 9, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"DeleteClass", (long) 10, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"AssociatorNames", (long) 11, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"Associators", (long) 12, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"ReferenceNames", (long) 13, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"References", (long) 14, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"GetProperty", (long) 15, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"SetProperty", (long) 16, 0, 0, 0},
{0}};

#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C"
#endif
SWIGEXPORT(void) SWIG_init(void) {
    static PyObject *SWIG_globals = 0; 
    static int       typeinit = 0;
    PyObject *m, *d;
    int       i;
    if (!SWIG_globals) SWIG_globals = SWIG_newvarlink();
    m = Py_InitModule((char *) SWIG_name, SwigMethods);
    d = PyModule_GetDict(m);
    
    if (!typeinit) {
        for (i = 0; swig_types_initial[i]; i++) {
            swig_types[i] = SWIG_TypeRegister(swig_types_initial[i]);
        }
        typeinit = 1;
    }
    SWIG_InstallConstants(d,swig_const_table);
    
}

